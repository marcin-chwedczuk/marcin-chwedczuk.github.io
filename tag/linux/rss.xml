<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>How to use grep command</title>
	  <link>//how-to-use-grep-command</link>
	  <author></author>
	  <pubDate>2016-08-20T02:00:00+02:00</pubDate>
	  <guid>//how-to-use-grep-command</guid>
	  <description><![CDATA[
	     `grep` is a command line program that allows us to find all occurrences of given pattern
in the text.
We can use `grep` to search command standard output, for example:
{% highlight no-highlight %}
$ # grep will print lines containing "eth0" phrase
$ ifconfig | grep eth0
eth0      Link encap:Ethernet  HWaddr xx:xx:xx:xx:xx:xx
        
$ cat /usr/share/dict/words | grep nerd
nerd
nerd's
nerdier
(...)
{% endhighlight %}
We may also use `grep` to find given pattern in the set of text files:
{% highlight no-highlight %}
$ cat > foo.txt <<EOF
foo
FOO
foobar
xfoox
in the middle of the line foo is
EOF
    
$ # search for foo in foo.txt file
$ grep foo foo.txt
foo
foobar
(...)
        
$ cat > bar.txt <<EOF
bar
Bar
foobar
EOF
    
$ # search for foo in foo.txt and bar.txt 
$ grep foo {foo,bar}.txt
foo.txt:foo
(...)
bar.txt:foobar
{% endhighlight %}
NOTE: In the last example I used 
[heredoc's](http://tldp.org/LDP/abs/html/here-docs.html) to create `foo.txt` and
`bar.txt` files.   
NOTE: `{foo,bar}.txt` is expanded by bash into `foo.txt bar.txt`, this is
called [brace expansion](https://en.wikipedia.org/wiki/Bash_(Unix_shell)#Brace_expansion).  

We may also peform recursive searches using `-r` or `-R` options (`grep` will search in
every file contained in the specified directory and it's subdirectories):
{% highlight no-highlight %}
$ tree grep_exercises/
grep_exercises/
  |-- bar.txt
  `-- foo.txt
     
$ grep -r foo grep_exercises/
grep_exercises/bar.txt:foobar
grep_exercises/foo.txt:foo
(...)
{% endhighlight %}

#### grep command in details

General `grep` invocation has form:
{% highlight no-highlight %}
$ grep [options] pattern [files|directories]
{% endhighlight %}
`grep` searches standard input when no files were given or
specified files/directories for occurrences of the `pattern`.
When `grep` finds a line that contains the `pattern` it prints it to
the standard output.
When we search multiple files each printed line
is prefixed by a filename.

##### -i (-\-ignore-case)
By default `grep` is case sensitive, so pattern `foo` doesn't match
word `FOO`, we can perform case insensitive search using `-i` option:
{% highlight no-highlight %}
$ grep bar bar.txt
bar
foobar

$ grep -i bar bar.txt
bar
Bar
foobar
{% endhighlight %}

##### -v (-\-invert-match)

We can use `-v` option to negate search, that is to print
all lines that don't contain given pattern:
{% highlight no-highlight %}
$ cat bar.txt 
bar
Bar
foobar

$ grep -v foo bar.txt 
bar
Bar
{% endhighlight %}

##### -r and -R

Both options can be used to perform recursive searches, the only difference
is that `-R` will follow 
[symbolic links](https://en.wikipedia.org/wiki/Symbolic_link#POSIX_and_Unix-like_operating_systems)
during search while `-r` won't.

When we are performing recursive search often 
we want to exclude some directory from search e.g. 
`.git` directory when we are searching inside GIT repository,
`--exclude-dir` option allows us to do exactly that:
{% highlight no-highlight %}
$ # create git repository
$ git init; git add *.txt; git commit -m 'foo';
$ grep -r foo .
./bar.txt:foobar
./foo.txt:foo
./foo.txt:foobar
./foo.txt:xfoox
./foo.txt:in the middle of the line foo is
Binary file ./.git/index matches
./.git/logs/refs/heads/master:00000000000...
./.git/logs/HEAD:000000000000000000000000...
./.git/COMMIT_EDITMSG:foo

$ grep -r foo --exclude-dir=.git .
./bar.txt:foobar
./foo.txt:foo
./foo.txt:foobar
./foo.txt:xfoox
./foo.txt:in the middle of the line foo is
{% endhighlight %}

We may limit set of files that will be searched during recursive search using
`--include`/`--exclude` options. Both of these options take 
[shell GLOB](https://en.wikipedia.org/wiki/Glob_(programming)#Unix) as an argument.
`--include` will force `grep` to check only files that match GLOB.
`--exclude` will force `grep` to skip any files that don't match GLOB.
For example to search for `foo` pattern only in `.txt` files we may use command:
{% highlight no-highlight %}
$ grep -r --include='*.txt' .
bar.txt:bar
bar.txt:Bar
bar.txt:foobar
foo.txt:foo
(...)
{% endhighlight %}

Another useful option when performing recursive searches is `-I`, it tells
`grep` to skip binary files when looking for the pattern.

##### -w (-\-word-regexp)

Sometime we want to match only whole words e.g. when we search for `foo` we don't
want matches like `foobar` or `xfoox`. `-w` option will force `grep` to perform
whole word search:
{% highlight no-highlight %}
$ grep foo foo.txt
foo
foobar
xfoox
in the middle of the line foo is

$ grep -w foo foo.txt
foo
in the middle of the line foo is
{% endhighlight %}

##### -c (-\-count)
`-c` option allow us to count number of occurrences of the pattern
inside searched files:
{% highlight no-highlight %}
$ grep -c foo foo.txt
4

$ grep -c foo *.txt
bar.txt:1
foo.txt:4
{% endhighlight %}

##### -n (-\-line-number)

`-n` option will force `grep` to prefix each found line with line number:
{% highlight no-highlight %}
$ grep -rn foo grep_exercises/
grep_exercises/bar.txt:3:foobar
grep_exercises/foo.txt:1:foo
grep_exercises/foo.txt:3:foobar
grep_exercises/foo.txt:4:xfoox
grep_exercises/foo.txt:5:in the middle of the line foo is
{% endhighlight %}

##### -l (-\-files-with-matches), -L (-\-files-without-match)

`-l` option will force `grep` to print only filenames of files that contain given pattern
instead of printing lines:
{% highlight no-highlight %}
$ grep -rl foo grep_exercises/
grep_exercises/bar.txt
grep_exercises/foo.txt
{% endhighlight %}
The is also `-L` option that will print only filenames of files that 
doesn't contain specified pattern.

##### -h (-\-no-filename), -H (-\-with-filename)

`-h` option will prevent printing of filenames when performing multifile search.
Similarly `-H` option will force `grep` to always print filenames:
{% highlight no-highlight %}
$ grep -H foo foo.txt 
foo.txt:foo
foo.txt:foobar
foo.txt:xfoox
foo.txt:in the middle of the line foo is
{% endhighlight %}

##### -A (-\-after-context), -B (-\-before-context) and -C (-\-context)
`-A`, `-B` and `-C` options allow us to print not only lines containing pattern
but also specified number of lines after (A) and before (B) them. `-C` option is
a shortcut to set both `-A` and `-B` to the same value:
{% highlight no-highlight %}
$ grep -B 1 -A 2 -w my /usr/share/dict/words
muzzling
my
myna
myna's
{% endhighlight %}

#### Basic regular expressions (BRE)

By default `grep` interpret pattern as a basic regular expression (BRE).
BREs are similar to shell GLOBs but are more powerful. Inside BRE we may use
the following special characters:

| Character/Expression | Meaning |
|:-:|-|
| `.` | Matches any single character |
| `*` | Matches zero or more repetitions of previous character or group |
| `[abc]` | Bracket expression matches single character. `[abc]` matches any of the characters `a`, `b` or `c`. `[0-9]` matches any digit. `[^abc]` matches any character that is *not* `a`, `b` or `c`. `[0-9abcdef]` matches any lowercase hex digit. Finally we can use character classes inside bracket expressions e.g. `[[:digit:]]` |
| `^` | Matches beginning of the line |
| `$` | Matches end of the line |

Any of the special characters used in BRE may be escaped by preceding 
them with a backslash (`\`).

OK, now let's see BRE in action:
{% highlight no-highlight %}
$ # first we will find all words that ends with 'cat'
$ grep 'cat$' /usr/share/dict/words
Muscat
bobcat
cat
(...)

$ # now let's find all 5 letter words in which second letter is
$ # a, e or i
$ grep '^.[aei]...$' /usr/share/dict/words | head
Aaron
Aesop
Aiken
(...)

$ # and let's finish by finding all hex numbers in the text
$ # we will assume that hex numbers have format 0xaabbcc
$ cat /proc/cpuinfo | grep '0x[0-9a-f]*'
microcode   : 0x9
microcode   : 0x9
(...)
{% endhighlight %}

BRE are even more powerful if we use grouping and more advanced operators.
Let's start with grouping, we may create groups by surrounding parts of the pattern
with `\(...\)`, then we may apply e.g. `*` to the entire group. For example to find
all words that have even number of characters we may write:
{% highlight no-highlight %}
$ grep '^\([a-z][a-z]\)*$' /usr/share/dict/words | head
aardvark
abacus
abacuses
(...)
{% endhighlight %}
This works because we are telling `grep` that we want to find any
number of repetitions of *pair of characters*.

Sometime we search for pattern like phone number that have fixed number
of digits in each part, we may use `\{...\}` operator to specify exact number
of repetitions of previous character or group:

| Expression | Meaning |
|:-:|-|
| `\{m\}` | Matches `m` repetitions of previous character or group e.g. `a{3}` matches `aaa` but not `aa` or `abc`. |
| `\{m,\}` | Matches at least `m` repetitions of previous character or group e.g. `a{2}` matches `aa`, `aaa` but not `a`. |
| `\{m,n\}` | Matches at least `m` and at most `n` repetitions of of previous character or group. |

For example to search for phone number in format `XXX-XX-XXXX` we will `grep`:
{% highlight no-highlight %}
$ grep '[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}' file
{% endhighlight %}

The last thing worth know about BRE is the possibility to use backreferences.
For example let's say that we search for all five letters palindromes, we may use
`\1`, `\2`, etc. placeholders to tell `grep` that we expect text that was matched by first group,
second group etc. in the place of placeholders:
{% highlight no-highlight %}
$ grep '^\(.\)\(.\).\2\1$' /usr/share/dict/words | head
civic
kayak
level
(...)
{% endhighlight %}

NOTE: Sometimes we just want to search using old plain text pattern, we may disable BRE
using `-F` grep option.

I didn't described all BRE features, if you are interested in details
please [check the standard](http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html#tag_09_03).
IMHO BRE are ugly and cumbersome to use, in the next
section I will quickly describe extended regular expressions that bring full power of
regexes to `grep`.

#### Extended regular expressions (ERE)

To enable extended regular expressions we must pass `-E` (`--extended-regexp`)
option to `grep`. ERE are similar to BRE with the exception that we don't need to
precede operators such as grouping with backslashes. To create a group in ERE 
we simply use `(foo)` pattern, and to specify number of matches for that group
we use `(foo){3}` pattern.
This looks *much* more cleaner compared to BRE `\(foo\)\{3\}`.

If we want to match
e.g. left parenthesis we need to escape it using backslash, for example to match `main()` text we
could use `main\(\)` pattern (or we could use `-F` option to match text as it is).

In ERE in addition to all special characters from BRE we may use:

| Character/Expression | Meaning |
|:-:|-|
| `+` | Matches one or more repetitions of previous character or group |
| `?` | Matches zero or one occurrences of previous character or group |
| `|` | Alternation - allows to match one of the specified patterns from set e.g. `0(x|X)` will match `0x` and `0X` texts |

Now let's see some examples of ERE in action:
{% highlight no-highlight %}
$ # let's find all phone numbers in format XXXX-XX-XXX that may
$ # be optionally prefixed by country code (+XX)
$ grep -E '(\(\+[0-9]{2}\) )?[0-9]{4}-[0-9]{2}-[0-9]{3}' file

$ # let's find all percent values in the text
$ grep -E '[0-9]+%' file

$ # let's find all email addresses, here we use -o option
$ # to print only matched text
$ grep -E -o '[A-Za-z0-9._]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}' file
{% endhighlight %}

Most modern versions of `grep` support even more powerful versions of regular expressions
that include shortcuts for character classes like `\d` for `[0-9]` and `\D` for `[^0-9]` and more
advanced anchors like `\b` (matches word start or end).
Check your local version of `grep` to find out what features are available.

That's all that I wanted to say about `grep` command. Happy grepping!


	  ]]></description>
	</item>

	<item>
	  <title>How to use find command</title>
	  <link>//how-to-use-find-command</link>
	  <author></author>
	  <pubDate>2016-07-26T02:00:00+02:00</pubDate>
	  <guid>//how-to-use-find-command</guid>
	  <description><![CDATA[
	     Linux `find` command may be used to find files and directories
that meet specified conditions. The most popular
conditions test file size, filename and file type 
(do we want regular files, directories or both).
By default `find` prints paths to found files and directories but it can 
perform various operations on found files e.g. it may remove them.
In this article I will present how to use `find` and how to create complex
search conditions, so let's begin.

Generally `find` invocation looks like this:
{% highlight no-highlight %}
$ find startDirectory filterOrAction1 ... filterOrActionN
{% endhighlight %}
Here `startDirectory` is root of directories tree that we want to search.
After `startDirectory` we pass zero or more filters and/or actions.
Filters define conditions that given file/directory must meet, e.g. filter `-type f`
tells `find` that it should only process regular files and skip other file system
objects like directories or named pipes. Actions on the other hand define what
should be done with found files/directories, we may for example print 
their filenames using `-print` action or we may delete them via `-delete` action.

If you pass no arguments to `find` as in:
{% highlight no-highlight %}
$ find
{% endhighlight %}
it will assume that `startDirectory` is current directory and that you want to
print filenames of all found files/directories. In other words it will be equivalent to
invocation:
{% highlight no-highlight %}
$ find . -print
{% endhighlight %}

`find` performs search by enumerating all files and directories contained in
the `startDirectory`. For each file/directory `find` executes specified filters and
actions, from left to right and stops on the first filter or action that returns `false`.
Filters return `false` when filter condition is not met. Actions return `false` when
action ends with an error
e.g. user has insufficient permissions to remove file for `-delete` action.

Image below presents how `find dir -type f -name '*.java' -print` works
assuming that `dir` contains two files `foo.java` and `foo.cpp`:
![Illustration how find works](assets/images/2016-07-26/find1_2.svg)
To keep image size reasonable I skipped one more "file" that was checked by `find` in
our example - the `dir` directory itself. 

Before you proceed please answer the following questions 
(use `dir` directory from previous example). 
Verify your answers by running `find` and checking it's output:

* What will be printed by `find dir -print -print`?
* What will be printed by `find dir -print -name '*.java' -print`?
* What will happen when we specify no action like in `find dir -name 'foo*'`?

#### Filters

After reading previous section you should have firm understanding
how `find` works. Now let's move to describing most usefull filters
provided by `find`.

##### Type filter

We will start with `-type` filter that allows us to find 
filesystem objects that have specified type. 
For example to find only directories
we will use `-type d` and to find only regular files we will use `-type f`.
`-type` filter takes single parameter that is one letter abbreviation of 
filesystem object type.
All available values are presented in table below:

|-|
| Argument | Description |
|:-:|
| b | Block device e.g. `/dev/sda` on most modern systems |
| c | Character device e.g. `/dev/tty0` |
| d | Directory e.g. `/etc` |
| p | Named pipe |
| f | Regular file e.g. `/etc/profile` |
| l | Symbolic link |
| s | Socket |
|-|

##### Name filter

`-name` filter allows us to find files/directories that have names
that match specified pattern e.g. `*.java`. Only filename is checked 
against the pattern, rest
of the file path is ignored e.g. `./usr/foo` file doesn't match `u*foo` pattern, but
`./uberfoo` file does.
`-name` filter performs *case sensitive* comparisons so `foo` doesn't match `FOO` pattern,
to use case insensitive comparisons use `-iname` filter instead.

Inside name filter pattern some characters like `*` or expressions like `[abc]` have
special meaning (see [glob expression](https://en.wikipedia.org/wiki/Glob_(programming))).
Table below lists all special expressions that may be used inside patterns:

|-|-|-|
| Special character / expression | Meaning |
|:-:|-|-|
| `*` | Matches zero or more characters |
| `?` | Matches single character |
| `[abc]` | Character set. Matches any character in set |
| `[!abc]` | Inverted character set. Matches any character NOT in set |
| `[a-z]` | Character range. Matches any character in range |
| `[!a-z]` | Inverted character range. Matches any character NOT in range |
|-|-|

BE CAREFUL: It is always
good idea to quote patterns using single quotes to prevent shell expansion of the pattern

Examples:

* To find all java files we can use `-name '*.java'` filter
* To find all files that have three letter names we may use `-name '???'` filter
* To find all files that have names starting with `a`, `b` or `c` we can use `-name '[abc]*'` filter
* To find all files that have names that doesn't start with `1` we may use `-name '[!1]*'` filter

##### Size filter

`-size` filter can be used to search for files of given size, for example `find dir -size 1M` will find
all one megabyte files in `dir` directory. 

We may use `+` and `-` prefixes to
signify that we want files bigger or smaller than specified size e.g. `find dir -size +64k` will
find all files contained in `dir` directory that are bigger than 64 kilobytes.
Conversely `find dir -size -64k` will find all files in `dir` directory that are smaller than 64 kilobytes.

We may use popular `k`, `M`, `G` suffixes to signify kilo-, mega- and gigabytes, `c` suffix can be used to
specify file size in bytes.

##### Time filter

For every file filesystem tracks up to three times:

* `atime` or Access time - time when give file was last read
* `mtime` or Modification time - last time when contents of file changed
* `ctime` or Change time - last time when contents or attributes of file changed. 
 Here attributes refers to file metadata like filename or file permissions

To find all files that were modified exactly one day ago we may use `-mtime 1` filter.
And to find all files that were accessed exactly one minute ago we may use `-amin 1` filter.

First letter of these filters (`a`, `m` or `c`) signifies on what file time filter should operate,
next word (`time` or `min`) signifies in what time unit will be passed argument - we may use only
days or minutes.

As with size filter we may use `+` and `-` prefixes to signify that we want to find files
that were modified at most one day ago (`-mtime -1`) or at least one day ago (`-mtime +1`).

##### Permissions filter

`-perm` filter can be used to find files/dirs that have specific permissions set.

In the examples I will use octal notation for permissions e.g. `-perm 644` but `-perm` filter
also supports symbolic notation e.g. `-perm u=rw`.  
Here is quick remainder of the octal
notation:
{% highlight no-highlight %}
    owner  |  group  |  others
    r w x  |  r w x  |  r w x
    4 2 1  |  4 2 1  |  4 2 1
{% endhighlight %}

To find all files/dirs that have permissions set 
exactly to `644` we may use `find dir -perm 644`, this will find
all files/dirs that are readable/writable for file owner and readable for everyone else.

Often we want to find files that have *at least* specified permissions, to do so 
we must prefix permissions with minus sign (`-`) e.g. `-perm -644`.
Filter `-perm -644` will
find all files that are at least readable/writable for file owner and readable for everybody
else e.g. files with permissions `666`, `655` and `777` will be included.

Sometimes we want to find files that have a common permission bit with specified permission, 
to do this
we should prefix permissions with `/` character. For example to find files that have
*any* permission for others set we may use `find dir -perm /007`.

#### Actions

No let's see what we can do with found files. In this section I will describe most
popular actions used with `find`.

##### print and print0 actions

`-print` and `-print0` actions print on `stdout` path to found files.
Printed path is **relative** to `startDirectory` so:
{% highlight no-highlight %}
$ find dir -print
dir
dir/foo.java
dir/foo.cpp

$ find ./././dir -print
./././dir
./././dir/foo.java
./././dir/foo.cpp

$ readlink -f dir
/home/user/dir

$ find $(readlink -f dir) -print
/home/user/dir
/home/user/dir/foo.java
/home/user/dir/foo.cpp
{% endhighlight %}
In the last example I used `readlink` command to get absolute path to `dir` directory.

When we pipe `find` output to other programs like `xargs` we should definitely use `-print0`
action. The main difference between `-print` and `-print0` is that the last one
uses `NUL` character (`\0`) instead of new line to separate paths. 
This allows other tools to process
paths that contains spaces including new lines without problems. 
Here's how we use it with `xargs`:
{% highlight no-highlight %}
find dir -print0 | xargs -0 -n 1 echo
{% endhighlight %}
The important part is to pass `-0` or `--null` option to `xargs` so it will know that
we will separate paths using `NUL` character.

##### delete action

This action is pretty self-explanatory, you may use it to remove files.

WARNING: Please remember that `find` processes filters and actions from left to right so
if you you put `-delete` action first `find` will try to delete all found files and
directories before trying other filters/actions.

If the delete operation fail `-delete` will return `false`, otherwise it will
return `true`.

Example usage:
{% highlight no-highlight %}
$ find dir -name '*foo*' -delete
{% endhighlight %}

##### exec action

`-exec` is the most useful action that you can use with `find`. It allows you
to execute arbitrary command for each found file. 
You must pass command to execute after `-exec` argument and you must end it with
`;` character. 
Since semicolon has special meaning in the shell you must escape it using `\;` or `';'`.
Inside command you may use `{}` placeholder that will be replaced by the path to 
the found file before command execution.
`-exec` action returns `true` if executed command returned `0` exit code, otherwise
it will return `false`.

Let's see some examples:
{% highlight no-highlight %}
$ find dir -name 'foo*' -exec echo "found file: {}" ';'
found file: dir/foo.java
found file: dir/foo.cpp


$ ls -l dir/*
-rw-rw-r-- 1 user user 0 lip 30 11:22 dir/foo.cpp
-rw-rw-r-- 1 user user 0 lip 30 11:22 dir/foo.java

$ find dir -name 'foo*' -exec chmod o+w {} \;

$ ls -l dir/*
-rw-rw-rw- 1 user user 0 lip 30 11:22 dir/foo.cpp
-rw-rw-rw- 1 user user 0 lip 30 11:22 dir/foo.java
{% endhighlight %}

##### ok action

`-ok` is like `-exec` action with the exception that `find` will ask you
for confirmation before executing command:
{% highlight no-highlight %}
$ find dir -ok chmod o+w {} \;
< chmod ... dir > ? y
< chmod ... dir/foo.java > ? n
< chmod ... dir/a > ? n
< chmod ... dir/foo.cpp > ? y
< chmod ... dir/c > ? y
< chmod ... dir/b > ? n
< chmod ... dir/d > ? n
{% endhighlight %}

#### Advanced expressions

As we have seen `find` command is very versatile. We already know how to
create complex search conditions and how to execute actions for found files.
Yet we still don't know full power of `find`, now it's time to change that.

Let's start with simple example: we want to find all files in `dir` directory
that have names that  *doesn't* end with `.java`. 
It's impossible to do so with `-name` filter that we know. 
But if there was a way to negate a filter it would be simple, right?
In fact there is, just precede a filter with `!`
character to negate it (since `!` is special shell character we need to escape it e.g. `\!`). 
{% highlight no-highlight %}
$ tree dir
 dir
 |-- foo.cpp
 |-- foo.java
 `-- foo.py

$ find dir \! -name '*.java' -type f
dir/foo.py
dir/foo.cpp
{% endhighlight %}

Beside negation `find` also provides two other boolean operators: AND (`-a`) and OR (`-o`).
We may also use parentheses to group filters/actions into subexpressions
(as you probably guessed parentheses have special meaning in the shell and we must 
escape them e.g. `\(` or `')'`).

When `find` evaluates complex expressions it tries to 
[short-circuit](https://en.wikipedia.org/wiki/Short-circuit_evaluation) AND and OR
operators. Short-circuiting means that if the left 
operand of the AND is false right operand is not evaluated,
and if the left operand of OR is true the right operand is not evaluated. This is very
important when we mix filters with actions.
Let's see some examples that show us AND and OR operators in action:
{% highlight no-highlight %}
$ # find files ending with .cpp or .py
$ find dir \( -name '*.cpp' -o -name '*.py' \)
dir/foo.py
dir/foo.cpp

$ # print files once but directories twice
$ find dir \( -type f -a -print \) -o \( -type d -a -print -a -print \)
dir
dir
dir/foo.java
dir/foo.py
dir/foo.cpp

$ # this one is tricky, we remove all NON-DIRECTORIES
$ # e.g. files, pipes, sockets etc.
$ # here we use fact that OR operator short-circuit's
$ find dir -type d -o -delete
{% endhighlight %}

The last think to remember is that `\( filter1 -a filter2 -a filter3 \)` expression is 
equivalent to `\( filter1 filter2 filter3 \)`.

#### Other

Before we end I want to mention two handy options `-mindepth` and `-maxdepth` that
allow us to limit search depth to a specific range. Here's how to use them:
{% highlight no-highlight %}
$ mkdir -p dir/dir1/dir2/dir3/dir4

$ tree dir
 dir
 `-- dir1
     `-- dir2
         `-- dir3
             `-- dir4

$ find dir -mindepth 1 -maxdepth 3
dir/dir1
dir/dir1/dir2
dir/dir1/dir2/dir3

$ find dir
dir
dir/dir1
dir/dir1/dir2
dir/dir1/dir2/dir3
dir/dir1/dir2/dir3/dir4

{% endhighlight %}
Intuitively `mindepth`/`maxdepth` tells us how many `/` characters we want to have in file path.

#### `findform` application 

To help you quickly recall all most useful `find` options I created simple interactive
app that provides GUI for `find`, you may add it as a bookmark if you find it useful.

<a href="/assets/apps/findform/">Open FindFORM app</a>

That's all for today, thanks for reading!

	  ]]></description>
	</item>

	<item>
	  <title>How to use xargs</title>
	  <link>//how-to-use-xargs</link>
	  <author></author>
	  <pubDate>2016-07-09T02:00:00+02:00</pubDate>
	  <guid>//how-to-use-xargs</guid>
	  <description><![CDATA[
	     In this blog post I will show you how to use `xargs` command line utility.

We will start by creating simple bash script `showargs` that prints all arguments
passed to it on command line:
{% highlight bash %}
#!/usr/bin/env bash

# echo -n option prints text without new line
echo -n "[ "
for arg in "$@"; do
    echo -n "{$arg} "
done
echo "]"
{% endhighlight %}
We must make this script executable by running `chmod +x showargs`.
Now we can check how it works:
{% highlight no-highlight %}
$ ./showargs 
[ ]

$ ./showargs a b c
[ {a} {b} {c} ]

$ ./showargs "foo bar" '#$%'
[ {foo bar} {#$%} ]

$ ./showargs 1 "foo bar" '()' blah
[ {1} {foo bar} {()} {blah} ]
{% endhighlight %}
As you can see invocation of `showargs` prints single line that starts with `[` and
ends with `]` character 
and contains all parameters passed to script surrounded by `{` and `}`
braces. This will help us to see if arguments with spaces are properly passed 
to our script.

#### How xargs work

When we run `xargs cmd` in the terminal, `xargs` first reads all
lines from standard input, then concatenates them using space character, then
it appends that concatenated input to `cmd` and finally it executes this
extended command in the shell. It may sound a bit complicated but it is
really a simple process:
![How xargs works](assets/images/2016-07-09/xargs_lines.svg)

Let's play a bit with `xargs` in the terminal.
We'll use `showargs` script to snoop arguments passed by `xargs` to the command.
{% highlight no-highlight %}
$ echo a b c d | xargs ./showargs
[ {a} {b} {c} {d} ]

$ cat example
a b c
d
e f
$ cat example | xargs ./showargs 
[ {a} {b} {c} {d} {e} {f} ]
{% endhighlight %}
As we can see it doesn't matter for `xargs` if arguments are on single line or in
many lines of input.
It also doesn't matter if arguments are separated by space, newline or tabs:
{% highlight no-highlight %}
$ echo -e "foo\nbar\n\n\t\tnyu"
foo
bar

                nyu

$ echo -e "foo\nbar\n\n\t\tnyu" | xargs ./showargs 
[ {foo} {bar} {nyu} ]
{% endhighlight %}

We must also know that `xargs` properly escapes special shell characters like `|` or `>`
when it builds command arguments:
{% highlight no-highlight %}
$ echo a '>' '|' d
a > | d

$ echo a '>' '|' d | xargs ./showargs 
[ {a} {>} {|} {d} ]
{% endhighlight %}
NOTE: Here I used single quotes to escape special characters in echo command, 
but you may also use backslash e.g. `\>`.

##### Custom argument separator (delimiter)

Sometimes it happens that arguments to the program are not separated by spaces but
e.g. by commas. By default `xargs` treats 
[whitespace](https://en.wikipedia.org/wiki/Whitespace_character) 
as argument separators but this can
be changed by using `-d` option:
{% highlight no-highlight %}
$ echo foo,bar,nyu | xargs ./showargs 
[ {foo,bar,nyu} ]

$ echo foo,bar,nyu | xargs -d, ./showargs 
[ {foo} {bar} {nyu
} ]

$ echo -n foo,bar,nyu | xargs -d, ./showargs 
[ {foo} {bar} {nyu} ]

$ echo foo,bar,nyu | head -c -1 | xargs -d, ./showargs 
[ {foo} {bar} {nyu} ]

$ echo foo,bar,,nyu | head -c -1 | xargs -d, ./showargs 
[ {foo} {bar} {} {nyu} ]
{% endhighlight %}
Now `xargs` splits arguments on `,` character but we have encountered another problem.
When we split arguments on `,` the last newline is treated as part of the last argument.
We can fix this by preventing `echo` from printing newline with `-n` option, but this can
be a problem when we get input from a file. If we are sure that file always ends
with a newline we may truncate it using `head -c -1` command, that will print
all characters of standard input except last.

It's worth to notice that when we use nonstandard separators arguments can contain spaces:
{% highlight no-highlight %}
$ echo -n foo,bar a la baz,nya | xargs -d, ./showargs 
[ {foo} {bar a la baz} {nya} ]
{% endhighlight %}

Often we want to pass entire line from file as a single argument, we may easily
achive this with `xargs` by using newline as argument separator:
{% highlight no-highlight %}
$ cat example 
/foo/bar/file with space
/other-file
/dir with space/file

$ cat example | xargs -d\\n ./showargs 
[ {/foo/bar/file with space} {/other-file} {/dir with space/file} ]
{% endhighlight %}
NOTE: Here we used `\\` to escape `\` character in the shell, we may also use single quotes
as in `-d'\n'`

WARNING: Filenames in Unix can contain newline characters. Use this trick
only when you are sure that filenames in input file will not contain newlines.

##### Executing command per argument or per line of input

`xargs` have two modes of operation. We already know one of them: gather all arguments
and execute command. The other is to execute command per argument of per line of input,
as illustrated below:
![xargs 2nd mode of operation](assets/images/2016-07-09/xargs_many.svg)

We may execute command per fixed number of arguments by using `-n` option:
{% highlight no-highlight %}
$ echo a b c d | xargs -n1 ./showargs 
[ {a} ]
[ {b} ]
[ {c} ]
[ {d} ]

$ echo a b c d | xargs -n2 ./showargs 
[ {a} {b} ]
[ {c} {d} ]

$ echo a b c d | xargs -n3 ./showargs 
[ {a} {b} {c} ]
[ {d} ]
{% endhighlight %}
As we can see we may specify number of arguments that are needed by command.

WARNING: There may be not enough arguments for the
last command but `xargs` executes it anyway.

We may also execute command per fixed number of lines of input using `-L` option:
{% highlight no-highlight %}
$ cat example 
arg1 arg2 arg3
arg4
arg5 arg6

$ cat example | xargs -L1 ./showargs 
[ {arg1} {arg2} {arg3} ]
[ {arg4} ]
[ {arg5} {arg6} ]

$ cat example | xargs -L2 ./showargs 
[ {arg1} {arg2} {arg3} {arg4} ]
[ {arg5} {arg6} ]
{% endhighlight %}
As with `-n` option we must be careful when we execute command per more than one line 
of input because last command may not get
all needed arguments.

I personally find `-L1` option very useful but it doesn't work well with `-d` option.
{% highlight no-highlight %}
$ cat example 
arg1,"arg2 bar",arg3
arg4
arg5,arg6,arg7

$ cat example | xargs -L1 -d, ./showargs 
[ {arg1} ]
[ {"arg2 bar"} ]
[ {arg3
arg4
arg5} ]
[ {arg6} ]
[ {arg7
} ]

$ cat example | tr ',' ' ' |  xargs -L1 ./showargs 
[ {arg1} {arg2 bar} {arg3} ]
[ {arg4} ]
[ {arg5} {arg6} {arg7} ]
{% endhighlight %}
Here we used `tr` utility to convert `,` into spaces so we can avoid using `-d,` option.
As we can see `xargs` preserved spaces in arguments surrounded by double quotes (this
works with single quotes too).

##### Passing additional argument to the command

Sometimes we need to provide additional arguments to `xargs` command, we may do this
in a very simple way:
{% highlight no-highlight %}
$ echo a b c d | xargs ./showargs 
[ {a} {b} {c} {d} ]

$ echo a b c d | xargs ./showargs --long-arg -s
[ {--long-arg} {-s} {a} {b} {c} {d} ]
{% endhighlight %}
But what if our command expects arguments in format:
{% highlight no-highlight %}
some-command --input input-file --output output-file
{% endhighlight %}
To work with command like that we must use `xargs` `-I` option:
{% highlight no-highlight %}
$ cat example
/file1
/file with spaces
/file3

$ cat example | xargs -I{} ./showargs --input {} --output {}.processed
[ {--input} {/file1} {--output} {/file1.processed} ]
[ {--input} {/file with spaces} {--output} {/file with spaces.processed} ]
[ {--input} {/file3} {--output} {/file3.processed} ]
{% endhighlight %}
After `-I` we must provide placeholder string that will be replaced by actual
command arguments. People usually use `{}` but we may use any string:
{% highlight no-highlight %}
$ cat example | xargs -Ifoo ./showargs --input foo --output foo.processed
{% endhighlight %}

`-I` option is really useful but it doesn't work with `-n` option, so if you plan to use
`-I` you must process input line by line.

##### Other useful options

With `-p` option `xargs` will prompt for user approval
before executing command:
{% highlight no-highlight %}
$ touch file{1..3}

$ echo file{1..3}
file1 file2 file3
        
$ echo file{1..3} | xargs -n1 -p rm
rm file1 ?...y
rm file2 ?...n
rm file3 ?...y
        
$ ls file*
file2
{% endhighlight %}

`-0` or `--null` option is often used with `find` command to avoid problems
with filenames that contain spaces or other non alphanumeric characters.
`-0` option tells `xargs` that `\0` character will be used to separate arguments:
{% highlight no-highlight %}
$ touch file\ with\ space

$ ls file*
file with space

$ find -type f -name '*with*'
./file with space

$ find -type f -name '*with*' | xargs ./showargs 
[ {./file} {with} {space} ]

$ find -type f -name '*with*' -print0 | xargs -0 ./showargs 
[ {./file with space} ]
{% endhighlight %}
TIP: Always use `-print0` and `-0` options when working with `find`.

The last option that can be really useful is `-P`. This can be used to
execute commands in parallel:
{% highlight no-highlight %}
$ echo {1..9} | tr '[:digit:]' '1'
1 1 1 1 1 1 1 1 1

# takes 9 seconds
$ echo {1..9} | tr '[:digit:]' '1' | xargs -n1 sleep

# takes 3 seconds
$ echo {1..9} | tr '[:digit:]' '1' | xargs -n1 -P4 sleep
{% endhighlight %}
By default commands are executed sequentially (`-P1`).

I wasn't able to describe all `xargs` options, 
as usually you can find all of them on `xargs` manual page.

Thanks for reading!

	  ]]></description>
	</item>


</channel>
</rss>

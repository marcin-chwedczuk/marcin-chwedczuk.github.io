<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Lambda expressions in Kotlin</title>
	  <link>//lambda-expressions-in-kotlin</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2017-06-10T02:00:00+02:00</pubDate>
	  <guid>//lambda-expressions-in-kotlin</guid>
	  <description><![CDATA[
	     <p>In this blog post we will learn about Kotlin lambda expressions
and how they are compiled to JVM bytecode.</p>

<h4 id="basic-syntax">Basic syntax</h4>

<p>To create lambda expression that just prints <code class="highlighter-rouge">Hello, world!</code>
we write:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val printHelloWorld = {
   println("Hello, world!")
}</code></pre></figure>

<p>We may invoke this function using either syntax:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">printHelloWorld()
// or
printHelloWorld.invoke()</code></pre></figure>

<p>The former is idiomatic and should be used in your code.</p>

<p>When we need to create a lambda that takes parameters we
use syntax:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val sayHello = { user: String -&gt; 
   println("Hello, $user!") 
}
sayHello("johnny")
// or with multiple parameters
val printSummary = { user: String, score: Int -&gt; 
   println("User '$user' get $score points.")
}
printSummary("johnny", 123)</code></pre></figure>

<p>When types of parameters may be inferred from the context we may skip them
as in:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val names = arrayOf("joe", "ann", "molly", "dolly")
names.sortedBy { name -&gt; name.length }
// equivalent to
names.sortedBy { name: String -&gt; name.length }</code></pre></figure>

<p>When working with Kotlin Sequence library you often need to define
short function literals (another name for a lambda expression) that take only
one parameter, for example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val russianNames = arrayOf("Maksim", "Artem", "Sophia", "Maria", "Maksim")

val selectedName = russianNames
      .filter { name -&gt; name.startsWith("m", ignoreCase = true) }
      .sortedBy { name -&gt; name.length }
      .firstOrNull()</code></pre></figure>

<p>For this special case Kotlin provides a shortcut, instead of writing:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">.filter { name -&gt; name.startsWith("m", ignoreCase = true) }
// we may write
.filter { it.startsWith("m", ignoreCase = true) }</code></pre></figure>

<p>Notice that we skipped parameter declaration altogether and 
use <code class="highlighter-rouge">it</code> keyword to access parameter value. 
If we rewrite our earlier example to use this new feature
we get not only shorter but also much more clearer code:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val selectedName = russianNames
      .filter { it.startsWith("m", ignoreCase = true) }
      .sortedBy { it.length }
      .firstOrNull()</code></pre></figure>

<p>Function literals in Kotlin always return a value. By default
value of the last expression in a lambda body is returned, for example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val produceValue = { "foo" }
println(produceValue()) // prints "foo"

val max = { a: Int, b: Int -&gt;
  if (a &gt; b)
      a
  else
      b
}
println(max(10,4)) // prints "10"</code></pre></figure>

<p>Sometimes we want to return early from a lambda body, in this case
we must follow “return-at-label” syntax:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val doStuff = lambda@ { stopEarly: Boolean -&gt;
   println("line 1")
   if (stopEarly) return@lambda
   println("line 2")
}

doStuff(true)
doStuff(false)</code></pre></figure>

<p>First we tag lambda expression with label <code class="highlighter-rouge">lambda@</code>.
You may use any name you like but label must ends with <code class="highlighter-rouge">@</code> character
(called ‘at’ character).
Then inside lambda body to signify return we use <code class="highlighter-rouge">return</code> keyword followed
by label name. There must be no whitespace between <code class="highlighter-rouge">return</code>
and label name.</p>

<p>Since “return-at-label” syntax is a bit cumbersome, we may use alternative
approach.
Instead of using a lambda expression we may use an anonymous function:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val doStuff = fun(stopEarly: Boolean) {
   println("line 1")
   if (stopEarly) return
   println("line 2")
}</code></pre></figure>

<p>Inside anonymous function <code class="highlighter-rouge">return</code> works like in any other Kotlin function.
Anonymous functions can also be used in cases when we must specify return
type of lambda explicitly:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val returnAny = {
   "foo" as Any
}

val returnAny2 = 
   fun(): Any = "foo"</code></pre></figure>

<p>Sometimes you do not need a value of particular lambda parameter,
in this case to avoid mistakes you may replace parameter name with <code class="highlighter-rouge">_</code>.
For example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">(1..5)
   .map { _ -&gt; rand.nextInt(100) }
   .forEach { println(it) }</code></pre></figure>

<h5 id="function-types">Function types</h5>

<p>Kotlin provides succinct syntax for specifying function types,
for example <code class="highlighter-rouge">() -&gt; Unit</code> is type of a function that doesn’t take
any parameters and returns nothing, and <code class="highlighter-rouge">(Int) -&gt; Int</code> is type
of a function that takes single parameter of type <code class="highlighter-rouge">Int</code> and returns
value of type <code class="highlighter-rouge">Int</code>. Here are more examples:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val fun1: (Int,Int)-&gt;Int = 
   { a,b -&gt; Math.max(a,b) }

val fun2: (String,MutableList&lt;String&gt;)-&gt;Unit =
   { s,list -&gt; list.add(s) }

val fun3: (Int,(Int)-&gt;Int)-&gt;Int = 
   { value, func -&gt; func(value) }</code></pre></figure>

<p>I believe that <code class="highlighter-rouge">fun1</code> and <code class="highlighter-rouge">fun2</code> declarations needs no explanation.
When it comes to <code class="highlighter-rouge">fun3</code> it is a higher level function, it
returns an integer and takes two arguments,
an integer and a function that takes an integer
and returns an integer.</p>

<p>When we use function types we may also provide names
for parameters, this further improves clarity of
code:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val sin: (angleInRadians: Double) -&gt; Double =
    Math::sin</code></pre></figure>

<p>In the example above I used method reference <code class="highlighter-rouge">Math::sin</code>,
this is equivalent to <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">Math.sin(x)</span><span class="w"> </span><span class="p">}</span></code>.</p>

<h5 id="type-aliases">Type aliases</h5>

<p>Since repeating function types may be tiring and error prone,
we should use Kotlin type aliases to give them meaningful names.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">typealias IntToStringConverter = 
   (Int) -&gt; String

typealias StringListAppender = 
   (String,MutableList&lt;String&gt;)-&gt;Unit</code></pre></figure>

<p>Now we may use aliases instead of repeating types in our declarations, e.g.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val fun2: StringListAppender =
   { s,list -&gt; list.add(s) }</code></pre></figure>

<p>The last cool thing about type aliases is that they
can use generic parameters. This allows us to
easily create types like:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">typealias Predicate&lt;T&gt; = (T) -&gt; Boolean
typealias Converter&lt;FROM,TO&gt; = (FROM) -&gt; TO</code></pre></figure>

<h5 id="closures">Closures</h5>

<p>Kotlin lambda expressions may be passed as arguments and returned
from functions. This allows us to apply many techniques from functional
programming. For example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">typealias Counter = ()-&gt;Int

fun counter(initValue: Int): Counter {
    var n = initValue
    return { n++ }
}

fun main(args: Array&lt;String&gt;) {
    val c1 = counter(100)

    println(c1()) // 100
    println(c1()) // 101
    println(c1()) // 102
}</code></pre></figure>

<p>Yet best feature of Kotlin lambdas in comparison to Java 8
lambdas is support of true 
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a>
- using simple words this is a language feature that allows lambda expression
to access and modify all variables that are in scope of their declarations.
Java 8 lambdas can only access external variables but cannot modify
them, this may be quite limiting when we try to use functional programming
in Java.</p>

<p>Following program demonstrates how closures work in Kotlin:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">fun main(args: Array&lt;String&gt;) {
    var sum = 0
    (1..10).forEach { sum += it }
    println(sum)
}</code></pre></figure>

<p>Here we see that <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">sum</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="p">}</span></code> lambda can access and modify <code class="highlighter-rouge">sum</code> 
variable that is declared outside of lambda body.</p>

<h5 id="implementation">Implementation</h5>

<p>Now you may be wondering how lambda expressions are translated to
JVM bytecode. In Kotlin every lambda is compiled to a small class.
For example simple expression that doesn’t use any variables:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val printHelloWorld = {
    println("Hello, world!")
}</code></pre></figure>

<p>Is compiled to:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Metadata</span><span class="o">(</span><span class="cm">/*...*/</span><span class="o">)</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">AppKt</span><span class="n">$main$printHelloWorld</span><span class="err">$</span><span class="mi">1</span> 
        <span class="kd">extends</span> <span class="n">Lambda</span> <span class="kd">implements</span> <span class="n">Function0</span> <span class="o">{</span>
   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">AppKt$main$printHelloWorld</span><span class="err">$</span><span class="mi">1</span> <span class="n">INSTANCE</span> <span class="o">=</span> 
        <span class="k">new</span> <span class="n">AppKt$main$printHelloWorld</span><span class="err">$</span><span class="mi">1</span><span class="o">();</span>

    <span class="n">AppKt$main$printHelloWorld</span><span class="err">$</span><span class="mi">1</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="cm">/*arity:*/</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="n">invoke</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// actual body of lambda expression</span>
        <span class="n">String</span> <span class="n">var1</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This class was generated by Kotlin compiler
and uses types form Kotlin runtime to provide its
functionality. In particular it extends <code class="highlighter-rouge">Lambda</code> abstract
class. 
<code class="highlighter-rouge">Lambda</code> constructor takes single parameter that specify 
function arity - a number of parameters that lambda expression takes.
<code class="highlighter-rouge">Lambda</code> also implements <code class="highlighter-rouge">Function</code> and <code class="highlighter-rouge">FunctionBase</code> interfaces,
and provides simple <code class="highlighter-rouge">toString()</code> implementation that prints function 
type - in our case <code class="highlighter-rouge">() -&gt; kotlin.Unit</code>.
For your convinience here are simplified definitions of the above types:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// from Kotlin runtime (kotlin.* packages)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span> <span class="o">{</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FunctionBase</span> <span class="kd">extends</span> <span class="n">Function</span><span class="o">,</span> <span class="n">Serializable</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">getArity</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Lambda</span> <span class="kd">implements</span> <span class="n">FunctionBase</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">arity</span><span class="o">;</span>

   <span class="kd">public</span> <span class="n">Lambda</span><span class="o">(</span><span class="kt">int</span> <span class="n">arity</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">arity</span> <span class="o">=</span> <span class="n">arity</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">int</span> <span class="n">getArity</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">arity</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="n">String</span> <span class="n">toString</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">Reflection</span><span class="o">.</span><span class="na">renderLambdaToString</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Classes generated for lambda expressions also implement <code class="highlighter-rouge">FunctionN</code>
interfaces, where <code class="highlighter-rouge">N</code> is lambda arity. Again <code class="highlighter-rouge">FunctionN</code> interfaces
are provided by Kotlin runtime:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function0</span> <span class="kd">extends</span> <span class="n">Function</span> <span class="o">{</span>
   <span class="n">Object</span> <span class="n">invoke</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function1</span> <span class="kd">extends</span> <span class="n">Function</span> <span class="o">{</span>
   <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function2</span> <span class="kd">extends</span> <span class="n">Function</span> <span class="o">{</span>
   <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">var2</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Kotlin runtime contains FunctionN defintions</span>
<span class="c1">// up to N=22</span></code></pre></figure>

<p>Now lets take a look at how lambda expressions are invoked,
following code:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">printHelloWorld()</code></pre></figure>

<p>Is translated into:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">Function0 printHelloWorld = (Function0)
    AppKt$main$printHelloWorld$1.INSTANCE;

printHelloWorld.invoke();</code></pre></figure>

<p>Notice that since our lambda expression doesn’t capture
any external variables in its closure, compiler is free to
share single lambda instance (contained in
static field <code class="highlighter-rouge">INSTANCE</code>) across all codebase.</p>

<p>The case is more complicated when closures are involved,
for example consider the following code:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">var value = 0

val incValue = { value++ }
val decValue = { value-- }

incValue()
decValue()

println(value)</code></pre></figure>

<p>As usual Kotlin compiler generated classes for lambdas:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="kd">class</span> <span class="nc">AppKt</span><span class="n">$main$incValue</span><span class="err">$</span><span class="mi">1</span> <span class="kd">extends</span> <span class="n">Lambda</span> <span class="kd">implements</span> <span class="n">Function0</span> <span class="o">{</span>
   <span class="kd">final</span> <span class="n">IntRef</span> <span class="n">$value</span><span class="o">;</span>

   <span class="n">AppKt$main$incValue</span><span class="err">$</span><span class="mi">1</span><span class="o">(</span><span class="n">IntRef</span> <span class="n">var1</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="n">$value</span> <span class="o">=</span> <span class="n">var1</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">invoke</span><span class="o">()</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">$value</span><span class="o">.</span><span class="na">element</span><span class="o">++;</span>
      <span class="k">return</span> <span class="n">var1</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="nc">AppKt</span><span class="n">$main$decValue</span><span class="err">$</span><span class="mi">1</span> <span class="kd">extends</span> <span class="n">Lambda</span> <span class="kd">implements</span> <span class="n">Function0</span> <span class="o">{</span>
   <span class="kd">final</span> <span class="n">IntRef</span> <span class="n">$value</span><span class="o">;</span>

   <span class="n">AppKt$main$decValue</span><span class="err">$</span><span class="mi">1</span><span class="o">(</span><span class="n">IntRef</span> <span class="n">var1</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="n">$value</span> <span class="o">=</span> <span class="n">var1</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">invoke</span><span class="o">()</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">$value</span><span class="o">.</span><span class="na">element</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">$value</span><span class="o">.</span><span class="na">element</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">var1</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Both classes generated for lambda expressions now take a single
parameter of type <code class="highlighter-rouge">IntRef</code>. As you may suspect this class is a
wrapper around <code class="highlighter-rouge">value</code> variable, its definition is again part of Kotlin
runtime:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">IntRef</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="n">element</span><span class="o">;</span>

   <span class="kd">public</span> <span class="n">String</span> <span class="n">toString</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">element</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This time our original code is compiled into:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// var value = 0</span>
<span class="n">IntRef</span> <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntRef</span><span class="o">();</span>
<span class="n">value</span><span class="o">.</span><span class="na">element</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="c1">// val incValue = { value++ }</span>
<span class="n">Function0</span> <span class="n">incValue</span> <span class="o">=</span> 
    <span class="o">(</span><span class="n">Function0</span><span class="o">)(</span><span class="k">new</span> <span class="n">AppKt</span><span class="o">.</span><span class="na">main</span><span class="o">.</span><span class="na">incValue</span><span class="o">.</span><span class="mi">1</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>

<span class="c1">// val decValue = { value-- }</span>
<span class="n">Function0</span> <span class="n">decValue</span> <span class="o">=</span> 
    <span class="o">(</span><span class="n">Function0</span><span class="o">)(</span><span class="k">new</span> <span class="n">AppKt</span><span class="o">.</span><span class="na">main</span><span class="o">.</span><span class="na">decValue</span><span class="o">.</span><span class="mi">1</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>

<span class="c1">// incValue()</span>
<span class="n">incValue</span><span class="o">.</span><span class="na">invoke</span><span class="o">();</span>

<span class="c1">// decValue()</span>
<span class="n">decValue</span><span class="o">.</span><span class="na">invoke</span><span class="o">();</span>

<span class="c1">// println(value)</span>
<span class="kt">int</span> <span class="n">var4</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">element</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">var4</span><span class="o">);</span></code></pre></figure>

<p>As we can see code generated for lambdas with closures is much
more complicated. Value of every variable accessed by lambda expression
must be stored in lambda class field. Primitive types must be wrapped
in classes like <code class="highlighter-rouge">IntRef</code> and unwrapped when they values are needed
(reference types are not wrapped).
Also bear in mind that compiler instantiates plenty of new objects even
for a simple code used in our example, this may negatively affect
performance of your application if you are not careful.</p>

<h4 id="using-receiver-object">Using receiver object</h4>

<p>Sometimes we want lambda expression to behave as it was
a method on some object, we will call this object receiver.
By this I mean that lambda will have
access to <code class="highlighter-rouge">this</code> value and also lambda will be able to
call other methods on receiver without any qualification. 
This behaviour is mostly used when we create
custom <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSLs</a>
(for more details <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">see Kotlin official documentation</a>).</p>

<p>Let’s look at a simple example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">class DummyObject {
    fun foo() { println("foo") }
    fun bar() { println("bar") }
}

fun main(args: Array&lt;String&gt;) {
    val f1: DummyObject.() -&gt; Unit = {
        // call methods without qualification
        foo()
        bar()

        // we can use this
        this.foo()

        // this will have type of the receiver object
        val this_: DummyObject = this
        this_.bar()
    }

    // we can call lambda in a classic way
    f1(DummyObject())

    // or using more idiomatic syntax
    val dummy = DummyObject()
    dummy.f1()
    
}</code></pre></figure>

<p>First we declare <code class="highlighter-rouge">f1</code> to be a lambda that operates on receiver objects
of type <code class="highlighter-rouge">DummyObject</code>, to do that we prepend <code class="highlighter-rouge">TypeOfReceiver.</code> to
a function type.
Then we may call methods on current receiver object without any qualification,
and use <code class="highlighter-rouge">this</code> to obtain current receiver.
Of course when invoking such a lambda we must provide receiver, we can
either pass it as a first parameter or use special <code class="highlighter-rouge">receiver.lambda_name(args)</code> syntax.</p>

<p>A bit of warning here, in our example if we add <code class="highlighter-rouge">f1()</code> method to
our <code class="highlighter-rouge">DummyObject</code> then that method would be called and not our
lambda if we use <code class="highlighter-rouge">receiver.lambda_name(args)</code> syntax:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val dummy = DummyObject()
dummy.f1() // object methods have precedence</code></pre></figure>

<p>Lambdas with receiver were devised to allow creation of
easy to use DSLs, you should not use them in you code until
you are building custom DSL.</p>

<p>One more thing, sometimes we want to convert a call to an object
method to a lambda expression. We don’t need to use lambdas with
receiver to achieve that, plain lambda is enough:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val dummy = DummyObject()

val x: ()-&gt;Unit = { dummy.foo() }
x()

val y = { dummy.bar() }
y()</code></pre></figure>

<p>Or even better we may use method references (borrowed by Kotlin from Java 8):</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val dummy = DummyObject()

val x: ()-&gt;Unit = dummy::foo
x() // calls foo on dummy

val y = dummy::bar
y() // calls bar on dummy</code></pre></figure>

<h4 id="using-lambdas-with-inline-methods">Using lambdas with <code class="highlighter-rouge">inline</code> methods</h4>

<p>Kotlin supports <code class="highlighter-rouge">inline</code> methods, they are similar to macros in
C and LISP and allow us to add new statements to the language.
To understand how <code class="highlighter-rouge">inline</code> methods work we will create a new
statement that executes given block of code and reports how much
time that execution took.</p>

<p>We will start with plain method:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">fun time(blockName: String, codeBlock: ()-&gt;Unit) {
    val startTime = System.currentTimeMillis()

    try {
        codeBlock()
    }
    finally {
        val endTime = System.currentTimeMillis()
        println("execution of $blockName took ${endTime-startTime} ms.")
    }
}</code></pre></figure>

<p>Then we may use this method to measure time of e.g. printing new line
to the standard output:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">time("simple println", {
    println("Hello, world!")
})</code></pre></figure>

<p>This doesn’t look very readable, fortunately in Kotlin when last
function parameter is of function type we may use alternative syntax:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">time("simple println") {
    println("Hello, world!")
}</code></pre></figure>

<p>This looks more like a language statement than a function call, but we still
call <code class="highlighter-rouge">time</code> function. Yet we may do even better than that, if we add <code class="highlighter-rouge">inline</code>
modifier to the <code class="highlighter-rouge">time</code> function compiler will inline our function at callsite
instead of calling it.
For example with:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">inline fun time(blockName: String, codeBlock: ()-&gt;Unit) {</code></pre></figure>

<p>Our sample call is translated by compiler into:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blockName$iv</span> <span class="o">=</span> <span class="s">"simple println"</span><span class="o">;</span>
<span class="kt">long</span> <span class="n">startTime$iv</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

<span class="n">String</span> <span class="n">var4</span><span class="o">,</span> <span class="n">var11</span><span class="o">;</span>
<span class="kt">long</span> <span class="n">endTime$iv1</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">var4</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">var4</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">finally</span> <span class="o">{</span>
    <span class="n">endTime$iv1</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="n">var11</span> <span class="o">=</span> <span class="s">"execution of "</span> <span class="o">+</span> <span class="n">blockName$iv</span> <span class="o">+</span> <span class="s">" took "</span> <span class="o">+</span> 
        <span class="o">(</span><span class="n">endTime$iv1</span> <span class="o">-</span> <span class="n">startTime$iv</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ms."</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">var11</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Kotlin compiler assumes that if we pass lambda expression to
inline function it also will be inlined. For this reason
Kotlin allows us to use <code class="highlighter-rouge">break</code>, <code class="highlighter-rouge">continue</code>[1] and <code class="highlighter-rouge">return</code> statements
in lambdas that are passed to inline functions, for example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">time("simple println") {
    println("Hello, world!")
    return
}</code></pre></figure>

<p>Sometimes inline function takes lambda parameter but passes it
to another function, such parameters may not be inlined and should
be marked with <code class="highlighter-rouge">crossinline</code> modifier. We may also mark 
lambda parameter as “noninlineable” with <code class="highlighter-rouge">noinline</code> modifier.
In both cases we will
not be able to use <code class="highlighter-rouge">return</code> and other control flow instructions in
lambdas passed as values to such parameters.</p>

<ul>
  <li>[1] - <code class="highlighter-rouge">break</code> and <code class="highlighter-rouge">continue</code> are not yet supported, but Kotlin team
 plans to add them to the language in a future release.</li>
</ul>

<h4 id="covariance-and-contravariance">Covariance and contravariance</h4>

<p>Kotlin lambda expressions support 
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">covariance and contravariance</a>
as is illustrated by the following example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val stringProducer: ()-&gt;String = { "foo" }
val anyProducer: ()-&gt;Any = stringProducer

println(stringProducer())
println(anyProducer())

val anyConsumer: (Any)-&gt;Unit = { any -&gt; println("consumed '$any'") }
val stringConsumer: (String)-&gt;Unit = anyConsumer

anyConsumer("bar")
stringConsumer("bar")</code></pre></figure>

<p>We can see that a lambda that returns <code class="highlighter-rouge">String</code> may be used
anywhere where a lambda that returns <code class="highlighter-rouge">Any</code> is expected.
The same goes for parameters, lambda that takes <code class="highlighter-rouge">Any</code> parameter
may be used in place of a function that takes <code class="highlighter-rouge">String</code> parameter.</p>

<h4 id="how-to-decompile-kotlin-code">How to decompile Kotlin code</h4>

<p>To provide decompiled code samples I used <a href="https://github.com/Konloch/bytecode-viewer/releases">Bytecode Viewer</a> with <a href="https://github.com/fesh0r/fernflower">FernFlower</a> engine:
<img src="assets/images/2017-06-10/bytecode_viewer.png" alt="Bytecode Viewer main window" /></p>


	  ]]></description>
	</item>


</channel>
</rss>

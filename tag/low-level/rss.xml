<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link></link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>A closer look at Portable Executable MS-DOS Stub</title>
	  <link>//a-closer-look-at-portable-executable-msdos-stub</link>
	  <author></author>
	  <pubDate>2017-11-18T01:00:00+01:00</pubDate>
	  <guid>//a-closer-look-at-portable-executable-msdos-stub</guid>
	  <description><![CDATA[
	     <p>When we open native or .NET windows executables in a hex-editor
we can notice that almost all of them contains strange
“This program cannot be run in DOS mode” text at the beginning of the file.
The original purpose on this text and surrounding it small
MS-DOS program, called MS-DOS stub is to print message to
the user and then exit if the <code class="highlighter-rouge">.exe</code> file is run from under MS-DOS.
I in this blog post I will explain how it works and since
currently I have only GNU/Linux boxes in my flat I will 
investigate using only Linux.</p>

<p>First we must obtain some <code class="highlighter-rouge">.exe</code> files. We can create .NET executable
using <a href="http://www.mono-project.com/download/#download-lin">Mono Project</a>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ cat HelloWorld.cs 
using System;

public class Program {
    public static void Main() {
        Console.WriteLine("Hello, world!");
    }
}

$ mcs HelloWorld.cs 

$ mono HelloWorld.exe 
Hello, world!</code></pre></figure>

<p>Native executable can be created using 
<a href="https://stackoverflow.com/a/38788588/1779504">MinGW</a>
cross-compiler:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ cat main.c 
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
    printf("Hello, world!\n");
    return 0;
}

$ i686-w64-mingw32-gcc -o main64.exe main.c 

$ wine main64.exe 
Hello, world!</code></pre></figure>

<p>Now when we have a .NET and a 64-bit <code class="highlighter-rouge">.exe</code> files we may look at
them using hex-editor
(I will use <a href="https://github.com/bwrsandman/Bless">Bless</a> here):
<img src="assets/images/2017-11-18/hex_hello_world_exe.png" alt=".NET executable viewed using hex-editor" />
<img src="assets/images/2017-11-18/hex_main64_exe.png" alt="Native executable viewed using hex-editor" />
MS-DOS Stubs in both files looks very similar. This is quite unexpected
because we used two completely different compilers to create them.
Let’s confirm our assumptions first by extracting MS-DOS Stubs and then
by comparing them.</p>

<p>In case of both files MS-DOS Stubs end on 0x80 offset.
At that offset we can see “PE” letters 
that mark start of PE headers
(“PE” means Portable Executable, this is
the name of <code class="highlighter-rouge">.exe</code> file format used by Windows).
These letters are often called a Magical Number or a file signature.
This is similar to MZ letters that are always present at the
beginning of MS-DOS executables.</p>

<p>To extract stubs we must copy first 0x80 bytes (0x80 = 8*16 = 128)
of <code class="highlighter-rouge">.exe</code> files. Then we may compare them:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ dd if=nativeexe/main64.exe \
    of=native-msdos-stub.exe \
    bs=1 count=$((8*16))
$ dd if=dotnetexe/HelloWorld.exe \
    of=dotnet-msdos-stub.exe \
    bs=1 count=$((8*16))

# diff can only compare text files. We must convert
# our binary MS-DOS Stubs to hex using xxd command first:
$ diff &lt;(xxd native-msdos-stub.exe) &lt;(xxd dotnet-msdos-stub.exe) \
    | colordiff
# No output means no changes</code></pre></figure>

<p>So indeed MS-DOS Stubs are identical.</p>

<p>Now just for the sake of doing it I will grab DOSBox and check
if these subs are working:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ sudo apt install dosbox
$ dosbox</code></pre></figure>

<p>After DOSBox starts we must mount our directory with <code class="highlighter-rouge">.exe</code> files
as <code class="highlighter-rouge">C:</code> disk:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Z:\&gt; mount c /home/user/path_to_exe_files
Z:\&gt; C:
C:\&gt; REM And we are done!</code></pre></figure>

<p><img src="assets/images/2017-11-18/dosbox1.png" alt="DOSBox main window" /></p>

<p>We may use <code class="highlighter-rouge">CLS</code> command to clear the screen and attempt to
run our <code class="highlighter-rouge">.exe</code> files. For those that never used MS-DOS, this
system supports only short files names (eight letters for file name plus
three letters for extension, so called <code class="highlighter-rouge">8.3</code> format).
That is why our <code class="highlighter-rouge">HelloWorld.exe</code> is displayed as <code class="highlighter-rouge">HELLOW~2.EXE</code>.
<img src="assets/images/2017-11-18/dosbox2.png" alt="DOSBox main window" /></p>

<p>Everything works as expected. But that is not all of it.
Instead of our <code class="highlighter-rouge">.exe</code> files we may run our extracted MS-DOS Stubs and
they also work without any problems:
<img src="assets/images/2017-11-18/dosbox3.png" alt="DOSBox main window" />
This suggest that MS-DOS Stubs are just tiny MS-DOS EXE programs
(in MZ format) embedded in PE files.</p>

<p>To confirm that assumption we must look under the cover.
Let’s start by dumping values of MS-DOS COM header:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">     e_magic: 4d 5a            // Magic number 'MZ'
      e_cblp: 0x0090           // Bytes on last page of file
        e_cp: 0x0003           // Pages in file
      e_crlc: 0x0000           // Relocations
   e_cparhdr: 0x0004           // Size of header in paragraphs
  e_minalloc: 0x0000           // Minimum extra paragraphs needed
  e_maxalloc: 0xffff           // Maximum extra paragraphs needed
        e_ss: 0x0000           // Initial (relative) SS value
        e_sp: 0x00b8           // Initial SP value
      e_csum: 0x0000           // Checksum
        e_ip: 0x0000           // Initial IP value
        e_cs: 0x0000           // Initial (relative) CS value
    e_lfarlc: 0x0040           // File address of relocation table
      e_ovno: 0x0000           // Overlay number
       e_res: 00 00 00 00 00 00 00 00 
                               // Reserved
     e_oemid: 0x0000           // OEM identifier (for e_oeminfo)
   e_oeminfo: 0x0000           // OEM information; e_oemid specific
      e_res2: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
                               // Reserved
    e_lfanew: 0x00000080       // File address of the new exe header</code></pre></figure>

<p>To extract these values I wrote a small Java program. Source code is
available as a <a href="https://gist.github.com/marcin-chwedczuk/bc050b8feddb50f29cd5bf83e5f843c4">GitHub Gist here</a>.</p>

<p>All values in both MS-DOS file header and in PE headers are stored
using little-endian convention. This means that a four byte integer
e.g. <code class="highlighter-rouge">0x11223344</code> will be represented on disk by bytes <code class="highlighter-rouge">0x44 0x33 0x22 0x11</code>
(least significant byte first).
Of course this applies only to multi-byte types supported by CPU
(<code class="highlighter-rouge">short</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">long</code>, <code class="highlighter-rouge">double</code> and <code class="highlighter-rouge">float</code>).
Also because characters in ASCII strings are represented by single bytes
they are not affected by endianness.
For example string “foo” is represented on disk as <code class="highlighter-rouge">0x66 (f) 0x6f (o) 0x6f (o)</code>
in both little-endian and bit-endian conventions.</p>

<p>I must admit that most of values in MS-DOS header seem magical to me.
The most important thing that I learn by looking at the header was its size:
64 bytes. So after first 64 bytes of MS-DOS Stub
I expect to find some MS-DOS code.</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ dd if=dotnet-msdos-stub.exe \
    of=code.com bs=1 skip=64 count=64

$ file code.com 
code.com: COM executable for DOS</code></pre></figure>

<p>Before we attempt to disassemble code we must learn how MS-DOS
programs are loaded in memory. I didn’t make a deep research but
I have found a few valuable informations:</p>

<ul>
  <li>MS-DOS divides memory in 64k segments. Programs refer to
 a specific address in memory using <code class="highlighter-rouge">segment:offset</code> pair.
 <code class="highlighter-rouge">segment</code> value is set by MS-DOS when program is loaded and
 is stored in special CPU registers like <code class="highlighter-rouge">CS</code> (code segment)
 or <code class="highlighter-rouge">SS</code> (stack segment).</li>
  <li><code class="highlighter-rouge">e_ip</code> value of MS-DOS header points to the first instruction
 of the program (to be more precise <code class="highlighter-rouge">e_ip</code> is <code class="highlighter-rouge">offset</code> inside <code class="highlighter-rouge">e_cs</code>
 code segment).</li>
</ul>

<p>Let’s try to use <a href="http://www.nasm.us/">NASM</a> to disassemble our code:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ ndisasm -b 16 code.com 
00000000  0E                push cs
00000001  1F                pop ds
00000002  BA0E00            mov dx,0xe
00000005  B409              mov ah,0x9
00000007  CD21              int 0x21
00000009  B8014C            mov ax,0x4c01
0000000C  CD21              int 0x21
0000000E  54                push sp
0000000F  686973            push word 0x7369
00000012  207072            and [bx+si+0x72],dh
00000015  6F                outsw
00000016  677261            jc 0x7a
00000019  6D                insw
0000001A  206361            and [bp+di+0x61],ah
...</code></pre></figure>

<p>While reading resulting assembly code we must remember that our tiny program
stores both “This program cannot be run in DOS mode” 
message data and code in the same segment.
Since the message starts at offset <code class="highlighter-rouge">0x0E</code> we may assume that <code class="highlighter-rouge">int 0x21</code>
is the last instruction of the program.
<img src="assets/images/2017-11-18/hex2.png" alt="Offset of the message" /></p>

<p>Now we should try to analyze this assembly code, fortunately for me
I have found this beautifully commend piece of code 
<a href="https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#MS-DOS_header">here</a>:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">push cs <span class="p">;</span><span class="c"># Push CS onto the stack</span>
pop ds  <span class="p">;</span><span class="c"># Set DS to CS</span>

<span class="p">;</span> <span class="c"># (me) This means that Data Segment</span>
<span class="p">;</span> <span class="c"># and Code Segment point to the same</span>
<span class="p">;</span> <span class="c"># 64k byte area of memory.</span>
<span class="p">;</span> <span class="c"># Without this we would not be able</span>
<span class="p">;</span> <span class="c"># to load any data.</span>

mov dx, message <span class="p">;</span><span class="c"># dx will contain pointer to message</span>
mov ah, 09  
int 0x21 <span class="p">;</span><span class="c"># when AH = 9, DOS interrupt to write a string</span>

<span class="p">;</span><span class="c"># terminate the program</span>
mov ax,0x4c01 
int 0x21

message db <span class="s2">"This program cannot be run in DOS mode."</span>, 
    0x0d, 0x0d, 0x0a, <span class="s1">'$'</span></code></pre></figure>

<p>Since we go that far why don’t we change default stub to something more
interesting e.g. printing “Nyan” 3 times?
First we must create a valid assembly program:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">ORG 0h <span class="p">;</span><span class="c"># Offset 0, for NASM</span>

push cs 
pop ds 

<span class="p">;</span> <span class="c"># print message 3 times</span>
mov bx, 3
push bx
repeat:
        mov dx, message 
        mov ah, 09  
        int 0x21

        pop bx
        dec bx
        push bx
cmp bx, 0
jg repeat
pop bx

<span class="p">;</span> <span class="c"># terminate the program</span>
mov ax,0x4c01 
int 0x21

<span class="p">;</span> <span class="nt">----------</span>  D A T A  <span class="nt">-------------</span>

message: DB <span class="s2">"Nyaan."</span>, 0x0d, 0x0d, 0x0a, <span class="s1">'$'</span></code></pre></figure>

<p>The main idea here is that we keep loop counter on the top of the
stack and we load counter into <code class="highlighter-rouge">bx</code> register only to decrement it
or to compere it with zero. I keep the counter value on the stack because
I don’t know if contents of <code class="highlighter-rouge">bx</code> register is changed by <code class="highlighter-rouge">int 0x21</code>
interrupt (yeah I am too lazy too check).</p>

<p>If you have some spare time you may play with other MS-DOS and BIOS
interrupts to print colorful messages or to beep at the user.</p>

<p>Let’s compile our assembly code and patch one of our <code class="highlighter-rouge">.exe</code> files:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight"># -fbin - just translate instruction to bytes
$ nasm -fbin code_alt.nasm -o code_alt.com

# check file size...
$ stat code_alt.com
  File: 'code_alt.com'
  Size: 37  (...)

# patch EXE file
$ dd conv=notrunc if=code_alt.com \
    of=nativeexe/main64.exe \
    bs=1 seek=64 count=37

# Check it works on "Windows"
$ wine ./nativeexe/main64.exe 
Hello, world!
# Yay! Still working!</code></pre></figure>

<p>And when we start it using DOSBox:
<img src="assets/images/2017-11-18/dosbox4.png" alt="DOSBox main window" /></p>

<p><img src="assets/images/memes/mission_accomplished.jpg" alt="The End" /></p>


	  ]]></description>
	</item>


</channel>
</rss>

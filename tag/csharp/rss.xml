<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Don't ask me about Singletons</title>
	  <link>//dont-ask-me-about-singletons</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2017-09-30T02:00:00+02:00</pubDate>
	  <guid>//dont-ask-me-about-singletons</guid>
	  <description><![CDATA[
	     Some time ago I attended a job interview for C# developer position in Warsaw.
One of the tasks that I had to perform was to implement a singleton pattern
in C#. With a bit of help from my interviewer
(I didn't get a cup of coffee that morning) I arrived at a solution:
{% highlight csharp %}
public class Singleton {
    private static Singleton _instance = null;
    private static object _lock = new object();
    
    public static Singleton Instance {
        get {
            if (_instance == null) {
                lock(_lock) {
                    if (_instance == null) {
                        _instance = new Singleton();    
                    }
                }
            }
            return _instance;
        }
    }
    
    private Singleton() {
        Console.WriteLine("Singleton()");   
    }
    public void DoJob() {
        Console.WriteLine("Singleton::DoJob()");
    }
}
{% endhighlight %}
We both admitted that this was a good enough solution 
and we moved to other questions.

Later the same day I had some spare time
at launch break so I started to think about my solution again.
Is it really the best way to create singletons in C#, I asked myself.
As it happens answer to my question was contained on
"C# in Depth" book 
[accompanying website](http://csharpindepth.com/Articles/General/Singleton.aspx#dcl).
There Jon Skeet commented on above solution:

>Without any memory barriers, it's broken in the ECMA CLI specification too. It's possible that under the .NET 2.0 memory model (which is stronger than the ECMA spec) it's safe, but I'd rather not rely on those stronger semantics, especially if there's any doubt as to the safety. Making the instance variable volatile can make it work, as would explicit memory barrier calls, although in the latter case even experts can't agree exactly which barriers are required. I tend to try to avoid situations where experts don't agree what's right and what's wrong!
>
> -- Jon Skeet

In practice this means that it is not strictly required by .NET specification
that this implementation should work. Currently it works on .NET standard,
and I guess Microsoft folks will also make sure that it 
works on .NET Core - but we cannot be 100% sure.

In the same article Jon Skeet proposes a better pattern:
{% highlight csharp %}
public sealed class Singleton
{
    public static Singleton Instance { 
        get { return Nested.instance; } }
        
    private class Nested
    {
        // Explicit static constructor to tell C# compiler
        // not to mark type as beforefieldinit
        static Nested() { }

        internal static readonly SingletonC instance 
            = new Singleton();
    }

    private Singleton()
    {
        Console.WriteLine("Singleton()");
    }
}
{% endhighlight %}
This works because if a type provides a static constructor, C# will
run static initializers lazily (on a first call to any method, including
constructors or access to any field). Without static constructor
runtime may invoke static initializers at any point in time prior to
the first access to any type member. In practice it means that our
singleton without empty static constructor in `Nested` class is no longer lazy.

So it looks like the cure is worse than the disease. Now we require that
any person that implements singletons in our codebase knows about
`beforefieldinit` attribute, which 
unfortunately is clearly visible only in CIL bytecode and is responsible
for the above behaviour:
{% highlight csharp %}
// without static constructor Nested class is declared in CIL
// as follows:
.class nested private auto ansi beforefieldinit Nested
        extends [mscorlib]System.Object
    { ... }

// and with static constructor we get:
.class nested private auto ansi Nested
        extends [mscorlib]System.Object
    { ... }
{% endhighlight %}

Also our version 2.0 doesn't protect us 
from forming cyclic dependency between singletons:
{% highlight csharp %}
public sealed class SingletonC
{
    // singleton stuff...

    private SingletonC()
    {
        Console.WriteLine("SingletonC()");
        Console.WriteLine("D: " + SingletonD.Instance);
    }
}

public sealed class SingletonD
{
    // singleton stuff...

    private SingletonD()
    {
        Console.WriteLine("SingletonD()");
        Console.WriteLine("C: " + SingletonC.Instance);
    }
}

public static void Main()
{
    Console.WriteLine("Main()");
    var tmp = SingletonC.Instance;
}
// Program output:
// Main()
// SingletonC()
// SingletonD()
// C: (null)
// D: SingletonD
{% endhighlight %}
As we can see `SingletonC.Intance` inside `SingletonD` constructor
returned `null`. If we tried to create cyclic dependency with our
first solution we would get a `StackOverflowException`. So at least
we would know that something is wrong.
Anyway looks like creating a singleton requires some skills...

And since we are talking about singletons already, its also worth to
know that .NET allows us to create an instance of type without invoking
constructor (useful when implementing e.g. JSON serialization library).
Objects created this way will be of course incomplete but still:
{% highlight csharp %}
FormatterServices.GetUninitializedObject(typeof(SingletonC));
{% endhighlight %}
And of course we don't even talk about reflection API that we may use to
destroy even most foolproof singletons.

So I guess now its a summary time! If you want to use singletons in
your code that badly, please read carefully Jon Skeet articles
from reference section. For the rest of us: let's forget about 
handcrafted singletons
and start using Dependency Injection!

PS. Also be careful when asking questions about Singletons 
at job interviews unless
you want to hear discussion about `beforefieldinit` ;)

References:

* [http://csharpindepth.com/Articles/General/Singleton.aspx](http://csharpindepth.com/Articles/General/Singleton.aspx)
* [http://csharpindepth.com/Articles/General/Beforefieldinit.aspx](http://csharpindepth.com/Articles/General/Beforefieldinit.aspx)



	  ]]></description>
	</item>

	<item>
	  <title>How null's are handled in switch statement in C#, Java and JavaScript</title>
	  <link>//how-nulls-are-handled-in-switch-statement</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-07-09T02:00:00+02:00</pubDate>
	  <guid>//how-nulls-are-handled-in-switch-statement</guid>
	  <description><![CDATA[
	     Let's start with C#. In C# `null`s may show up in `switch` statement in two cases:

1. We `switch` on `string` type
2. We `switch` on nullable `char`, nullable integral type (`byte`, `short` etc.) 
 or nullable enum

Both cases are handled by compiler in the same way,
we just declare `case null` label and it will work out of the box.

This is illustrated by simple program:
{% highlight csharp %}
using System;

public class Program
{
   public void Main() {
        int? n = GetDefault<int?>();
 
        // This will write null       
        switch(n) {
            case null: Console.WriteLine("null");    break;
            case 1:    Console.WriteLine("value 1"); break;
            default:   Console.WriteLine("default"); break;
        }


        string s = GetDefault<string>();
 
        // This will write null       
        switch(s) {
            case null:   Console.WriteLine("null");    break;
            case "foo":  Console.WriteLine("foo");     break;
            default:     Console.WriteLine("default"); break;
        }
    }
    
    // GetDefault returns null for nullable and reference type T
    private T GetDefault<T>() {
        return default(T);   
    }
}
{% endhighlight %}

##### Java switch and null's

In Java `null`'s may show up in `switch` statement when we `switch` 
on primitive type wrappers like `Integer` or on `String` or on enum type.
In that case Java will throw `NullPointerException` as is demonstrated by program:
{% highlight java %}
public class Program 
{
  public static void main(String[] args)
  {
    String s = getNullString();
    try {
      switch(s) {
          // case null - doesn't compile:
          // error: constant string expression required
          // case null:  System.out.println("null"); break;

          case "foo": System.out.println("foo"); break;
          default:    System.out.println("default"); break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(s) {` line
        System.out.println("null pointer exception");
    }
    
    FooEnum e = getNullFooEnum();
    try {
      switch(e) {
       // case null doesn't compile
       // error: an enum switch case label must be the unqualified name of an enumeration constant
       // case null: System.out.println("null"); break;
        
       case OPTION_1: System.out.println("option 1"); break;
       default:       System.out.println("default");  break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(e) {` line
        System.out.println("null pointer exception");
    }
  }
  private static String getNullString() {
        return null; 
  }
  private static FooEnum getNullFooEnum() {
    return null;
  }
}

enum FooEnum {
  OPTION_1,
  OPTION_2
}
{% endhighlight %}
Program output:
{% highlight no-highlight %}
null pointer exception
null pointer exception
{% endhighlight %}
As we have seen it's not even possible to declare `case null` label.

In Java until you are 100% sure that value will not contain `null` you must
explicitly check for `null` before switch as in:
{% highlight java %}
FooEnum e = getNullFooEnum();

if (e == null) { 
  System.out.println("null"); 
}
else {
  switch(e) {
    case OPTION_1: System.out.println("option 1"); break;
    default:       System.out.println("default");  break;
  }
}
{% endhighlight %}
Or use trick with default value:
{% highlight java %}
Integer n = getNullableInteger();

// -1 is default here, but you may use Integer.MIN/MAX_VALUE or any
// other value
switch((e != null) ? e : -1) {
  case 1:  System.out.println("1"); break;
  case -1: System.out.println("null"); break;
  default: System.out.println("default"); break;
}
{% endhighlight %}

WARNING: This Java behaviour may cause problems when we translate code from C# to Java.

#### JavaScript switch and null

JavaScript `switch` statement is very flexible, each `case` label may contain
an expression that will be evaluated at runtime. To compare `case` label values to
`switch` value JavaScript uses `===` operator.

In JavaScript there is no problem with using `null` and even `undefined` as `case`
labels. Only tricky thing is with `NaN`s because `NaN === NaN` yields `false`
in JavaScript. This is enforced by IEEE 754 standard that describes floating point
numbers representation and behaviour. 
In other words we can use `NaN` as a `case` label but
program will never enter block of code associated with that label. As a side note
it's worth to mention that in JavaScript `NaN` is 
the only value for which expression `x === x` yields
`false`.

Following program demonstrates flexibility of JavaScript `switch` statement:
{% highlight js %}
var values = [undefined, null, '', 0, NaN, 1, 'foo', {}];

values.forEach(function(value) {
    switch (value) {
        case undefined:
            console.log('undefined');
            break;

         case null:
            console.log('null');
            break;
        
        case '':
            console.log('empty string');
            break;
        
        case 0:
            console.log('zero');
            break;
        
        case NaN:
            // dead code here
            console.log('nan');
            break;
        
        case 1:
            console.log(1);
            break;
        
        // label with runtime expression here:
        case 'f'+'oo':
            console.log('foo');
            break;
        
        default:
            console.log('default');
            break;
    }
});
{% endhighlight %}
This program will write:
{% highlight no-highlight %}
"undefined"
"null"
"empty string"
"zero"
"default"
1
"foo"
"default"
{% endhighlight %}
Notice that `"default"` was printed for `NaN` value.

That's all for today, I hope you learned something new from this article.   
May the Force be with you.


	  ]]></description>
	</item>

	<item>
	  <title>Object and collection initializers in C#</title>
	  <link>//object-and-collection-initializers-in-csharp</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-12T02:00:00+02:00</pubDate>
	  <guid>//object-and-collection-initializers-in-csharp</guid>
	  <description><![CDATA[
	     In this post I want to present a nice C# syntax sugar: object and collection
initializers.

#### Object initializers
We will start with object initializers. Let's assume we have classes:
{% highlight csharp %}
public class Position {
    public int Top { get; set; }
    public int Left { get; set; }
}

public class Button {
    public Position Position { get; private set; } 
    public string Text { get; set; }
    public int FontSize { get; set; }

    public Button() {
        Position = new Position();
        FontSize = 10;
    }
}
{% endhighlight %}
Without object initializer we could set `Button` object
properties using the following code:
{% highlight csharp %}
var okButton = new Button();

okButton.Position.Top = 100;
okButton.Position.Left = 200;
okButton.Text = "OK";
okButton.FontSize = 13;
{% endhighlight %}
With object initializers we can shorten this code a bit:
{% highlight csharp %}
var okButton = new Button {
    Position = {
        Top = 100,
        Left = 200
    },
    Text = "OK",
    FontSize = 13
};
{% endhighlight %}
Instructions generated by compiler in this two cases are exactly the same, but code 
using object initializer is more clear and more readable.

Now let's dive into some syntax details:  
I. We can pass any parameters to object
constructor using syntax:
{% highlight csharp %}
var foo = new Foo(param1, param2) {
    Property1 = "some value",
    Property2 = "some other value",
    // ...
}
{% endhighlight %}

II. When we call parameterless constructor we can omit parentheses 
(like I did in the `Button` example):
{% highlight csharp %}
var foo = new Foo() {
    // ...
};

// this is exactly the same as new Foo()
var foo2 = new Foo {
    // ...
}
{% endhighlight %}
III. Object initializers can be nested:
{% highlight csharp %}
var invoice = new Invoice {
    ShippingAddress = new Address {
        Street = "Long Street",
        Number = "3A"
    },

    InvoiceAddress = new Address {
        Street = "Short Street",
        Number = "4B"
    }
};
{% endhighlight %}
IV. We can set nested properties without creating new objects  
Do you remember our first example with `Button`? We use
{% highlight csharp %}
var okButton = new Button {
    Position = {
        Top = 100,
        Left = 200
    },
    // ...
};
{% endhighlight %}
to set properties of `Button` `Position` object. Notice that `Position`
property has private setter
{% highlight csharp %}
public Position Position { get; private set; }
{% endhighlight %}
so we cannot use `new` to create new `Position` object
{% highlight csharp %}
var okButton = new Button {
    //         v doesn't compile
    Position = new Position {
        Top = 100,
        Left = 200
    },
    // ...
};
{% endhighlight %}
Fortunately object initializer syntax is flexible enough to allow us
set properties without creating new objects.  

V. Object initializer syntax works only with `new`  
In other words following code doesn't compile:
{% highlight csharp %}
// doesn't compile
var foo = SomeMethodReturningFoo() {
    Property1 = 1
};
{% endhighlight %}

#### Collection initializers

Now it's time to present collection initializers. We will start with
`List<T>` initializers, then we will describe `Dictionary<TKey, TValue>`
initializers.

As we all know C# allows to create and initialize arrays in single expression:
{% highlight csharp %}
var funnyNames = new string[] { "foo", "bar", "baz", "yay" };
{% endhighlight %}
Wouldn't it be nice if this syntax worked with `List<T>`'s? Actually thanks
to collection initializers it works and not only with `List`'s but also with
custom classes!

Let's see an example:
{% highlight csharp %}
List<string> funnyNames = new List<string> { "foo", "bar", "baz" };
{% endhighlight %}
this code is translated by compiler to
{% highlight csharp %}
List<string> tmp = new List<string>();
tmp.Add("foo");
tmp.Add("bar");
tmp.Add("baz");

List<string> funnyNames = tmp;
{% endhighlight %}

Inside initializers we are not limited to constants, we can use complex expressions
like
{% highlight csharp %}
List<object> things = new List<object>() {
    (1+3*7),
    true.ToString(),
    new object()
};
{% endhighlight %}

As we already seen compiler translates collection initializers to a couple
of `Add` calls. We can make collection initializers work with custom classes by
providing `Add` method and implementing `IEnumerable` or `IEnumerable<T>`. This
second requirement is very important - since we are using *collection* initializers,
compiler expects that we will initialize some kind of collection and collections
ought to implement `IEnumerable` interface.

Below we present minimal generic and non-generic class that works with
collections initializers:
{% highlight csharp %}
public class CustomCollection : IEnumerable {
    public void Add(object item) {
        Console.WriteLine("Add({0})", item);
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}

public class CustomCollection<T> : IEnumerable<T> {
    public void Add(T item) {
        Console.WriteLine("Add<T>({0})", item);
    }

    IEnumerator<T> IEnumerable<T>.GetEnumerator() {
        yield break;
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}
{% endhighlight %}
NOTE: We used `yield break` to quickly provide dummy `IEnumerable` implementation.  
Now we can test our custom collections:
{% highlight csharp %}
public class Program
{
    public static void Main(string[] args)
    {
        var nonGeneric = new CustomCollection { 1, 2, 3 };
        var generic = new CustomCollection<int> { 1, 2, 3 };
    }
}
{% endhighlight %}
When ran this program will write:
{% highlight no-highlight %}
Add(1)
Add(2)
Add(3)
Add<T>(1)
Add<T>(2)
Add<T>(3)
{% endhighlight %}

Now since collections initializers are translated to a `Add` method calls, what will happen
when we write `Add` method that take more than one parameter?
{% highlight csharp %}
public class CustomCollection2 : IEnumerable {
    // notice *two* parameters
    public void Add(object item, object item2) {
        Console.WriteLine("Add({0}, {1})", item, item2);
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}
{% endhighlight %}
It turns out that we still can use collection initializers, but the syntax is a bit different
{% highlight csharp %}
var coll2 = new CustomCollection2 { 
    { 1, 1 }, 
    { 2, 2 },
    { 3, 3 } 
};
{% endhighlight %}
This is translated by compiler to
{% highlight csharp %}
CustomCollection2 tmp = new CustomCollection2();
tmp.Add(1, 1);
tmp.Add(2, 2);
tmp.Add(3, 3);
CustomCollection2 coll2 = tmp;
{% endhighlight %}

With this knowledge it should be now easy to understand how `Dictionary<TKey, TValue>`
initializers work. First `Dictionary<TKey, TValue>` defines `Add(TKey, TValue)` method,
second it implements `IEnumerable<KeyValuePair<TKey,â€‚TValue>>` interface - so it fulfills all 
requirements needed by collection initializers to work.

We can initialize `Dictionary` with the following code
{% highlight csharp %}
var dict = new Dictionary<string, string> {
    { "1", "one" },
    { "2", "two" },
    { "3", "three" }
};
{% endhighlight %}
Which as we already know is translated into
{% highlight csharp %}
Dictionary<string, string> tmp = new Dictionary<string, string>();
tmp.Add("1", "one");
tmp.Add("2", "two");
tmp.Add("3", "three");

var dict = tmp;
{% endhighlight %}

C# 6 introduced more flexible syntax for `Dictionary` initializers
{% highlight csharp %}
var dict = new Dictionary<string, string> {
    ["1"] = "one",
    ["2"] = "two",
    ["3"] = "three"
};
{% endhighlight %}
This is not translated to `Add` calls, but uses indexer instead
{% highlight csharp %}
Dictionary<string, string> tmp = new Dictionary<string, string>();
tmp["1"] = "one";
tmp["2"] = "two";
tmp["3"] = "three";
var dict = tmp;
{% endhighlight %}

As other collection initializers it can work with custom types, only requirement is that
type must have indexer
{% highlight csharp %}
public class CustomCollection {
    public object this[string key] {
        get { return null; }
        set { /* do something with value */ }
    }
}

// usage:
var coll = new CustomCollection {
    ["foo"] = 1,
    ["bar"] = 2
};
{% endhighlight %}

Another feature is that we can set properties of already existing objects in collection,
for example let's assume that constructor of our collection already added some objects into
collection:
{% highlight csharp %}
public class Example : Dictionary<string, Position> {
    public Example() {
        Add("topLeft", new Position());
        Add("bottomRight", new Position());
    }
}
{% endhighlight %}
Then we can write
{% highlight csharp %}
var example  = new Example {
    ["topLeft"] = { Top = 10, Left = 20 },
    ["bottomRight"] = { Top = 100, Left = 220 }
};
{% endhighlight %}
This will be translated by compiler into
{% highlight csharp %}
Example tmp = new Example();
tmp["topLeft"].Top = 10;
tmp["topLeft"].Left = 20;
tmp["bottomRight"].Top = 100;
tmp["bottomRight"].Left = 220;
Example example = tmp;
{%endhighlight %}

The last thing worth know about this new initializer syntax is ability to mix it with
property initializers e.g.
{% highlight csharp %}
 var example  = new Example {
    ["topLeft"] = { Top = 10, Left = 20 },
    ["bottomRight"] = { Top = 100, Left = 220 },

    // normal property
    Tag = new object()
};
{% endhighlight %}

That was plenty of knowledge, but the best way to learn about initializer is to use
them in code. After a while they become second nature for C# programmers and central part
of many language idioms.



	  ]]></description>
	</item>


</channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Don't ask me about Singletons</title>
	  <link>//dont-ask-me-about-singletons</link>
	  <author></author>
	  <pubDate>2017-09-30T02:00:00+02:00</pubDate>
	  <guid>//dont-ask-me-about-singletons</guid>
	  <description><![CDATA[
	     Some time ago I attended a job interview for C# developer position in Warsaw.
One of the tasks that I had to perform was to implement a singleton pattern
in C#. With a bit of help from my interviewer
(I didn't get a cup of coffee that morning) I arrived at a solution:
{% highlight csharp %}
public class Singleton {
    private static Singleton _instance = null;
    private static object _lock = new object();
    
    public static Singleton Instance {
        get {
            if (_instance == null) {
                lock(_lock) {
                    if (_instance == null) {
                        _instance = new Singleton();    
                    }
                }
            }
            return _instance;
        }
    }
    
    private Singleton() {
        Console.WriteLine("Singleton()");   
    }
    public void DoJob() {
        Console.WriteLine("Singleton::DoJob()");
    }
}
{% endhighlight %}
We both admitted that this was a good enough solution 
and we moved to other questions.

Later the same day I had some spare time
at launch break so I started to think about my solution again.
Is it really the best way to create singletons in C#, I asked myself.
As it happens answer to my question was contained on
"C# in Depth" book 
[accompanying website](http://csharpindepth.com/Articles/General/Singleton.aspx#dcl).
There Jon Skeet commented on above solution:

>Without any memory barriers, it's broken in the ECMA CLI specification too. It's possible that under the .NET 2.0 memory model (which is stronger than the ECMA spec) it's safe, but I'd rather not rely on those stronger semantics, especially if there's any doubt as to the safety. Making the instance variable volatile can make it work, as would explicit memory barrier calls, although in the latter case even experts can't agree exactly which barriers are required. I tend to try to avoid situations where experts don't agree what's right and what's wrong!
>
> -- Jon Skeet

In practice this means that it is not strictly required by .NET specification
that this implementation should work. Currently it works on .NET standard,
and I guess Microsoft folks will also make sure that it 
works on .NET Core - but we cannot be 100% sure.

In the same article Jon Skeet proposes a better pattern:
{% highlight csharp %}
public sealed class Singleton
{
    public static Singleton Instance { 
        get { return Nested.instance; } }
        
    private class Nested
    {
        // Explicit static constructor to tell C# compiler
        // not to mark type as beforefieldinit
        static Nested() { }

        internal static readonly SingletonC instance 
            = new Singleton();
    }

    private Singleton()
    {
        Console.WriteLine("Singleton()");
    }
}
{% endhighlight %}
This works because if a type provides a static constructor, C# will
run static initializers lazily (on a first call to any method, including
constructors or access to any field). Without static constructor
runtime may invoke static initializers at any point in time prior to
the first access to any type member. In practice it means that our
singleton without empty static constructor in `Nested` class is no longer lazy.

So it looks like the cure is worse than the disease. Now we require that
any person that implements singletons in our codebase knows about
`beforefieldinit` attribute, which 
unfortunately is clearly visible only in CIL bytecode and is responsible
for the above behaviour:
{% highlight csharp %}
// without static constructor Nested class is declared in CIL
// as follows:
.class nested private auto ansi beforefieldinit Nested
        extends [mscorlib]System.Object
    { ... }

// and with static constructor we get:
.class nested private auto ansi Nested
        extends [mscorlib]System.Object
    { ... }
{% endhighlight %}

Also our version 2.0 doesn't protect us 
from forming cyclic dependency between singletons:
{% highlight csharp %}
public sealed class SingletonC
{
    // singleton stuff...

    private SingletonC()
    {
        Console.WriteLine("SingletonC()");
        Console.WriteLine("D: " + SingletonD.Instance);
    }
}

public sealed class SingletonD
{
    // singleton stuff...

    private SingletonD()
    {
        Console.WriteLine("SingletonD()");
        Console.WriteLine("C: " + SingletonC.Instance);
    }
}

public static void Main()
{
    Console.WriteLine("Main()");
    var tmp = SingletonC.Instance;
}
// Program output:
// Main()
// SingletonC()
// SingletonD()
// C: (null)
// D: SingletonD
{% endhighlight %}
As we can see `SingletonC.Intance` inside `SingletonD` constructor
returned `null`. If we tried to create cyclic dependency with our
first solution we would get a `StackOverflowException`. So at least
we would know that something is wrong.
Anyway looks like creating a singleton requires some skills...

And since we are talking about singletons already, its also worth to
know that .NET allows us to create an instance of type without invoking
constructor (useful when implementing e.g. JSON serialization library).
Objects created this way will be of course incomplete but still:
{% highlight csharp %}
FormatterServices.GetUninitializedObject(typeof(SingletonC));
{% endhighlight %}
And of course we don't even talk about reflection API that we may use to
destroy even most foolproof singletons.

So I guess now its a summary time! If you want to use singletons in
your code that badly, please read carefully Jon Skeet articles
from reference section. For the rest of us: let's forget about 
handcrafted singletons
and start using Dependency Injection!

PS. Also be careful when asking questions about Singletons 
at job interviews unless
you want to hear discussion about `beforefieldinit` ;)

References:

* [http://csharpindepth.com/Articles/General/Singleton.aspx](http://csharpindepth.com/Articles/General/Singleton.aspx)
* [http://csharpindepth.com/Articles/General/Beforefieldinit.aspx](http://csharpindepth.com/Articles/General/Beforefieldinit.aspx)



	  ]]></description>
	</item>

	<item>
	  <title>Castle Windsor most popular features</title>
	  <link>//castle-windsor-most-popular-features</link>
	  <author></author>
	  <pubDate>2016-09-11T02:00:00+02:00</pubDate>
	  <guid>//castle-windsor-most-popular-features</guid>
	  <description><![CDATA[
	     In this post I will present the most popular 
[Castle Windsor](http://www.castleproject.org/projects/windsor/) features
encountered in typical enterprise applications. 

> Source code: [https://github.com/marcin-chwedczuk/castle-windsor-most-popular-features](https://github.com/marcin-chwedczuk/castle-windsor-most-popular-features)

##### Typed factory

When I follow good software development practices like
[SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
I find myself writing plenty of [factory](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)) classes.
These factory classes often fall in one of the two categories:

* I need to create instance of generic service for specific type e.g. I want to get 
 service that implements `ICommandHandler<TCommand>` for `TCommand` type
* I must pass parameters and/or configuration to the service before I
 can use it e.g. `HeuristicSearch` service has `quality` constructor parameter
 to decide what solutions are good enough for the user

In cases like these we can use typed factory feature to generate
factory implementations:
{% highlight csharp %}
// to enable typed factory we must add TypedFactoryFacility
// to the container
container.AddFacility<TypedFactoryFacility>();

// case  I: get generic service instance for specific type
public interface ICommandHandler<TCommand> {
    void Handle(TCommand command);
}
public interface ICommandHandlerFactory {
    ICommandHandler<T> Create<T>();
    void Release<T>(ICommandHandler<T> instance);
}
public class AddUserCommandHandler : ICommandHandler<AddUserCommand> {
    public AddUserCommandHandler(/* dependencies */) { ... }
    public void Handle(AddUserCommand command) { ... }
}

container.Register(
    Component.For<ICommandHandler<AddUserCommand>>()
        .ImplementedBy<AddUserCommandHandler>()
        .LifeStyle.Transient,

    // tell Windsor that it should generate factory for me
    Component.For<ICommandHandlerFactory>()
        .AsFactory()
    );

// usage
ICommandHandlerFactory factory =
        container.Resolve<ICommandHandlerFactory>();

ICommandHandler<AddUserCommand> handler =
    factory.Create<AddUserCommand>();

handler.Handle(new AddUserCommand());

factory.Release(handler);

// case II: pass configuration to the service
public interface IGreeter {
    void Greet();
}
public interface IGreeterFactory {
    IGreeter Create(string greeting);
    void Release(IGreeter instance);
}
public class ConsoleGreeter : IGreeter {
    ...
    public ConsoleGreeter(string greeting
        /* you may add other dependencies here,
         * e.g. ITextWrapper wrapper */) { ... }
}

container.Register(
    Component.For<IGreeter>()
        .ImplementedBy<ConsoleGreeter>()
        .LifestyleTransient(),

    // tell Windsor that it should generate factory for me
    Component.For<IGreeterFactory>()
        .AsFactory()
    );

// usage
IGreeterFactory greeterFactory = 
    container.Resolve<IGreeterFactory>();

IGreeter helloWorldGreeter = greeterFactory.Create("hello, world!");
IGreeter goodbyeGreeter = greeterFactory.Create("goodbye cruel world!");

helloWorldGreeter.Greet();
goodbyeGreeter.Greet();

greeterFactory.Release(helloWorldGreeter);
greeterFactory.Release(goodbyeGreeter);
{% endhighlight %}

Things to remember when using typed factory:

* `Release` method in factory interface is optional.  
 It is a good practice to
 always include `Release` method in factory interface and to release all instances
 created using factory when they are no longer needed
* In case of transient or per-web-request components that are disposable
 not releasing component will result in a memory leak
* Remember that some factories should be implemented manually especially these 
 that contain domain knowledge e.g. factory that selects discount
 [strategy](https://en.wikipedia.org/wiki/Strategy_pattern) based on user profile

##### Collection resolver

Sometime we want to get all components that provide given service.
For example we may try to implement message filtering component and
we want to get all components that implement `IFilter` interface.
We may achieve this easily by using Castle Windsor `CollectionResolver`:
{% highlight csharp %}
// register CollectionResolver in the container:
container.Kernel.Resolver.AddSubResolver(
        new CollectionResolver(container.Kernel));

// demo:
public interface IFilter {
    bool IsAllowed(string message);
}

public class MessageFilterService {
    private ICollection<IFilter> _filters;

    public MessageFilterService(ICollection<IFilter> filters) {
        this._filters = filters;
    }
    ...
}

container.Register(
    Component.For<MessageFilterService>().LifeStyle.Transient,

    Component.For<IFilter>().ImplementedBy<RejectBazWordFilter>(),
    Component.For<IFilter>().ImplementedBy<FooOrBazFilter>()
);

MessageFilterService service = container.Resolve<MessageFilterService>();
service.IsAllowed("foo");
{% endhighlight %}

Since registering `CollectionResolver` requires a bit of interaction
with a container it is advisable to wrap that logic into custom facility:
{% highlight csharp %}
public class ResolveCollectionsFacility : AbstractFacility {
    protected override void Init() {
        Kernel.Resolver.AddSubResolver(new CollectionResolver(Kernel));
    }
}

// then use:
// container.AddFacility<ResolveCollectionsFacility>();
{% endhighlight %}

##### Component registration using conventions

[Convention over configuration](https://en.wikipedia.org/wiki/Convention_over_configuration)
is popular subject these days so why not to apply it to the component registration.
Instead of writing boring:
{% highlight csharp %}
Component.For<IFooRepository>()
        .ImplementedBy<FooRepository>()
        .Lifestyle.PerWebRequest,
...
Component.For<IBarRepository>()
        .ImplementedBy<BarRepository>()
        .Lifestyle.PerWebRequest
{% endhighlight %}
We may write just once:
{% highlight csharp %}
Classes.FromThisAssembly()
    .BasedOn(typeof(IRepository<>))
    .WithService.AllInterfaces()
    .Lifestyle.PerWebRequest
{% endhighlight %}

Castle Windsor is very flexible when it comes to registering components
by convention, we may scan selected assemblies and/or namespaces, we
may even select components to register by testing component `Type`.

> PITFALL: Avoid creating conventions based on type name (e.g. register all classes that
> have names ending with `Repository`) as
> much as possible. It is always better to create empty marker interface
> e.g. `IApplicationService` and use it to register all necessary components.

##### Installers

Castle Windsor installers allow us to group component registrations into
reusable pieces of code. The real power of installers comes from the fact that
we may pass them arguments or in other words we may configure them.
For example installer may take a single argument that tells what lifestyle should
be applied to all registrations contained in the installer. Such installer can
be used in both ASP.NET MVC app when most of the components will be
registered as `PerWebRequest` and in Windows service app where components will 
be registered as either `Transient` or `Singleton`.

Here is example of very simple installer:
{% highlight csharp %}
public class DummyModuleInstaller : IWindsorInstaller {
    public void Install(IWindsorContainer container, IConfigurationStore store) {
        container.AddFacility<TypedFactoryFacility>();

        // add other installers, facilities etc.

        container.Register(
            Component.For<DummyService>().LifeStyle.Transient
            // other components
            );
    }
}

container.Install(new [] {
    new DummyModuleInstaller()
});
{% endhighlight %}

##### Fallback and default components

When we start grouping registrations into installers often we will find ourselves
in situation that we want to register given service only when user of the installer
didn't provide she's own implementation. We may achieve this by passing parameters
to the installer but a fallback components are a better choice here.
Components registered as fallbacks will be used by the container only when there is no
other component that provides given service:
{% highlight csharp %}
// fallback is used when no other component
// for service is registered
container.Register(
    Component.For<IFooService>()
        .ImplementedBy<FallbackFooService>()
        .LifeStyle.Transient
        .IsFallback()
        );

Assert.That(container.Resolve<IFooService>(),
    Is.InstanceOf<FallbackFooService>());

// we may register our own component for FooService
container.Register(
    Component.For<IFooService>()
        .ImplementedBy<FooService>()
        );

Assert.That(container.Resolve<IFooService>(),
    Is.InstanceOf<FooService>());
{% endhighlight %}

Since word isn't perfect it happens from time to time that we want to
overwrite component registration for some particular service. This usually happens
because author of the installer doesn't use fallback components. But don't panic
Castle Windsor allow us to overwrite service registrations using default components:
{% highlight csharp %}
container.Register(
    Component.For<IFooService>()
        .ImplementedBy<FooService>());

Assert.That(container.Resolve<IFooService>(),
    Is.InstanceOf<FooService>());

// Without IsDefault() we
// would get an exception telling us that
// there is already component registered for IFooService
// interface.
container.Register(
   Component.For<IFooService>()
       .ImplementedBy<DefaultFooService>()
       .IsDefault()
       );

Assert.That(container.Resolve<IFooService>(),
    Is.InstanceOf<DefaultFooService>());
{% endhighlight %}

##### Interceptors

Interceptors are most powerful Castle Windsor feature that
brings power of [aspect oriented programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
to .NET.
Interceptors can be used to implement transaction management, logging, security checks,
we may use them to gather performance related statistics and for many other purposes.

Here is a simple interceptor that log the invocations of all component methods:
{% highlight csharp %}
public class EventTracingInterceptor : IInterceptor {
    public void Intercept(IInvocation invocation) {
        EventTracer.AddEvent("BEFORE " + invocation.Method.Name);

        try {
            // call original method, we may inspect method arguments,
            // generic parameters, return value and many others
            invocation.Proceed();
        }
        finally {
            EventTracer.AddEvent("AFTER " + invocation.Method.Name);
        }
    }
}

[Interceptor(typeof(EventTracingInterceptor))]
public class Service : IService {
    public void Foo() { ... }
    public void Bar() { ... }
}

container.Register(
    // interceptors work only when you expose your
    // components via interfaces.
    // here I registered interceptors by using
    // attributes on Service class but you may also
    // use fluent api.
    Component.For<IService>().ImplementedBy<Service>(),
    Component.For<EventTracingInterceptor>()
    );

IService service = container.Resolve<IService>();
service.Foo();
{% endhighlight %}

When you start writing your own interceptors it is generally advisable to
create custom attribute e.g. `TransactionalAttribute` to mark classes that
should have interceptors attached. 
Then you should write your own facility that will scan all components
registered in container
and will attach interceptor for these marked with your custom attribute.
[Here is a good example of this approach](http://blog.willbeattie.net/2010/09/implementing-custom-castle-windsor.html)
used to implement caching.

That's all for today! Thanks for reading.

	  ]]></description>
	</item>

	<item>
	  <title>How null's are handled in switch statement in C#, Java and JavaScript</title>
	  <link>//how-nulls-are-handled-in-switch-statement</link>
	  <author></author>
	  <pubDate>2016-07-09T02:00:00+02:00</pubDate>
	  <guid>//how-nulls-are-handled-in-switch-statement</guid>
	  <description><![CDATA[
	     Let's start with C#. In C# `null`s may show up in `switch` statement in two cases:

1. We `switch` on `string` type
2. We `switch` on nullable `char`, nullable integral type (`byte`, `short` etc.) 
 or nullable enum

Both cases are handled by compiler in the same way,
we just declare `case null` label and it will work out of the box.

This is illustrated by simple program:
{% highlight csharp %}
using System;

public class Program
{
   public void Main() {
        int? n = GetDefault<int?>();
 
        // This will write null       
        switch(n) {
            case null: Console.WriteLine("null");    break;
            case 1:    Console.WriteLine("value 1"); break;
            default:   Console.WriteLine("default"); break;
        }


        string s = GetDefault<string>();
 
        // This will write null       
        switch(s) {
            case null:   Console.WriteLine("null");    break;
            case "foo":  Console.WriteLine("foo");     break;
            default:     Console.WriteLine("default"); break;
        }
    }
    
    // GetDefault returns null for nullable and reference type T
    private T GetDefault<T>() {
        return default(T);   
    }
}
{% endhighlight %}

##### Java switch and null's

In Java `null`'s may show up in `switch` statement when we `switch` 
on primitive type wrappers like `Integer` or on `String` or on enum type.
In that case Java will throw `NullPointerException` as is demonstrated by program:
{% highlight java %}
public class Program 
{
  public static void main(String[] args)
  {
    String s = getNullString();
    try {
      switch(s) {
          // case null - doesn't compile:
          // error: constant string expression required
          // case null:  System.out.println("null"); break;

          case "foo": System.out.println("foo"); break;
          default:    System.out.println("default"); break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(s) {` line
        System.out.println("null pointer exception");
    }
    
    FooEnum e = getNullFooEnum();
    try {
      switch(e) {
       // case null doesn't compile
       // error: an enum switch case label must be the unqualified name of an enumeration constant
       // case null: System.out.println("null"); break;
        
       case OPTION_1: System.out.println("option 1"); break;
       default:       System.out.println("default");  break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(e) {` line
        System.out.println("null pointer exception");
    }
  }
  private static String getNullString() {
        return null; 
  }
  private static FooEnum getNullFooEnum() {
    return null;
  }
}

enum FooEnum {
  OPTION_1,
  OPTION_2
}
{% endhighlight %}
Program output:
{% highlight no-highlight %}
null pointer exception
null pointer exception
{% endhighlight %}
As we have seen it's not even possible to declare `case null` label.

In Java until you are 100% sure that value will not contain `null` you must
explicitly check for `null` before switch as in:
{% highlight java %}
FooEnum e = getNullFooEnum();

if (e == null) { 
  System.out.println("null"); 
}
else {
  switch(e) {
    case OPTION_1: System.out.println("option 1"); break;
    default:       System.out.println("default");  break;
  }
}
{% endhighlight %}
Or use trick with default value:
{% highlight java %}
Integer n = getNullableInteger();

// -1 is default here, but you may use Integer.MIN/MAX_VALUE or any
// other value
switch((e != null) ? e : -1) {
  case 1:  System.out.println("1"); break;
  case -1: System.out.println("null"); break;
  default: System.out.println("default"); break;
}
{% endhighlight %}

WARNING: This Java behaviour may cause problems when we translate code from C# to Java.

#### JavaScript switch and null

JavaScript `switch` statement is very flexible, each `case` label may contain
an expression that will be evaluated at runtime. To compare `case` label values to
`switch` value JavaScript uses `===` operator.

In JavaScript there is no problem with using `null` and even `undefined` as `case`
labels. Only tricky thing is with `NaN`s because `NaN === NaN` yields `false`
in JavaScript. This is enforced by IEEE 754 standard that describes floating point
numbers representation and behaviour. 
In other words we can use `NaN` as a `case` label but
program will never enter block of code associated with that label. As a side note
it's worth to mention that in JavaScript `NaN` is 
the only value for which expression `x === x` yields
`false`.

Following program demonstrates flexibility of JavaScript `switch` statement:
{% highlight js %}
var values = [undefined, null, '', 0, NaN, 1, 'foo', {}];

values.forEach(function(value) {
    switch (value) {
        case undefined:
            console.log('undefined');
            break;

         case null:
            console.log('null');
            break;
        
        case '':
            console.log('empty string');
            break;
        
        case 0:
            console.log('zero');
            break;
        
        case NaN:
            // dead code here
            console.log('nan');
            break;
        
        case 1:
            console.log(1);
            break;
        
        // label with runtime expression here:
        case 'f'+'oo':
            console.log('foo');
            break;
        
        default:
            console.log('default');
            break;
    }
});
{% endhighlight %}
This program will write:
{% highlight no-highlight %}
"undefined"
"null"
"empty string"
"zero"
"default"
1
"foo"
"default"
{% endhighlight %}
Notice that `"default"` was printed for `NaN` value.

That's all for today, I hope you learned something new from this article.   
May the Force be with you.


	  ]]></description>
	</item>

	<item>
	  <title>Object and collection initializers in C#</title>
	  <link>//object-and-collection-initializers-in-csharp</link>
	  <author></author>
	  <pubDate>2016-06-12T02:00:00+02:00</pubDate>
	  <guid>//object-and-collection-initializers-in-csharp</guid>
	  <description><![CDATA[
	     In this post I want to present a nice C# syntax sugar: object and collection
initializers.

#### Object initializers
We will start with object initializers. Let's assume we have classes:
{% highlight csharp %}
public class Position {
    public int Top { get; set; }
    public int Left { get; set; }
}

public class Button {
    public Position Position { get; private set; } 
    public string Text { get; set; }
    public int FontSize { get; set; }

    public Button() {
        Position = new Position();
        FontSize = 10;
    }
}
{% endhighlight %}
Without object initializer we could set `Button` object
properties using the following code:
{% highlight csharp %}
var okButton = new Button();

okButton.Position.Top = 100;
okButton.Position.Left = 200;
okButton.Text = "OK";
okButton.FontSize = 13;
{% endhighlight %}
With object initializers we can shorten this code a bit:
{% highlight csharp %}
var okButton = new Button {
    Position = {
        Top = 100,
        Left = 200
    },
    Text = "OK",
    FontSize = 13
};
{% endhighlight %}
Instructions generated by compiler in this two cases are exactly the same, but code 
using object initializer is more clear and more readable.

Now let's dive into some syntax details:  
I. We can pass any parameters to object
constructor using syntax:
{% highlight csharp %}
var foo = new Foo(param1, param2) {
    Property1 = "some value",
    Property2 = "some other value",
    // ...
}
{% endhighlight %}

II. When we call parameterless constructor we can omit parentheses 
(like I did in the `Button` example):
{% highlight csharp %}
var foo = new Foo() {
    // ...
};

// this is exactly the same as new Foo()
var foo2 = new Foo {
    // ...
}
{% endhighlight %}
III. Object initializers can be nested:
{% highlight csharp %}
var invoice = new Invoice {
    ShippingAddress = new Address {
        Street = "Long Street",
        Number = "3A"
    },

    InvoiceAddress = new Address {
        Street = "Short Street",
        Number = "4B"
    }
};
{% endhighlight %}
IV. We can set nested properties without creating new objects  
Do you remember our first example with `Button`? We use
{% highlight csharp %}
var okButton = new Button {
    Position = {
        Top = 100,
        Left = 200
    },
    // ...
};
{% endhighlight %}
to set properties of `Button` `Position` object. Notice that `Position`
property has private setter
{% highlight csharp %}
public Position Position { get; private set; }
{% endhighlight %}
so we cannot use `new` to create new `Position` object
{% highlight csharp %}
var okButton = new Button {
    //         v doesn't compile
    Position = new Position {
        Top = 100,
        Left = 200
    },
    // ...
};
{% endhighlight %}
Fortunately object initializer syntax is flexible enough to allow us
set properties without creating new objects.  

V. Object initializer syntax works only with `new`  
In other words following code doesn't compile:
{% highlight csharp %}
// doesn't compile
var foo = SomeMethodReturningFoo() {
    Property1 = 1
};
{% endhighlight %}

#### Collection initializers

Now it's time to present collection initializers. We will start with
`List<T>` initializers, then we will describe `Dictionary<TKey, TValue>`
initializers.

As we all know C# allows to create and initialize arrays in single expression:
{% highlight csharp %}
var funnyNames = new string[] { "foo", "bar", "baz", "yay" };
{% endhighlight %}
Wouldn't it be nice if this syntax worked with `List<T>`'s? Actually thanks
to collection initializers it works and not only with `List`'s but also with
custom classes!

Let's see an example:
{% highlight csharp %}
List<string> funnyNames = new List<string> { "foo", "bar", "baz" };
{% endhighlight %}
this code is translated by compiler to
{% highlight csharp %}
List<string> tmp = new List<string>();
tmp.Add("foo");
tmp.Add("bar");
tmp.Add("baz");

List<string> funnyNames = tmp;
{% endhighlight %}

Inside initializers we are not limited to constants, we can use complex expressions
like
{% highlight csharp %}
List<object> things = new List<object>() {
    (1+3*7),
    true.ToString(),
    new object()
};
{% endhighlight %}

As we already seen compiler translates collection initializers to a couple
of `Add` calls. We can make collection initializers work with custom classes by
providing `Add` method and implementing `IEnumerable` or `IEnumerable<T>`. This
second requirement is very important - since we are using *collection* initializers,
compiler expects that we will initialize some kind of collection and collections
ought to implement `IEnumerable` interface.

Below we present minimal generic and non-generic class that works with
collections initializers:
{% highlight csharp %}
public class CustomCollection : IEnumerable {
    public void Add(object item) {
        Console.WriteLine("Add({0})", item);
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}

public class CustomCollection<T> : IEnumerable<T> {
    public void Add(T item) {
        Console.WriteLine("Add<T>({0})", item);
    }

    IEnumerator<T> IEnumerable<T>.GetEnumerator() {
        yield break;
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}
{% endhighlight %}
NOTE: We used `yield break` to quickly provide dummy `IEnumerable` implementation.  
Now we can test our custom collections:
{% highlight csharp %}
public class Program
{
    public static void Main(string[] args)
    {
        var nonGeneric = new CustomCollection { 1, 2, 3 };
        var generic = new CustomCollection<int> { 1, 2, 3 };
    }
}
{% endhighlight %}
When ran this program will write:
{% highlight no-highlight %}
Add(1)
Add(2)
Add(3)
Add<T>(1)
Add<T>(2)
Add<T>(3)
{% endhighlight %}

Now since collections initializers are translated to a `Add` method calls, what will happen
when we write `Add` method that take more than one parameter?
{% highlight csharp %}
public class CustomCollection2 : IEnumerable {
    // notice *two* parameters
    public void Add(object item, object item2) {
        Console.WriteLine("Add({0}, {1})", item, item2);
    }

    IEnumerator IEnumerable.GetEnumerator() {
        yield break;
    }
}
{% endhighlight %}
It turns out that we still can use collection initializers, but the syntax is a bit different
{% highlight csharp %}
var coll2 = new CustomCollection2 { 
    { 1, 1 }, 
    { 2, 2 },
    { 3, 3 } 
};
{% endhighlight %}
This is translated by compiler to
{% highlight csharp %}
CustomCollection2 tmp = new CustomCollection2();
tmp.Add(1, 1);
tmp.Add(2, 2);
tmp.Add(3, 3);
CustomCollection2 coll2 = tmp;
{% endhighlight %}

With this knowledge it should be now easy to understand how `Dictionary<TKey, TValue>`
initializers work. First `Dictionary<TKey, TValue>` defines `Add(TKey, TValue)` method,
second it implements `IEnumerable<KeyValuePair<TKey,â€‚TValue>>` interface - so it fulfills all 
requirements needed by collection initializers to work.

We can initialize `Dictionary` with the following code
{% highlight csharp %}
var dict = new Dictionary<string, string> {
    { "1", "one" },
    { "2", "two" },
    { "3", "three" }
};
{% endhighlight %}
Which as we already know is translated into
{% highlight csharp %}
Dictionary<string, string> tmp = new Dictionary<string, string>();
tmp.Add("1", "one");
tmp.Add("2", "two");
tmp.Add("3", "three");

var dict = tmp;
{% endhighlight %}

C# 6 introduced more flexible syntax for `Dictionary` initializers
{% highlight csharp %}
var dict = new Dictionary<string, string> {
    ["1"] = "one",
    ["2"] = "two",
    ["3"] = "three"
};
{% endhighlight %}
This is not translated to `Add` calls, but uses indexer instead
{% highlight csharp %}
Dictionary<string, string> tmp = new Dictionary<string, string>();
tmp["1"] = "one";
tmp["2"] = "two";
tmp["3"] = "three";
var dict = tmp;
{% endhighlight %}

As other collection initializers it can work with custom types, only requirement is that
type must have indexer
{% highlight csharp %}
public class CustomCollection {
    public object this[string key] {
        get { return null; }
        set { /* do something with value */ }
    }
}

// usage:
var coll = new CustomCollection {
    ["foo"] = 1,
    ["bar"] = 2
};
{% endhighlight %}

Another feature is that we can set properties of already existing objects in collection,
for example let's assume that constructor of our collection already added some objects into
collection:
{% highlight csharp %}
public class Example : Dictionary<string, Position> {
    public Example() {
        Add("topLeft", new Position());
        Add("bottomRight", new Position());
    }
}
{% endhighlight %}
Then we can write
{% highlight csharp %}
var example  = new Example {
    ["topLeft"] = { Top = 10, Left = 20 },
    ["bottomRight"] = { Top = 100, Left = 220 }
};
{% endhighlight %}
This will be translated by compiler into
{% highlight csharp %}
Example tmp = new Example();
tmp["topLeft"].Top = 10;
tmp["topLeft"].Left = 20;
tmp["bottomRight"].Top = 100;
tmp["bottomRight"].Left = 220;
Example example = tmp;
{%endhighlight %}

The last thing worth know about this new initializer syntax is ability to mix it with
property initializers e.g.
{% highlight csharp %}
 var example  = new Example {
    ["topLeft"] = { Top = 10, Left = 20 },
    ["bottomRight"] = { Top = 100, Left = 220 },

    // normal property
    Tag = new object()
};
{% endhighlight %}

That was plenty of knowledge, but the best way to learn about initializer is to use
them in code. After a while they become second nature for C# programmers and central part
of many language idioms.



	  ]]></description>
	</item>


</channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Indexes in PostgreSQL database</title>
	  <link>//indexes-in-postgresql</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-08-06T02:00:00+02:00</pubDate>
	  <guid>//indexes-in-postgresql</guid>
	  <description><![CDATA[
	     <p>In this article I will present how to use indexes in PostgreSQL database.</p>

<p>We will need test database for exercises so let’s create one:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">database</span> <span class="n">index_demo</span><span class="p">;</span></code></pre></figure>

<p>Inside <code class="highlighter-rouge">index_demo</code> database we should create three tables:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="n">account</span>
<span class="p">(</span>
    <span class="n">account_id</span> <span class="n">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span> 
    <span class="n">email</span> <span class="n">text</span><span class="p">,</span> 
    <span class="n">first_name</span> <span class="n">text</span><span class="p">,</span> 
    <span class="n">last_name</span> <span class="n">text</span><span class="p">,</span> 
    <span class="n">is_active</span> <span class="n">boolean</span>
<span class="p">);</span>

<span class="k">create</span> <span class="k">table</span> <span class="n">first_name</span> 
<span class="p">(</span>
    <span class="n">id</span> <span class="n">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">first_name</span> <span class="n">text</span>
<span class="p">);</span>

<span class="k">create</span> <span class="k">table</span> <span class="n">last_name</span>
<span class="p">(</span>
    <span class="n">id</span> <span class="n">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">last_name</span> <span class="n">text</span>
<span class="p">);</span></code></pre></figure>

<p><code class="highlighter-rouge">account</code> table will be used in exercises, <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> tables
will be needed to load test data.</p>

<p>To populate <code class="highlighter-rouge">account</code> table we will use <a href="http://www.quietaffiliate.com/free-first-name-and-last-name-databases-csv-and-sql/">freely available database of
most popular first names and last names</a>.
Please download <a href="assets/data/2016-08-06/first_name.csv">first_name.csv</a> and
<a href="assets/data/2016-08-06/last_name.csv">last_name.csv</a> files.</p>

<p>We will use SQL <code class="highlighter-rouge">copy</code> command to load data from CSV files into <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code>
tables:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">copy</span> <span class="n">first_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">)</span> 
<span class="k">from</span> <span class="s1">'/path_to/first_name.csv'</span> 
<span class="k">with</span> <span class="n">csv</span> <span class="k">delimiter</span> <span class="s1">','</span><span class="p">;</span>

<span class="k">copy</span> <span class="n">last_name</span><span class="p">(</span><span class="n">last_name</span><span class="p">)</span> 
<span class="k">from</span> <span class="s1">'/path_to/last_name.csv'</span> 
<span class="k">with</span> <span class="n">csv</span> <span class="k">delimiter</span> <span class="s1">','</span><span class="p">;</span></code></pre></figure>

<p>This command must be run from PostgreSQL account that was created with <code class="highlighter-rouge">superuser</code> option.
You may check if your current account is <code class="highlighter-rouge">superuser</code> by executing query:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">show</span> <span class="n">is_superuser</span><span class="p">;</span>
<span class="o">--</span> <span class="n">if</span> <span class="n">you</span> <span class="k">get</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">'on'</span> <span class="k">or</span> <span class="s1">'yes'</span> <span class="k">then</span> <span class="n">you</span> <span class="k">are</span> <span class="n">a</span> <span class="n">superuser</span></code></pre></figure>

<p>On Ubuntu you can create <code class="highlighter-rouge">superuser</code> account using command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ sudo -u postgres psql -c "create role super_user with login superuser password '1234'"</code></pre></figure>

<p>After loading data from CSV files you should have a bunch of first and last names in
<code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> tables:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">first_name</span><span class="p">;</span>
<span class="c1">-- 5164
</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">last_name</span><span class="p">;</span>
<span class="o">--</span> <span class="mi">88798</span></code></pre></figure>

<p>Now we may use data from <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> to populate <code class="highlighter-rouge">account</code> table:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">select</span> 
    <span class="c1">-- create email by joining first letter of first name, dot and last name
</span>    <span class="k">lower</span><span class="p">(</span><span class="k">substring</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">first_name</span> <span class="k">from</span> <span class="mi">1</span> <span class="k">for</span> <span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="s1">'.'</span><span class="o">||</span><span class="n">L</span><span class="p">.</span><span class="n">last_name</span><span class="o">||</span><span class="s1">'@example.com'</span><span class="p">)</span> <span class="k">as</span> <span class="n">email</span><span class="p">,</span>
    <span class="n">F</span><span class="p">.</span><span class="n">first_name</span> <span class="k">as</span> <span class="n">first_name</span><span class="p">,</span>
    <span class="n">L</span><span class="p">.</span><span class="n">last_name</span>  <span class="k">as</span> <span class="n">last_name</span><span class="p">,</span>
    <span class="k">true</span> <span class="k">as</span> <span class="n">is_active</span>
<span class="k">from</span> <span class="p">(</span>
    <span class="k">select</span> 
        <span class="n">last_name</span><span class="p">,</span>
        <span class="c1">-- select random number from 1 to count_of_first_names
</span>        <span class="n">ceil</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">first_name</span><span class="p">))</span> <span class="k">as</span> <span class="n">first_name_index</span>
    <span class="k">from</span> <span class="n">last_name</span>
<span class="p">)</span> <span class="n">L</span>
<span class="k">inner</span> <span class="k">join</span> <span class="p">(</span>
    <span class="k">select</span> 
        <span class="n">first_name</span><span class="p">,</span> 
        <span class="c1">-- number first names from 1 to count_of_first_names
</span>        <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">()</span> <span class="k">as</span> <span class="k">index</span>
    <span class="k">from</span> <span class="n">first_name</span>
<span class="p">)</span> <span class="n">F</span> <span class="k">on</span> <span class="n">F</span><span class="p">.</span><span class="k">index</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">first_name_index</span>
<span class="o">--</span> <span class="n">we</span> <span class="k">join</span> <span class="k">on</span> <span class="n">first_name_index</span><span class="p">,</span> <span class="n">so</span> <span class="k">each</span> <span class="n">last_name</span> <span class="n">will</span> <span class="k">get</span> <span class="n">random</span> <span class="n">first_name</span></code></pre></figure>

<p>After executing this query <code class="highlighter-rouge">account</code> table will contain test data:
<img src="assets/images/2016-08-06/account_data.png" alt="Data in account table" /></p>

<h4 id="unique-indexes">Unique Indexes</h4>

<p>Often we want to enforce uniqueness of values in given table column.
For example each user should have unique login, there should be
only one person with given national id etc.
Databases allow us to implement such a constraint via unique index.</p>

<p>We will add unique index to <code class="highlighter-rouge">account</code> table to
ensure that each account email is unique:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- udx_account_email is index name
</span><span class="k">create</span> <span class="k">unique</span> <span class="k">index</span> <span class="n">udx_account_email</span> <span class="k">on</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">)</span></code></pre></figure>

<p>If in the future we decide that after all emails may repeat, we may
drop (remove) index using:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">drop</span> <span class="k">index</span> <span class="n">udx_account_email</span><span class="p">;</span></code></pre></figure>

<p>Let’s check how it works:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(</span><span class="s1">'j.doe@example.com'</span><span class="p">,</span> <span class="s1">'jon'</span><span class="p">,</span> <span class="s1">'doe'</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="c1">-- OK
</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(</span><span class="s1">'j.doe@example.com'</span><span class="p">,</span> <span class="s1">'joseph'</span><span class="p">,</span> <span class="s1">'doe'</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="c1">-- ERROR:  duplicate key value violates unique constraint "udx_account_email"
-- DETAIL:  Key (email)=(j.doe@example.com) already exists.
</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(</span><span class="s1">'J.doe@example.com'</span><span class="p">,</span> <span class="s1">'joseph'</span><span class="p">,</span> <span class="s1">'doe'</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="o">--</span> <span class="n">OK</span></code></pre></figure>

<p>Looks like our index works, but uses case sensitive check to compare two emails.
It would be better to ignore case when performing check, we may achieve this by using
<code class="highlighter-rouge">lower</code> function (converts strings to lower case) in our index definition:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">drop</span> <span class="k">index</span> <span class="n">udx_account_email</span><span class="p">;</span>
<span class="k">create</span> <span class="k">unique</span> <span class="k">index</span> <span class="n">udx_account_email</span> <span class="k">on</span> <span class="n">account</span><span class="p">(</span><span class="k">lower</span><span class="p">(</span><span class="n">email</span><span class="p">));</span></code></pre></figure>

<p>Now index will check if <code class="highlighter-rouge">lower(email)</code> value is unique across table:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">delete</span> <span class="k">from</span> <span class="n">account</span> <span class="k">where</span> <span class="n">last_name</span> <span class="k">like</span> <span class="s1">'doe'</span><span class="p">;</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(</span><span class="s1">'j.doe@example.com'</span><span class="p">,</span> <span class="s1">'joe'</span><span class="p">,</span> <span class="s1">'doe'</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="c1">-- OK
</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">is_active</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(</span><span class="s1">'J.doe@example.com'</span><span class="p">,</span> <span class="s1">'joseph'</span><span class="p">,</span> <span class="s1">'doe'</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="c1">-- ERROR:  duplicate key value violates unique constraint "udx_account_email"
</span><span class="o">--</span> <span class="n">DETAIL</span><span class="p">:</span>  <span class="k">Key</span> <span class="p">(</span><span class="k">lower</span><span class="p">(</span><span class="n">email</span><span class="p">))</span><span class="o">=</span><span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="n">doe</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span> <span class="n">already</span> <span class="k">exists</span><span class="p">.</span></code></pre></figure>

<h4 id="standard-indexes">Standard Indexes</h4>

<p>In databases indexes are mainly used to speed up queries.
By keeping additional information database can retrieve values more
quickly.
The following example will illustrate that:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span>

<span class="c1">-- Seq Scan on account  (cost=0.00..1907.98 rows=17 width=39)
</span><span class="o">--</span>   <span class="n">Filter</span><span class="p">:</span> <span class="p">(</span><span class="n">first_name</span> <span class="o">~~</span> <span class="s1">'Michael'</span><span class="p">::</span><span class="n">text</span><span class="p">)</span></code></pre></figure>

<p>We can use <code class="highlighter-rouge">explain</code> to ask database how it will execute query.
In our example since we don’t have any index on <code class="highlighter-rouge">first_name</code> column
database will read every row in the table (that’s what Seq Scan mean)
and then check if <code class="highlighter-rouge">fist_name</code> is equal to <code class="highlighter-rouge">Michael</code>. If our table
would contain millions of rows this would be really slow.
To speed things up we may add index on <code class="highlighter-rouge">first_name</code> column 
that will keep track where rows with given <code class="highlighter-rouge">first_name</code> are stored:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">index</span> <span class="n">idx_account_first_name</span> <span class="k">on</span> <span class="n">account</span><span class="p">(</span><span class="n">first_name</span><span class="p">);</span>

<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span>

<span class="c1">-- Index Scan using idx_account_first_name on account  (cost=0.29..8.63 rows=17 width=39)
--  Index Cond: (first_name = 'Michael'::text)
</span><span class="o">--</span>  <span class="n">Filter</span><span class="p">:</span> <span class="p">(</span><span class="n">first_name</span> <span class="o">~~</span> <span class="s1">'Michael'</span><span class="p">::</span><span class="n">text</span><span class="p">)</span></code></pre></figure>

<p>Now we can see that database will use index to perform search (Index Scan).
When we look at <code class="highlighter-rouge">cost</code> returned by explain we can see that
now it’s equal to <code class="highlighter-rouge">0.29 - 8.63</code>, and without index it was equal to <code class="highlighter-rouge">0 - 1907.98</code>. 
This means that we should expect x200 performance improvement especially
with more rows in account table.</p>

<p>Indexes are great way to speed queries up but they come with a cost, database must
update index every time you insert a new row into table or update existing one.
Adding too many indexes to table may actually slow things down, be warned.</p>

<h4 id="multicolumn-indexes">Multicolumn Indexes</h4>

<p>PostgreSQL allows us to define index on multiple columns.
For example let’s say that we want to speed up query that filters
accounts by first name and last name:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- we use analyze option here to get total query running time
</span>
<span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Heber'</span> <span class="k">and</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span>

<span class="c1">-- Index Scan using idx_account_first_name on account  (cost=0.29..8.32 rows=1 width=39) (actual time=0.001..0.001 rows=0 loops=1)
--  Index Cond: ((first_name = 'Heber'::text) AND (first_name = 'Michael'::text))
--  Filter: ((first_name ~~ 'Heber'::text) AND (first_name ~~ 'Michael'::text))
</span><span class="o">--</span> <span class="n">Total</span> <span class="n">runtime</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">017</span> <span class="n">ms</span></code></pre></figure>

<p>As we can see this query uses <code class="highlighter-rouge">idx_account_first_name</code> index that we created in
previous section and has quite good performance already.
But we can do even better by creating index on <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> column:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">drop</span> <span class="k">index</span> <span class="n">idx_account_first_name</span><span class="p">;</span>

<span class="k">create</span> <span class="k">index</span> <span class="n">idx_acount_first_name_last_name</span> 
    <span class="k">on</span> <span class="n">account</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span></code></pre></figure>

<p>Now we get:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">last_name</span> <span class="k">like</span> <span class="s1">'Heber'</span> <span class="k">and</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span>

<span class="c1">-- Index Scan using idx_acount_first_name_last_name on account  (cost=0.42..8.44 rows=1 width=39) (actual time=0.001..0.001 rows=0 loops=1)
--  Index Cond: ((first_name = 'Heber'::text) AND (first_name = 'Michael'::text))
--  Filter: ((first_name ~~ 'Heber'::text) AND (first_name ~~ 'Michael'::text))
</span><span class="o">--</span> <span class="n">Total</span> <span class="n">runtime</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">013</span> <span class="n">ms</span></code></pre></figure>

<p>We didn’t gain much in this example (running time 0.017 ms vs 0.013 ms) 
but it’s worth to know that
multicolumn indexes are available in PostgreSQL.</p>

<p>If we define index on columns <code class="highlighter-rouge">col1, ..., colN</code> PostgreSQL can use it
to optimize queries that test for equality/inequality for columns <code class="highlighter-rouge">col1 ... colK</code> and
that use comparisons (equal, greater then, less than etc.) on <code class="highlighter-rouge">col(K+1)</code>.
In other words our multicolumn index will be used to optimize queries:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- we test first index column for equality
</span><span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span><span class="p">;</span>

<span class="c1">-- we test first index column for equality
-- and perform comparison on second index column:
-- last_name must be greater than 'A' and less than 'B' (in lexicographic order)
</span><span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">first_name</span> <span class="k">like</span> <span class="s1">'Michael'</span> <span class="k">and</span> <span class="n">last_name</span> <span class="k">like</span> <span class="s1">'A%'</span></code></pre></figure>

<p>But our index cannot be used to optimise query:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- first_name is not used in where, index can be only used
-- when we test for equality/inequality on first_name and
-- perform some additional test on last_name
</span><span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">last_name</span> <span class="k">like</span> <span class="s1">'Heber'</span></code></pre></figure>

<p>The last thing to remember is that multicolumn indexes can take up a lot of space
on disk. We can get size of all indexes for given table via query:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">pg_size_pretty</span><span class="p">(</span><span class="n">pg_indexes_size</span><span class="p">(</span><span class="s1">'account'</span><span class="p">));</span>
<span class="c1">-- 4896 kB
</span>
<span class="c1">-- while using single column index on first_name:
</span><span class="k">select</span> <span class="n">pg_size_pretty</span><span class="p">(</span><span class="n">pg_indexes_size</span><span class="p">(</span><span class="s1">'account'</span><span class="p">));</span>
<span class="o">--</span> <span class="mi">4040</span> <span class="n">kB</span></code></pre></figure>

<h4 id="partial-indexes">Partial Indexes</h4>

<p>Sometime we want to index only part of the table rows. In our example we may
want to index <code class="highlighter-rouge">email</code>s of only active users.
To support such scenarios PostgreSQL provides partial indexes.
For example:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- you must use where clause to specify 
-- which rows should be included in index
</span>
<span class="k">create</span> <span class="k">index</span> <span class="n">idx_email_active_account</span> <span class="k">on</span> <span class="n">account</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
        <span class="k">where</span> <span class="n">is_active</span><span class="p">;</span></code></pre></figure>

<p>After index creation database will use index to speed up queries like:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- we search only active accounts
</span><span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">email</span> <span class="k">like</span> <span class="s1">'foo'</span> <span class="k">and</span> <span class="n">is_active</span> <span class="o">=</span> <span class="k">true</span></code></pre></figure>

<p>But will use SeqScan to perform queries:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- we may want to include not active accounts
</span><span class="k">select</span> <span class="o">*</span> 
<span class="k">from</span> <span class="n">account</span>
<span class="k">where</span> <span class="n">email</span> <span class="k">like</span> <span class="s1">'foo'</span></code></pre></figure>

<h4 id="the-end">The End</h4>
<p>That’s all for today, thanks for reading.</p>

<p>If you have any suggestion how I can improve this blog please
leave a comment!</p>

	  ]]></description>
	</item>


</channel>
</rss>

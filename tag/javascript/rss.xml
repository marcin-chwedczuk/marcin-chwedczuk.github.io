<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>JavaScript in and delete operators</title>
	  <link>//JavaScript-in-and-delete-operators</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-11-12T01:00:01+01:00</pubDate>
	  <guid>//JavaScript-in-and-delete-operators</guid>
	  <description><![CDATA[
	     In this post I will describe `in` and `delete` JavaScript operators.

Operator `in` can be used to check if given object has given property:
{% highlight javascript %}
var obj = {
	propA: 'xxx',
	propB: { someData: 101 }
};
	
console.log('propA' in obj); // true
console.log('notExisting' in obj); // false
	
obj.notExisting = 'xxx';
console.log('notExisting' in obj); // true

var propName = 'propA';
console.log(propName in obj); // true
{% endhighlight %}
While checking if object has given property `in` also checks
prototype chain:
{% highlight javascript %}
var proto = {
	propA: 'xxx'
};
	
var obj = Object.create(proto);
obj.propB = 'yyy';
	
console.log('toString' in obj); // true - from Object
console.log('propA' in obj); // true - from proto
console.log('propB' in obj); // true - own property
{% endhighlight %}

Adding properties to objects in JavaScript is easy, what's about removing?
{% highlight javascript %}
var obj = { };
obj.prop = 1;

// attempt to remove prop
obj.prop = undefined;

// assigning undefined to property doesn't remove it 
console.log('prop' in obj); // true
console.log(Object.keys(obj)); // ["prop"]

delete obj.prop;
// or delete obj['prop'];

// now property is gone
console.log('prop' in obj); // false 
console.log(Object.keys(obj)); // []
{% endhighlight %}
But we cannot delete anything from prototype chain:
{% highlight javascript %}
var proto = { prop: 1 };
var obj = Object.create(proto);

console.log('prop' in obj); // true
console.log(Object.keys(obj)); // []

delete obj.prop;

// nothing changed
console.log('prop' in obj); // true
console.log(Object.keys(obj)); // []
{% endhighlight %}
Also in strict mode we cannot delete global functions and variables
but we can delete properties of `window` object:
{% highlight javascript %}
function globalFunc() { }
var globalVar = 1;
window.globalViaProp = 1;

(function () {
  'use strict';

  // "SyntaxError: Delete of an unqualified identifier in strict mode.
  // delete globalFunc;
  // delete globalVar;
  // delete globalViaProp;
  
  // "TypeError: Cannot delete property 'globalVar' of #<Window>
  // delete window.globalVar;
  // delete window.globalFunc;
  delete window.globalViaProp; // ok
 
})();
{% endhighlight %}
As usual with JavaScript without strict mode you won't get any of these errors.

And what if you want to make one of your own properties undeletable?  
No problem just mark is as a non configurable prop:
{% highlight javascript %}
(function () {
  'use strict';

  var obj = {};
  
  Object.defineProperty(obj, 'nonDeletable', {
    value: 'foo forever',
    writable: false,
    configurable: false, // cannot be deleted
    enumerable: true
  });
  
  console.log(obj.nonDeletable);
  
  // strict mode again:
  // "TypeError: Cannot delete property 'nonDeletable' 
  // delete obj.nonDeletable;
})();
{% endhighlight %}

The last thing about `delete` to remember is that it returns `true`
when it manages to remove property and `false` otherwise.
If you think that this may be useful, look at the example below:
{% highlight javascript %}
var proto = { foo: 1};
var obj = Object.create(proto);
	
// property was not removed but we get true
console.log(delete obj.foo); // true
console.log(obj.foo); // 1
	
// property didn't exist but we get true again
console.log(delete obj.bar); // true
console.log(obj.bar); // undefined 
{% endhighlight %}
OK OK to be honest `delete` returns `true` when object 
doesn't have *own* property after executing delete operation.
In other words if `delete` returns `true` we may be certain 
that property name doesn't appear
in array returned by `Object.keys()`.

The End

	  ]]></description>
	</item>

	<item>
	  <title>Hoisting in JavaScript</title>
	  <link>//hoisting-in-javascript</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-10-30T02:00:00+02:00</pubDate>
	  <guid>//hoisting-in-javascript</guid>
	  <description><![CDATA[
	     In this post I will describe what is variable hoisting in JavaScript.
But before we go into detailed explanations let's look at
a few code examples.

Let's start with function `bad()` that tries to
access not defined variable:
{% highlight javascript %}
function bad() {
    console.log(notDefinedVariable);
}

bad();
// result:
// "ReferenceError: notDefinedVariable is not defined
{% endhighlight %}
As we would expected attempt to read `notDefinedVariable`
ends with an error, namely `ReferenceError` exception.

Now you may be wondering what will happen when we try
to write value to not defined variable:
{% highlight javascript %}
function bad2() {
    notDefinedVariable = 'fufufu';
}

bad2(); // no error

console.log(notDefinedVariable);
// prints: "fufufu"
{% endhighlight %}
In this case we get no error and everything seems to work,
but after a call to `bad2()` `notDefinedVariable` is still visible.
What happened here is that we accidentally create 
`notDefinedVariable` *global* variable.

Using global variables is regarded by many programmers as
bad practice, especially when you can create them accidentally.
To prevent errors and encourage good programming style 
ECMAScript 5 standard (which defines JavaScript language)
introduced so called *strict mode*.
We can enable strict mode by beginning function with `'use strict';`
instruction.
With strict mode enabled we get `ReferenceError` exception
when we try to write to undefined variable:
{% highlight javascript %}
function bad3() {
    'use strict';
    notDefinedVariable = 'fufufu';
}

bad3();
// result: "ReferenceError: undefinedVariable is not defined
{% endhighlight %}

You may be wondering what will happen when we declare
variable but didn't assign any value to it, will we get
an error while accessing variable value or not?
{% highlight javascript %}
function soSo() {
    'use strict';
    
    var foo;
    console.log(foo);
}

soSo();
// prints: undefined
{% endhighlight %}
We didn't get an error, that's because variables declared using `var` keyword
initially have value of `undefined` until explicitly assigned by the user.

Now let's look on a bit more complicated example:
{% highlight javascript %}
function hoisting1() {
    'use strict';

    console.log(x);
    
    var x = 3;
    console.log(x);
}

hoisting1();
// prints: undefined 3
{% endhighlight %}
You may wonder what happened here. We already know that reading
from undefined variables causes `ReferenceError` exception, but
why first call to `console.log(x)` didn't throw any?
And what about `undefined` value that was printed, 
we know that this is the value of declared but not initialized variables.
So to sum up this function behaves as if variable `x` was declared
at the very beginning of `hoisting1` function:
{% highlight javascript %}
function hoisting1() {
    'use strict';
    
    var x;

    console.log(x);
    x = 3;
    console.log(x);
}
{% endhighlight %}
And this is what hoisting is all about. In JavaScript it doesn't
matter where you declare variables inside function body
because they declarations will be implicitly 
moved to the beginning of the function.
For example `func1()` when processed by JavaScript interpreter
behaves exactly the same as `func2()`:
{% highlight javascript %}
function func1() {
    'use strict';
    
    var x = 1;
    console.log(x);

    for (var i = 0; i < 3; i += 1) {
        console.log(i);
    }

    if (x > 0.5) {
       var y = 2*x;
       console.log(y);
    }
}

function func2() {
    'use strict';

    var x, i, y;

    x = 1;
    console.log(x);

    for (i = 0; i < 3; i += 1) {
        console.log(i);
    }

    if (x > 0.5) {
       y = 2*x;
       console.log(y);
    }
}
{% endhighlight %}

As you may expect hoisting can make troubles when we are not
alert, for example can you spot a bug here:
{% highlight javascript %}
function withBug() {
    'use strict';
    var arrayI = [1,2,3],
        arrayJ = [3,2,1];

    for (var i = 0; i < arrayI.length; i += 1) {
        arrayI[i] += 1;
    }

    for (var j = 0; j < arrayJ.length; j += 1) {
        if (arrayJ[j] == 2) {
            console.log(arrayJ[i]);
            break;
        }
    }
}

withBug();
// prints: undefined
{% endhighlight %}
If `i` was accessible only inside `for(var i ...)` loop
interpreter would spot problem with `console.log(arrayJ[i])` line
and would thrown a `ReferenceError` exception. Unfortunately 
because of hoisting
variable `i` is accessible through entire function body and only
wrong behaviour of our program can tell us that something is wrong.

So how can we make our programs secure against bugs caused by
hoisting? The simples thing to do is to declare all function
variables at the beginning of function body, thus making
hoisting explicit:
{% highlight javascript %}
function sum(array) {
    'use strict';

    // declare all variables at the beginning   
    var arrSum = 0, i;
  
    for (i = 0; i < array.length; i += 1) {
      arrSum += array[i];
    }
  
    return arrSum;
}
{% endhighlight %}
This is simple and effective solution but a bit cumbersome to use,
it would be better to declare variables in the place of their first usage
right? So the second solution is to just ignore the problem, if
you are keeping size of your function small (no longer than 20 lines
of code) and you follow good coding practices (especially you give
your variables good descriptive names, and prefer `forEach` method to
`for` loops)
you should have no problems with hoisting.

In some cases you really want to reduce visibility of a variable to
some block of code, the popular solution to this problem is 
to use [IIFE pattern](https://developer.mozilla.org/en-US/docs/Glossary/IIFE):
{% highlight javascript %}
function iife() {
    'use strict';
    
    // following line produces: ReferenceError: i is not defined
    // console.log('before IIFE: ' + i);
  
    // iife expression - we declare anonymous
    // function and immediately invoke it
    (function() {
      for (var i = 0; i < 3; i+=1) {
        console.log(i);
      }
    }());
  
    // following line produces: ReferenceError: i is not defined
    // console.log('after IIFE: ' + i);
}

iife();
// prints: 0 1 2
{% endhighlight %}
Here variable `i` is visible only inside IIFE expression.
Using IIFE has it's own problems especially when we want to
access `this` value inside IIFE expression.
We must either pass `this` via local variable:
{% highlight javascript %}
function foo() {
	// it is a convention to call such a variable
	// that or self
	var that = this;

	(function() {
		that.someMethod();
	}());
}
{% endhighlight %}
or use `call()` to invoke function:
{% highlight javascript %}
function foo() {
	(function() {
		this.someMethod();
	}).call(this);
}
{% endhighlight %}

Almost every popular language (e.g. Java, C#, C++) follows block scoping
rules, this means that variable is visible only inside a block of
code in which it is declared. For example in Java:
{% highlight java %}
int i = 0;
{
	int j = 3;
	// we can use i and j here
}
// j no longer visible here
for (int k = 0; k < 3; k++ ) {
	// k and i are visible here
}
// k is no longer visible here
// but we can access i
{% endhighlight %}
Compare this with JavaScript version:
{% highlight javascript %}
// can use i, j and k here
var i = 0;
// can use i, j and k here
{
	var j = 3;
	// can use i, j and k here
}
// can use i, j and k here
for (var k = 0; k < 3; k++ ) {
	// can use i, j and k here
}
// can use i, j and k here
{% endhighlight %}
If you have this strange feeling that something is wrong here
you are not the only one.
JavaScript community decided to introduce proper lexical scoping
to JavaScript in ECMAScript 2015 standard (sometimes called ES6).
ECMAScript 2015 introduces a new JavaScript keyword `let` that
works like `var` but with lexical scoping.
Here's how our example looks with `let`:
{% highlight javascript %}
function letTest() {
	'use strict';
	let i = 0;
	{
		let j = 3;
	}
	// cannot use j here
	for (let k = 0; k < 10; k++) {
		console.log(k);
	}
	// cannot use k here 
}

letTest();
{% endhighlight %}
`let` also prohibits redeclarations of variables:
{% highlight javascript %}
function foo() {
	var i = 3;
	var i = 7; // ok

	let j = 3;
	let j = 7; // error
}
{% endhighlight %}
Support of ES6 among browsers is pretty good right now (you may also use it
with node.js), but I guess if you have a chance to work with ES6 you most
probably will be transpiling ES6 code into ES5 code (a plain old JavaScript)
using Babel or some other transpiler.

I hope you now know what hoisting is and what troubles it can make.
If you have any remarks how I can improve this article please leave a comment.

	  ]]></description>
	</item>

	<item>
	  <title>How null's are handled in switch statement in C#, Java and JavaScript</title>
	  <link>//how-nulls-are-handled-in-switch-statement</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-07-09T02:00:00+02:00</pubDate>
	  <guid>//how-nulls-are-handled-in-switch-statement</guid>
	  <description><![CDATA[
	     Let's start with C#. In C# `null`s may show up in `switch` statement in two cases:

1. We `switch` on `string` type
2. We `switch` on nullable `char`, nullable integral type (`byte`, `short` etc.) 
 or nullable enum

Both cases are handled by compiler in the same way,
we just declare `case null` label and it will work out of the box.

This is illustrated by simple program:
{% highlight csharp %}
using System;

public class Program
{
   public void Main() {
        int? n = GetDefault<int?>();
 
        // This will write null       
        switch(n) {
            case null: Console.WriteLine("null");    break;
            case 1:    Console.WriteLine("value 1"); break;
            default:   Console.WriteLine("default"); break;
        }


        string s = GetDefault<string>();
 
        // This will write null       
        switch(s) {
            case null:   Console.WriteLine("null");    break;
            case "foo":  Console.WriteLine("foo");     break;
            default:     Console.WriteLine("default"); break;
        }
    }
    
    // GetDefault returns null for nullable and reference type T
    private T GetDefault<T>() {
        return default(T);   
    }
}
{% endhighlight %}

##### Java switch and null's

In Java `null`'s may show up in `switch` statement when we `switch` 
on primitive type wrappers like `Integer` or on `String` or on enum type.
In that case Java will throw `NullPointerException` as is demonstrated by program:
{% highlight java %}
public class Program 
{
  public static void main(String[] args)
  {
    String s = getNullString();
    try {
      switch(s) {
          // case null - doesn't compile:
          // error: constant string expression required
          // case null:  System.out.println("null"); break;

          case "foo": System.out.println("foo"); break;
          default:    System.out.println("default"); break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(s) {` line
        System.out.println("null pointer exception");
    }
    
    FooEnum e = getNullFooEnum();
    try {
      switch(e) {
       // case null doesn't compile
       // error: an enum switch case label must be the unqualified name of an enumeration constant
       // case null: System.out.println("null"); break;
        
       case OPTION_1: System.out.println("option 1"); break;
       default:       System.out.println("default");  break;
      }
    }
    catch(NullPointerException ex) {
        // exception stack trace points to `switch(e) {` line
        System.out.println("null pointer exception");
    }
  }
  private static String getNullString() {
        return null; 
  }
  private static FooEnum getNullFooEnum() {
    return null;
  }
}

enum FooEnum {
  OPTION_1,
  OPTION_2
}
{% endhighlight %}
Program output:
{% highlight no-highlight %}
null pointer exception
null pointer exception
{% endhighlight %}
As we have seen it's not even possible to declare `case null` label.

In Java until you are 100% sure that value will not contain `null` you must
explicitly check for `null` before switch as in:
{% highlight java %}
FooEnum e = getNullFooEnum();

if (e == null) { 
  System.out.println("null"); 
}
else {
  switch(e) {
    case OPTION_1: System.out.println("option 1"); break;
    default:       System.out.println("default");  break;
  }
}
{% endhighlight %}
Or use trick with default value:
{% highlight java %}
Integer n = getNullableInteger();

// -1 is default here, but you may use Integer.MIN/MAX_VALUE or any
// other value
switch((e != null) ? e : -1) {
  case 1:  System.out.println("1"); break;
  case -1: System.out.println("null"); break;
  default: System.out.println("default"); break;
}
{% endhighlight %}

WARNING: This Java behaviour may cause problems when we translate code from C# to Java.

#### JavaScript switch and null

JavaScript `switch` statement is very flexible, each `case` label may contain
an expression that will be evaluated at runtime. To compare `case` label values to
`switch` value JavaScript uses `===` operator.

In JavaScript there is no problem with using `null` and even `undefined` as `case`
labels. Only tricky thing is with `NaN`s because `NaN === NaN` yields `false`
in JavaScript. This is enforced by IEEE 754 standard that describes floating point
numbers representation and behaviour. 
In other words we can use `NaN` as a `case` label but
program will never enter block of code associated with that label. As a side note
it's worth to mention that in JavaScript `NaN` is 
the only value for which expression `x === x` yields
`false`.

Following program demonstrates flexibility of JavaScript `switch` statement:
{% highlight js %}
var values = [undefined, null, '', 0, NaN, 1, 'foo', {}];

values.forEach(function(value) {
    switch (value) {
        case undefined:
            console.log('undefined');
            break;

         case null:
            console.log('null');
            break;
        
        case '':
            console.log('empty string');
            break;
        
        case 0:
            console.log('zero');
            break;
        
        case NaN:
            // dead code here
            console.log('nan');
            break;
        
        case 1:
            console.log(1);
            break;
        
        // label with runtime expression here:
        case 'f'+'oo':
            console.log('foo');
            break;
        
        default:
            console.log('default');
            break;
    }
});
{% endhighlight %}
This program will write:
{% highlight no-highlight %}
"undefined"
"null"
"empty string"
"zero"
"default"
1
"foo"
"default"
{% endhighlight %}
Notice that `"default"` was printed for `NaN` value.

That's all for today, I hope you learned something new from this article.   
May the Force be with you.


	  ]]></description>
	</item>

	<item>
	  <title>Augmenting JavaScript objects with toString and valueOf</title>
	  <link>//augmenting-JavaScript-objects-with-toString-and-valueOf</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-09T02:00:00+02:00</pubDate>
	  <guid>//augmenting-JavaScript-objects-with-toString-and-valueOf</guid>
	  <description><![CDATA[
	     Today I want to present two useful methods: `toString` and `valueOf`. Both of these methods are 
used by JavaScript interpreter when converting objects to primitive types.

We will start with `toString` that can be useful for debugging purposes, say we have an object:
{% highlight js %}
var point = {
  x: 10,
  y: 20
};
{% endhighlight %}
When we try to convert it to `String` e.g. using `'' + point` expression, we get (in Chrome):
{% highlight no-highlight %}
[object Object]
{% endhighlight %}
Wouldn't it be nice to get `(10, 20)`? With support of `toString` we can do it, simply
let's augment our point with `toString` method:
{% highlight js %}
point.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
};
{% endhighlight %}
now `String(point)` returns:
{% highlight js %}
"(10, 20)"
{% endhighlight %}
This works too when we concatenate our point with string, or when we are join'ing array of points:
{% highlight js %}
> 'current position: ' + point
"current position: (10, 20)"

> [point, point, point].join('; ');
"(10, 20); (10, 20); (10, 20)"
{% endhighlight %}
It will also work in any other situation when object is coerced to `String` type. Unfortunately
it doesn't work with `console.log`:
{% highlight js %}
> console.log(point)
Object {x: 10, y: 20}
{% endhighlight %}

Now we go into interesting topic: when JavaScript objects are converted to string's?
We already given two examples: when object is concatenated with string and when we explicitly
convert object to string via `String(obj)` call.
But this will also happen when we use object with operators like `>` or `>=`. 
Exact rules are pretty compiled and
if your are interested in them I advice reading chapter 8 (Type coercion) and 9 (Operators) from excellent 
[Speaking JS book.](http://speakingjs.com/es5/ch08.html)
For now let's consider simple example, what will happen when we try to use `>` on
points with `toString` method:
{% highlight js %}
var Point = function(x, y) {
    this.x = x;
    this.y = y;
};

Point.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
};

var p1 = new Point(10, 20);
var p2 = new Point(20, 30);
var p3 = new Point(20, 15);
{% endhighlight %}
When interpreter executes expression like `p1 > p2` first it tries to convert objects to
primitives - first by calling `valueOf` method (by default it will return `this`) and if 
it not return primitive value then it tries `toString`. Since we are providing our own
version of `toString` that returns primitive value (a `String`) interpreter will use values returned
by `toString` to compare points, so:
{% highlight js %}
> // because '(20, 30)' > '(10, 20)'  - strings in JS are compared lexicographically
> p1 > p2
false
> p2 > p1
true
> // because '(20, 30)' > '(20, 15)':
> p2 > p3
true
{% endhighlight %}
Looks like we overloaded `>` operator in JavaScript, yay! But we must be aware of limitations of
this technique: first we are comparing strings not object properties, second string in JS are compared
lexicographically so `'2' > '111'`. In other words don't use it in production code it may cause
too much confusion, explicit method like
`Point.compare` would be much better.

Now we can turn to `valueOf` method, in it's working it is similar to `toString` method, only difference
is that it is called when object must be converted to `Number`.
Let's see quick example:
{% highlight js %}
var obj = {
    valueOf: function() {
        return 42;
    }
};

console.log(Number(obj)); // prints 42
{% endhighlight %}

Object is converted to number when used with operators like: `+`, `*` and `-`. Also `valueOf` is used
when objects are compared using `>` or `>=` operators. `valueOf` is not as useful as `toString` IMHO,
but it's worth to know. One more fact is that `Date` objects have custom implementation of `valueOf` method
that returns number of milliseconds from epoch (in other words it returns same value as `getTime()`). Thanks
to this we can use `>` to compare dates, and get difference in milliseconds between dates as: `date2 - date1`.


	  ]]></description>
	</item>

	<item>
	  <title>Break out of block of code in Java and JavaScript</title>
	  <link>//break-out-of-code-block-in-java-and-javascript</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-04T02:00:00+02:00</pubDate>
	  <guid>//break-out-of-code-block-in-java-and-javascript</guid>
	  <description><![CDATA[
	     Java and JavaScript have a common feature that allows us to break out of
nested loops, e.g. in Java we may write:
{% highlight java %}
OUTER_LOOP: for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        System.out.printf("%d x %d = %d%n", i, j, i * j);
        if (j == 1) break OUTER_LOOP;
    }
}
{% endhighlight %}
As you can see first we label outer for loop with `OUTER_LOOP` label, then we use
`break label_name` syntax to tell compiler which loop we want to break.

Likewise in JavaScript we may write:
{% highlight js %}
OUTER_LOOP: for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 3; j++) {
        console.log([i, 'x', j, '=', i*j].join(' '));
        if (j == 1) break OUTER_LOOP;
    }
}
{% endhighlight %}
both programs will print:
{% highlight no-highlight %}
0 x 0 = 0
0 x 1 = 0
{% endhighlight %}

TIP: You can use `continue` instead of `break` and it will work too.

I think most of you knew this already, but what's more interesting is that you can break
out of any nested code block, for example in Java:
{% highlight java %}
public static void func(boolean useBreak) {
    System.out.println("before outer");
    OUTER: {
        System.out.println("before break");

        // condition needed to prevend unreachable statement error
        if (useBreak)
            break OUTER;

        System.out.println("after break");
    }
    System.out.println("after outer");
}

public static void main(String[] args) {
    func(true);
}
{% endhighlight %}
this program will print when run:
{% highlight no-highlight %}
before outer
before break
after outer
{% endhighlight %}

And similarly in JavaScript you can write:
{% highlight js %}
console.log('before outer');
OUTER: {
    console.log('before break');
    break OUTER;
    console.log('after break');
}
console.log('after outer');
{% endhighlight %}

Ability to break nested loops and to jump out of nested code blocks is not
something that you do on everyday job, but once in a year it may become handy.

Just remember to not overuse it (from [XKCD](https://xkcd.com/292/)):
![xkcd goto](//imgs.xkcd.com/comics/goto.png)


	  ]]></description>
	</item>


</channel>
</rss>

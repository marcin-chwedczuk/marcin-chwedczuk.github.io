<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>ReadOnly does not mean Immutable</title>
	  <link>//read-only-does-not-mean-immutable</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2019-01-06T01:00:00+01:00</pubDate>
	  <guid>//read-only-does-not-mean-immutable</guid>
	  <description><![CDATA[
	     <p>Recently I have introduced a subtle bug into my code.
It all started when I was creating a few
value object classes:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">Method</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">Method</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TypedArgument</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">Type</span> <span class="n">Type</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">TypedArgument</span><span class="p">(</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">object</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Type</span> <span class="p">=</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MethodCall</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">Method</span> <span class="n">CalledMethod</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">PassedArguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">MethodCall</span><span class="p">(</span>
        <span class="n">Method</span> <span class="n">calledMethod</span><span class="p">,</span>
        <span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CalledMethod</span> <span class="p">=</span> <span class="n">calledMethod</span><span class="p">;</span>
        <span class="c1">// NOTICE: No defensive copy.
</span>        <span class="n">PassedArguments</span> <span class="p">=</span> <span class="n">args</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>While implementing <code class="highlighter-rouge">MethodCall</code> class constructor, I wrongly assumed
that <code class="highlighter-rouge">IReadOnlyList&lt;T&gt;</code> behaves like an immutable list.
In other words that its content never changes.
Due to this wrong assumption I did not create a defensive copy,
that I usually do for collection arguments,
but instead I just assigned <code class="highlighter-rouge">args</code> parameter to
a readonly property named <code class="highlighter-rouge">PassedArguments</code>.</p>

<p><code class="highlighter-rouge">MethodCall</code> object was then used by another component
called <code class="highlighter-rouge">MethodCallSpy</code>:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">MethodCallSpy</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">MethodCall</span><span class="p">&gt;</span> <span class="n">_methodCalls</span>
        <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">MethodCall</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">MethodCall</span><span class="p">&gt;</span> <span class="n">MethodCalls</span>
        <span class="p">=&gt;</span> <span class="n">_methodCalls</span><span class="p">;</span>

    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">_currentArguments</span>
        <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">AddArgument</span><span class="p">(</span><span class="n">TypedArgument</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_currentArguments</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">AddMethodCall</span><span class="p">(</span><span class="n">Method</span> <span class="n">method</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">methodCall</span> <span class="p">=</span> 
            <span class="k">new</span> <span class="nf">MethodCall</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">_currentArguments</span><span class="p">);</span>
        <span class="n">_methodCalls</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">methodCall</span><span class="p">);</span>

        <span class="c1">// NOTICE: Old List&lt;T&gt; is not modified.
</span>        <span class="n">_currentArguments</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">MethodCallSpy</code>
gathers <code class="highlighter-rouge">TypeArgument</code>s passed to it via <code class="highlighter-rouge">AddArgument</code> calls
in <code class="highlighter-rouge">_currentArguments</code> list. 
Then when someone calls <code class="highlighter-rouge">AddMethodCall</code> method, it uses stored
<code class="highlighter-rouge">TypeArgument</code>s and a value of <code class="highlighter-rouge">method</code> parameter to construct
a new <code class="highlighter-rouge">MethodCall</code> object and adds it to <code class="highlighter-rouge">_methodCalls</code> list.</p>

<p><code class="highlighter-rouge">MethodCallSpy</code> class worked perfectly, at least until I
returned to it a few days later to make some improvements.
Yes, I know, I know
<a href="https://xkcd.com/1691/">“premature optimization is the root of all evil”</a>
but this was my quick’n’dirty pet project and I just cannot resist:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="c1">// readonly added.
</span><span class="k">private</span> <span class="k">readonly</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">_currentArguments</span>
    <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;();</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">AddMethodCall_AfterRefactoring</span><span class="p">(</span><span class="n">Method</span> <span class="n">method</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Assumes that MethodCall will make a defensive copy
</span>    <span class="c1">// of _currentArguments list.
</span>    <span class="n">var</span> <span class="n">methodCall</span> <span class="p">=</span> 
        <span class="k">new</span> <span class="nf">MethodCall</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">_currentArguments</span><span class="p">);</span>

    <span class="n">_methodCalls</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">methodCall</span><span class="p">);</span>

    <span class="c1">// NOTICE: We use clear instead of creating a new list
</span>    <span class="n">_currentArguments</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>Of course I also made a lot of other refactorings without
running my tests (I had only a few integration tests).
This was another mistake of mine. Looks like good
practices help even if you are building
quickly a Proof Of Concept solution.</p>

<p>When I finally ran my tests, they all failed. For some reason
<code class="highlighter-rouge">MethodCall</code> objects did not contain any <code class="highlighter-rouge">TypeArgument</code>s.
Strange, isn’t it…</p>

<p>After a quarter of debugging, I have found that the bug was
introduced by my wrong assumptions about <code class="highlighter-rouge">IReadOnlyList&lt;T&gt;</code>
interface.</p>

<p><code class="highlighter-rouge">IReadOnlyList&lt;T&gt;</code>, <code class="highlighter-rouge">IReadOnlyCollection&lt;T&gt;</code> interfaces and
<code class="highlighter-rouge">ReadOnlyCollection&lt;T&gt;</code> class where introduced
to protect owners of the collections, not the receivers.
For example if a method is declared like this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">void</span> <span class="n">ProcessList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">);</span></code></pre></figure>

<p>We can be sure, that it will not attempt to modify
the list that we are going to pass to it:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span> <span class="p">};</span>
<span class="nf">ProcessList</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">//</span> <span class="n">still</span><span class="p">:</span> <span class="n">list</span> <span class="p">==</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span> <span class="p">}</span></code></pre></figure>

<p>Of course <code class="highlighter-rouge">ProcessList</code> method may be
implemented in an evil way:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">void</span> <span class="n">ProcessList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">list</span> <span class="k">as</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>But we can protect our lists from evil code by using <code class="highlighter-rouge">AsReadOnly</code>
method, that returns a <code class="highlighter-rouge">List&lt;T&gt;</code> instance
wrapped in a <code class="highlighter-rouge">ReadOnlyCollection&lt;T&gt;</code> object
(<a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L251">source code</a>).</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span> <span class="p">};</span>
<span class="nf">ProcessList</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="nf">AsReadOnly</span><span class="p">());</span>
<span class="c1">// Our list can be modified now
// only by using reflection
// to get access to private fields
</span><span class="p">//</span> <span class="n">of</span> <span class="n">ReadOnlyCollection</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">class</span><span class="err">.</span></code></pre></figure>

<p>On the other hand receivers of <code class="highlighter-rouge">IReadOnlyList&lt;T&gt;</code> arguments
are not protected at all. Consider this short program:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">ReadonlyButNotForYou</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span> <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">extraInt</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nf">ProcessList</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">extraInt</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">ProcessList</span><span class="p">(</span><span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">ints</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">extraInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">first</span> <span class="p">=</span> <span class="n">ints</span><span class="p">.</span><span class="nf">First</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="p">=</span> <span class="nf">extraInt</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">firstAgain</span> <span class="p">=</span> <span class="n">ints</span><span class="p">.</span><span class="nf">First</span><span class="p">();</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">firstAgain</span><span class="p">);</span> <span class="c1">// fails
</span><span class="p">}</span></code></pre></figure>

<p>It demonstrates that <code class="highlighter-rouge">IReadOnlyList&lt;T&gt;</code> can change even
during duration of a single method!</p>

<p>So what should we do to void this class of bugs?
Option one is to use old and proven defensive copy
technique:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="nf">MethodCall</span><span class="p">(</span>
    <span class="n">Method</span> <span class="n">calledMethod</span><span class="p">,</span> 
    <span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CalledMethod</span> <span class="p">=</span> <span class="n">calledMethod</span><span class="p">;</span>
    <span class="n">PassedArguments</span> <span class="p">=</span> 
        <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Remember not to use <code class="highlighter-rouge">ReadOnlyCollection&lt;T&gt;</code> class to create
a defensive copy. This class is only a wrapper - it
does not copy the actual data.</p>

<p>The second option is to use truly immutable
data structures, for example from
<a href="https://www.nuget.org/packages/System.Collections.Immutable">System.Collections.Immutable</a>
package:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="nf">MethodCall</span><span class="p">(</span>
    <span class="n">Method</span> <span class="n">calledMethod</span><span class="p">,</span> 
    <span class="n">IImmutableList</span><span class="p">&lt;</span><span class="n">TypedArgument</span><span class="p">&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CalledMethod</span> <span class="p">=</span> <span class="n">calledMethod</span><span class="p">;</span>
    <span class="n">PassedArguments</span> <span class="p">=</span> <span class="n">args</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>These types are truly immutable, they never change their
contents after they are created.</p>

<p>One problem that I have with <code class="highlighter-rouge">System.Collections.Immutable</code>
is that immutable types have often different performance
characteristics than their mutable counterparts.
For example <code class="highlighter-rouge">ImmutableList</code> is implemented using,
guess what, a good old AVL tree
(<a href="https://github.com/dotnet/corefx/blob/master/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableList_1.cs#L28">source code</a>).</p>

<p>On the other hand <code class="highlighter-rouge">ImmutableArray</code> that is backed by a
regular array, seems like a perfect candidate for making
defensive copies. You can read more about <code class="highlighter-rouge">ImmutableArray</code>
in <a href="https://blogs.msdn.microsoft.com/dotnet/2013/06/24/please-welcome-immutablearrayt/">this MSDN article</a>.</p>

<p>It is never wrong to take a look at the collection source code
before using it (all links to GitHub):</p>

<ul>
  <li><a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Collections/ObjectModel/ReadOnlyCollection.cs">ReadOnlyCollection</a></li>
  <li><a href="https://github.com/dotnet/corefx/blob/master/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableList_1.cs">ImmutableList</a></li>
  <li><a href="https://github.com/dotnet/corefx/blob/master/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableArray_1.cs">ImmutableArray</a></li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>

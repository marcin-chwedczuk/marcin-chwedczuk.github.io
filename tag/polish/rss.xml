<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link></link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Cierpienia młodego Wertera czyli algorytm alfa-beta dla gry kółko i krzyżyk</title>
	  <link>//cierpienia-mlodego-wertera</link>
	  <author></author>
	  <pubDate>2020-08-06T02:00:01+02:00</pubDate>
	  <guid>//cierpienia-mlodego-wertera</guid>
	  <description><![CDATA[
	     <p>W tym wpisie przyjrzymy się trudnościom które występują podczas
implementacji algorytmu alfa-beta dla gry kółko i krzyżyk.
Nie będę tutaj omawiał samego algorytmu, gdyż został on już dobrze
opisany w wielu innych miejscach, między innymi na
<a href="http://wazniak.mimuw.edu.pl/index.php?title=Sztuczna_inteligencja/SI_Modu%C5%82_8_-_Gry_dwuosobowe">Ważniaku</a>.
Zamiast tego skoncentrujemy się na technikach debugowania które można
będzie wykorzystać również przy innych grach np. warcabach.</p>

<p>Kod algorytmów alfa-beta i minimax jest powszechnie dostępny
w internecie czy to w postaci 
<a href="https://en.wikipedia.org/wiki/Alpha–beta_pruning#Pseudocode">pseudokodu</a>
czy jako gotowa implementacja na <a href="https://github.com/search?l=Java&amp;q=alpha+beta+tictactoe&amp;type=Repositories">GitHubie</a>.</p>

<p>W trakcie przygotowań do stworzenia tego artykułu, ja również napisałem 
prostą implementację gry w kółko i krzyżyk. 
Kod mojej wersji algorytmu alfa-beta, podobnie jak cała gra, dostępny jest na 
<a href="https://github.com/marcin-chwedczuk/xox/blob/master/src/main/java/pl/marcinchwedczuk/xox/game/AlphaBetaAlgo.java">GitHubie</a>.</p>

<p>W dalszej części artykułu założymy że posiadana przez nas 
implementacja algorytmu alfa-beta jest poprawna, 
a mimo to program nie wykonuje prawidłowych ruchów podczas gry.</p>

<h3 id="heurystyka-czyli-serce-algorytmu">Heurystyka czyli Serce algorytmu</h3>

<p>Najważniejszą częścią algorytmu alfa-beta jest heurystyka czyli
funkcja oceniająca stan gry z punktu widzenia danego gracza.
Ogólna sygnatura heurystyki wygląda następująco:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">double</span> <span class="nf">score</span><span class="o">(</span><span class="n">GameState</span> <span class="n">gameState</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span></code></pre></figure>

<p>Większe wartości zwracane przez funkcję odpowiadają lepszej
sytuacji gracza na planszy i na odwrót im mniejsza wartość
zwrócona tym położenie gracza jest gorsze.</p>

<p>Czasami przekazujemy do heurystyki również
inne pomocnicze informacje,
na przykład ostatni wykonany przez gracza ruch, jeżeli może to
przyspieszyć wykonywanie obliczeń.
Sama funkcja może również zwracać więcej danych niż tylko samą ocenę sytuacji na polu gry.
Przykładowo heurystyka może zwracać informację o zakończeniu gry i jej ewentualnym zwycięscy.
Wiele zależy tutaj od konkretnej gry, w przypadku gry w kółko i krzyżyk
obie te optymalizacje są możliwe.</p>

<p>W przypadku planszy 3x3 prosta heurystyka która zwraca <code class="highlighter-rouge">1</code> gdy gracz
wygrał i <code class="highlighter-rouge">0</code> w przeciwnym wypadku, w połączeniu z algorytmem alfa-beta
tworzy program z którym nie sposób wygrać.</p>

<p>Na koniec uwaga techniczna. Nakreślona powyżej funkcja heurystyki
traktuje w taki sam sposób zarówno gracza MAX
jak i gracza MIN. Dla poprawności działania algorytmu alfa-beta
konieczne jest zanegowanie wyniku zwróconego przez heurystykę dla
gracza MIN:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">currentPlayer</span><span class="o">);</span>
<span class="n">score</span> <span class="o">=</span> <span class="n">maximizingPlayer</span> <span class="o">?</span> <span class="n">score</span> <span class="o">:</span> <span class="o">-</span><span class="n">score</span><span class="o">;</span></code></pre></figure>

<h3 id="plansza-4x4-3-pod-rząd-wygrywają">Plansza 4x4, 3 pod rząd wygrywają</h3>

<p>Uruchomienie powyższego algorytmu na planszy 4x4, gdy pierwszy ruch
należy do użytkownika przynosi jednak opłakane rezultaty.
Program zajmuje po prostu kolejne pola na planszy, a my nie mamy
najmniejszego problemu z wygraną.</p>

<p><img src="assets/images/2020-08-05/game1.png" alt="Dziwne zachowanie algorytmu" />
X - Użytkownik, O - Komputer</p>

<p>Dlaczego tak się dzieje? Okazuje się że przy grze 4x4, 3 pod rząd
istnieje strategia wygrywająca która pozwala pierwszemu graczowi
wygrać w dokładnie 3 ruchach:
<img src="assets/images/2020-08-05/str1.svg" alt="Strategia wygrywająca" /></p>

<p>Z punktu widzenia algorytmu minimax każdy ruch skutkuje przegraną,
dlatego algorytm wybierze pierwszy lub ostatni ruch 
(w zależności od implementacji).
Pozwolę sobie nazwać to zjawisko depresją,
chociaż nie jest to powszechnie przyjęta terminologia.</p>

<p>Istnieje bardzo prosty sposób na wykrycie zjawiska depresji -
wystarczy zamienić kolejność graczy tj. pozwolić komputerowi wykonać
pierwszy ruch. Jeżeli spowoduje to nagłą poprawę sposobu działania algorytmu
należy sprawdzić czy przypadkiem gra nie faworyzuje gracza wykonującego
ruch jako pierwszy.</p>

<p>Istnieje jeszcze jedno proste ulepszenie które możemy wykonać.
Mianowicie jeżeli pozwolimy algorytmowi grać samemu ze sobą to
okaże się że “nie spieszy mu się do wygranej”:
<img src="assets/images/2020-08-05/str2.svg" alt="Ilustracja problemu" />
Ludzie zachowują się inaczej, chcemy wygrać jak najszybciej,
w jak najmniejszej ilości ruchów.
Możemy dodać to zachowanie do naszego algorytmu, modyfikując
funkcję heurystyki tak żeby “karała” gracza za każdy wykonany ruch.
Alternatywnie heurystyka może nagradzać gracza za każde 
pozostawione wolne pole na planszy:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">double</span> <span class="nf">impatientPlayerHeuristics</span><span class="o">(</span><span class="n">GameState</span> <span class="n">gameState</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">currentPlayer</span><span class="o">);</span>
    <span class="n">var</span> <span class="n">freePlaces</span> <span class="o">=</span> <span class="n">gameState</span><span class="o">.</span><span class="na">board</span><span class="o">.</span><span class="na">countFreePlaces</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">score</span> <span class="o">+</span> <span class="n">freePlaces</span><span class="o">*</span><span class="n">Q</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Stałą <code class="highlighter-rouge">Q</code> musimy dobrać w taki sposób żeby wartość 
wyrażenia <code class="highlighter-rouge">freePlaces*Q</code> nigdy
nie przekraczała wartości zwracanej w przypadku wygranej przez 
funkcję <code class="highlighter-rouge">score</code>.
Na przykład jeżeli dla wygranej heurystyka zwraca <code class="highlighter-rouge">1000.0</code> to użycie
<code class="highlighter-rouge">Q = 1.0</code> jest rozsądnym wyborem.</p>

<p>Na koniec zauważmy że plansza 5x5, 3 pod rząd zawiera w sobie
planszę 4x4, 3 pod rząd, dlatego wszystko co powiedzieliśmy tutaj
o zjawisku depresji odnosi się również do niej.</p>

<h3 id="plansza-4x4-4-pod-rząd-wygrywają">Plansza 4x4, 4 pod rząd wygrywają</h3>

<p>W przypadku plansz 4x4 i większych kluczowym problemem staje się wydajność.
Prostym sposobem na poradzenie sobie z tym problemem jest rezygnacja z
analizy całego drzewa gry i skupienie się na pierwszych N ruchach 
wykonywanych przez graczy.
W tym wypadku dobór odpowiedniej heurystyki staje się jeszcze ważniejszy
ponieważ
oceniać musimy nie tylko gry zakończone, ale również takie
które wciąż trwają.
Z drugiej strony nadmierne skomplikowanie heurystyki negatywnie wpływa 
na złożoność obliczeniową i co za tym idzie, na czas oczekiwania na wybór ruchu.</p>

<p>Jako kompromis możemy przyjąć na przykład analizę jedynie siedmiu
posunięć graczy w przyszłość, przy jednoczesnym rozbudowaniu heurystyki
o punktowanie “prawie zwycięstw”. Prawie zwycięstwo to sytuacja na
planszy która w wyniku jednego ruchu czy posunięcia gracza zmienia się
w wygraną. W przypadku planszy 4x4, 4 pod rząd możemy przyjąć
że rząd, kolumna lub przekątna złożona z trzech znaków gracza i wolnego
miejsca jest prawie zwycięstwem np. <code class="highlighter-rouge">X _ X X</code> jest prawie zwycięstwem
dla gracza X.</p>

<p>W przypadku optymalizacji bardziej skomplikowanych gier nie obejdziemy się
bez dodatkowych narzędzi takich jak np. profiler.
Jednym z najlepszych, darmowych profilerów dostępnych na rynku dla platformy JVM
jest <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a>.</p>

<p>Możemy również dużo zyskać unikając nadmiernych alokacji pamięci.
Na przykład zamiast tworzyć nową niemutowalną planszę za każdym razem gdy 
symulujemy ruch gracza, możemy wykorzystać mutowalną strukturę danych
wraz z wycofywaniem ruchów (ang. backtracking):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="n">Move</span> <span class="nl">playerMove:</span> <span class="n">movesToCheck</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Modify board in place</span>
    <span class="n">board</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">playerMove</span><span class="o">.</span><span class="na">position</span><span class="o">,</span> <span class="n">playerMove</span><span class="o">.</span><span class="na">mark</span><span class="o">);</span>

    <span class="c1">// Do recursive minimax call and other stuff</span>

    <span class="c1">// Restore board state</span>
    <span class="n">board</span><span class="o">.</span><span class="na">removeMark</span><span class="o">(</span><span class="n">playerMove</span><span class="o">.</span><span class="na">position</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<h3 id="plansza-5x5-4-lub-5-pod-rząd-wygrywają">Plansza 5x5, 4 lub 5 pod rząd wygrywają</h3>

<p>Na tym poziomie wydajność staje się elementem kluczowym.
Duża wielkość drzewa gry sprawia że strategie
bazujące na prawdopodobieństwie zaczynają wyglądać 
coraz bardziej interesująco.
Na przykład możemy użyć następującego algorytmu bazującego
na <a href="https://pl.wikipedia.org/wiki/Metoda_Monte_Carlo">metodzie Monte Carlo</a>,
do wygenerowania listy ruchów które będziemy oceniać:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Moves</span><span class="o">&gt;</span> <span class="nf">getMovesToCheck</span><span class="o">(</span><span class="n">Board</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Cutoff - use heuristics to evaluate the board</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Set</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// For the first three player moves we analyze every possibility</span>
    <span class="n">var</span> <span class="n">allPossibleMoves</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">getMovesForAllFreeFields</span><span class="o">()</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">allPossibleMoves</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Take K random moves to analyze</span>
    <span class="k">return</span> <span class="n">allPossibleMove</span><span class="o">.</span><span class="na">shuffle</span><span class="o">().</span><span class="na">take</span><span class="o">(</span><span class="n">K</span><span class="o">);</span>

<span class="o">}</span></code></pre></figure>

<p>W przypadku gdy algorytm zwróci pustą listę ruchów do sprawdzenia,
po prostu oceniamy planszę za pomocą heurystyki i zwracamy to jako
wynik (pamiętając o negacji dla gracza MIN) z wywołania funkcji minimax.</p>

<h3 id="jak-to-zdebugować-generalne-strategie-debugowania">Jak to zdebugować? Generalne strategie debugowania</h3>

<ul>
  <li>Testy jednostkowe dla wykorzystywanych przez nas heurystyk to podstawa.
 Pisząc heurystyki dla gry kółko i krzyżyk bardzo łatwo o pomyłkę
 lub błąd w stylu “off by one”. Dodanie testów i upewnienie się
 że pokrycie kodu testami jest odpowiednio wysokie powinno być
 pierwszym działaniem jakie podejmujemy podczas debugowania.</li>
  <li>Nasza aplikacja powinna posiadać funkcję umożliwiającą cofnięcie
 ostatnich ruchów gracza. Znacznie ułatwi to debugowanie za pomocą
 debuggera. W przypadku bardziej skomplikowanych gier typu warcaby
 warto dodać opcję zapisu i odczytu stanu gry z pliku.</li>
  <li>Warto dodać opcję gry komputer vs komputer, jak również wyboru
 kto stawia pierwszy ruch. Pozwala to lepiej ocenić działanie algorytmu.</li>
  <li>Zwracając optymalny ruch algorytm minimax zwraca tak naprawdę
 ścieżkę od korzenia do liścia w drzewie gry (korzeń reprezentuje
 obecną sytuację na planszy, liść przyszłą wygraną lub remis).
 Warto zalogować taką informację wypisując ją na konsole, bądź 
 zapisując do pliku. Pamiętajmy żeby zalogować tylko i wyłącznie
 ścieżkę dla wybranego ruchu. W przeciwnym wypadku możemy utonąć w
 powodzi informacji.</li>
</ul>

<p>Na koniec zdradzę wam sekret debugowania, który pomoże wam rozwiązać
nie jeden problem: “Co dwie głowy to nie jedna!”.
Jeżeli masz problem którego nie potrafisz sam rozwiązać poproś
drugą osobę o pomoc. I niech to nie będzie prośba na forum 
czy StackOverflow ale debugowanie ramie w ramie z drugim człowiekiem.
To naprawdę działa i mówię to mając na karku kilka lat solidnej
praktyki jako programista.</p>

<h3 id="przykładowa-aplikacja">Przykładowa aplikacja</h3>

<p>Kod przykładowej aplikacji można znaleźć na 
<a href="https://github.com/marcin-chwedczuk/xox/">GitHubie</a>.</p>

<p>Aplikację najlepiej otworzyć w IntelliJ, importując ją 
jako projekt Gradle. Do edycji GUI niezbędny jest
<a href="https://gluonhq.com/products/scene-builder/">SceneBuilder</a>.</p>

<p>Jeżeli odkryjecie w aplikacji błąd proszę piszcie na 0xmarcin małpa gmail.com.</p>

<p>Sam kod aplikacji jest czytelny ale nie perfekcyjny. Jest jeszcze wiele
rzeczy które chciałbym poprawić. Jeżeli widzicie miejsce które
można poprawić nie bójcie się stworzyć pull request’a na GitHubie.
Gwiazdki są również mile widziane ;)</p>

	  ]]></description>
	</item>

	<item>
	  <title>Jak zacząć przygodę z elektroniką</title>
	  <link>//jak-zaczac-przygode-z-elektronika</link>
	  <author></author>
	  <pubDate>2019-12-30T01:00:01+01:00</pubDate>
	  <guid>//jak-zaczac-przygode-z-elektronika</guid>
	  <description><![CDATA[
	     <p>Parę miesięcy temu postanowiłem powrócić do mojego
hobby z czasów dzieciństwa: elektroniki.
Powrót, po ponad dziesięciu latach przerwy, okazał
się być trudniejszy niż przypuszczałem,
a droga do pierwszego działającego układu 
pełna frustracji i porażek.</p>

<p>Pomimo tego radość z wykonania najprostszego generatora,
który naprzemiennie migał diodami LED dostarczyła
mi tak dużo radości i frajdy, że przez kilka następnych
wieczorów oddałem się w całości budowie kolejnych układów.</p>

<p>Niestety elektronika jako hobby, nie jest
już w Polsce tak popularna jak 
miało to miejsce w końcówce lat dziewięćdziesiątych.
A szkoda, bo na zachodzie mamy obecnie do czynienia
z prawdziwym boomem na elektronikę.
Dobrze ilustrują to platformy takie jak
<a href="https://www.arduino.cc/">Arduino</a> czy
<a href="https://www.raspberrypi.org/">Raspberry PI</a>.
Nie wspominając już o modzie na retro-computing
(a więc na budowę prostych, często 8-bitowych komputerów wprost
z układów scalonych) uosabianej przez takie postaci
jak <a href="https://www.youtube.com/channel/UCS0N5baNlQWJCUrhCEo8WlA">Ben Eater</a>
i projekty jak <a href="https://monster6502.com/">The MOnSter 6502</a> i
<a href="https://gigatron.io/">Gigatron</a></p>

<p>Niestety nauka nowej umiejętności czy jest nią jazda samochodem,
czy język obcy czy też elektronika, nie jest prosta.
Na początkujących czyha wiele pułapek, które zniechęcają ich 
do dalszej nauki. Dlatego, aby ułatwić początkującym wejście w
świat elektronik, postawiłem podzielić się moimi doświadczeniami
(czytaj wpadkami)
i opisać problemy na jakie się natknąłem.
To jest pierwszy wpis z tej serii, w którym opisuję
pułapki które czekają nas przy zakupie pierwszych płytek
stykowych, przewodów i elementów elektronicznych. Zapraszam!</p>

<h4 id="płytka-stykowa">Płytka stykowa</h4>

<p>Według mnie najlepszym sposobem montażu układów, na początku
przygody z elektroniką są płytki stykowe.
Na rysunku poniżej przedstawiam przykład dwóch takich płytek:
<img src="assets/images/2019-12-30/plytki-stykowe-1.jpg" alt="Przykładowe płytki stykowe" /></p>

<p>Płytka oznaczona numerem 1, to przykład płytki droższej
która mimo to posiada kilka poważnych mankamentów.
Po pierwsze brakuje oznaczenia polaryzacji szyn zasilania,
co rodzi pole do przykrych w konsekwencjach pomyłek
(np. nieprawidłowe doprowadzenie zasilania do układu scalonego).
Po drugie szyny zasilania są “przecięte” w połowie płytki
(patrz strzałki). Tego typu “przecięcie” przydaje 
się gdy budujemy układy w których występują dwa poziomy
zasilania np. 3.3V i 5V. Większość początkujących
elektroników korzysta jednak z pojedynczego napięcia zasilania.
W praktyce okazywało się to tak denerwujące że musiałem dodać specjalne
oznaczenia markerem, żeby już więcej się nie zastanawiać dlaczego
połowa układu nie ma napięcia zasilania.</p>

<p>Płytka oznaczona numerem 2 to tania płytka (7 PLN za sztukę),
produkcji chińskiej. Mimo to producent
nie oszczędzał na pomocnych oznaczeniach. 
Każda z czterech linii zasilania
ma swój kolor, każde gniazdo jest adresowane 
za pomocą kombinacji litery (a-j) i liczby (1-65).
Może, na pierwszy rzut oka nie wydaje się to
przydatne, ale w internecie można znaleźć mnóstwo
projektów pomyślanych specjalnie do wykonania
na płytkach stykowych, które zawierają instrukcje
typu: “umieść rezystor 1k w gniazdach 5f i 5c”.</p>

<p>Niestety niska cena płytki nr. 2 znalazła negatywne
odbicie w jakości styków. Korzystanie z tej płytki
rodziło sporo kłopotów: często miałem problemy żeby
włożyć końcówkę przewodu lub nóżkę elementu do danego
gniazda. Czasami pomagało wetknięcie szpilki, czasami
włożenie przewodów najpierw do sąsiadujących gniazd
a dopiero potem przeniesienie ich do tego właściwego.
Czasami pomagało “wiercenie” w gnieździe nóżką diody LED.
Innymi słowy, spora część radości wynikającej z budowania układu 
ustępowała miejsca frustracji związanej z niskiej jakości płytką.</p>

<p>Przed zakupem płytek polecam przeczytać
recenzje, zarówno na polski forach jak i na zagranicznych (oraz
na Amazonie). Osobiście, nie znalazłem jak do tej pory
płytki stykowej godnej polecenia, jeżeli taką znacie to
proszę dodajcie komentarz z linkiem.</p>

<p>Wróćmy jeszcze na chwilę do zdjęcia płytek. 
Część oznaczona numerem cztery to pojedyncza szyna zasilania,
odseparowana od płytki stykowej typu dwa. 
Jak się okazuje od każdej płytki możemy oderwać jedną lub
obie szyny zasilania. Przy wykonywaniu tej operacji
przydaje się nożyk do kartonu, który pozwoli nam
rozciąć izolacyjny materiał znajdujący się na spodzie płytki.</p>

<p>Każda płytka stykowa posiada wypustki, które pozwalają
zbudować “megapłytkę” z dwóch lub większej liczby 
pojedynczych płytek (z obecnymi lub oderwanymi szynami zasilania).
Niestety płytki wyprodukowane przez różne firmy rzadko
są ze sobą kompatybilne. 
Poniżej zamiejszczam zdjęcie takiej “megapłytki”:
<img src="assets/images/2019-12-30/megaplytka.jpg" alt="Megapłytka" /></p>

<p>Oprócz pełonowymiarowych płytek, na ryku dostępne są też
mniejsze modele:
<img src="assets/images/2019-12-30/mini.jpg" alt="Mini płytki" />
Osobiście nie polecam ich początkującym, gdyż są
po prostu za małe.</p>

<p>Wydawało by się że orientacja płytki nie ma żadnego znaczenia.
Warto jednak przy budowie układów podążać za sprawdzoną regułą,
która mówi że prądy powinny płynąć z góry na dół, a sygnały
od lewej do prawej. W praktyce oznacza to że górna wewnętrzna
szyna zasilająca powinna być podłączona do plusa zasilania,
a dolna wewnętrzna do minusa. Przestrzeganie tej
zasady znacznie ułatwi nam doprowadzanie zasilania do układów scalonych.</p>

<p>A skoro już jesteśmy przy układach scalonych, większość
z nich nie posiada prostopadłych nóżek. Zamiast tego
nóżki rozchodzą się nieco na boki, co uniemożliwia umieszczenie
takiego układu w płytce stykowej. Rozwiązaniem tego
problemu jest przygięcie nóżek scalaka przed włożeniem go
do płytki:
<img src="assets/images/2019-12-30/nogi.jpg" alt="Ach te nóżki" /></p>

<p>Zanim opuścimy temat płytek warto jeszcze dodać, że
na opakowaniu płytki znajduje się jeden z najważniejszych
jej parametrów, mianowicie zakres grubości drutów/końcówek/wyprowadzeń
z jakimi płytka współpracuje. Ten parametr okaże się istotny
gdy będziemy planować zakup przewodów kompatybilnych
z płytką (czytaj nie każdy przewód pasuje do danej płytki).</p>

<h4 id="przewody--połączenia--zworki">Przewody / połączenia / zworki</h4>

<p>Oprócz płytki stykowej, przy budowie układów będziemy
też potrzebowali całej masy przewodów.
Osobiście polecam zakup zestawu przewodów
takich jak <a href="https://www.adafruit.com/product/3174">Adafruit Hook-up Wire</a>,
wraz ze szczypcami do ściągania izolacji takimi
jak <a href="https://www.adafruit.com/product/147">Adafruit Wire Stripper</a>:
<img src="assets/images/2019-12-30/druty.jpg" alt="Przewody" />
Przy zakupie warto zwracać uwagę czy na pewno kupujemy
<em>jednożyłowy</em>, <em>cynowany</em> przewód miedziany, a nie na przykład
wielożyłowy (czysta miedź pokrywa się
nieprzewodzącą warstwą tlenków, cynowany drut zapewni
nam znacznie lepszą jakość połączeń).</p>

<p>Przedstawiony powyżej zestaw przewodów ma grubość
drutu AWG 22 (miara amerykańska), co przelicza się
na polskie 0.6438 milimetra średnicy.
Płytki stykowe z pierwszej sekcji, pracują poprawnie z przewodami
o grubościach 0.3-0.8 milimetra, a więc są kompatybilne z tym
zestawem przewodów.</p>

<p>Ze względu na rosnące ceny miedzi zakup zestawów takich
jak te przedstawione powyżej, może wiązać się ze sporym wydatkiem.
Należy jednak pamiętać że
jeden zestaw przewodów powinien zaspokoić nasze potrzeby na mniej więcej rok,
a szczypce to wydatek jednorazowy.
Obecna cena powyższego zestawu przewodów w sklepie <a href="https://pl.mouser.com/">Mouser</a>
wynosi około 120PLN. Oczywiście zawsze warto sprawdzić czy
nie znajdziemy lepszej oferty w polskich sklepach, na ceneo czy
w końcu na AliExpressie.</p>

<p>Oprócz zestawu przewodów, w sklepach można znaleźć również zestawy zworek
(numer jeden na zdjęciu):
<img src="assets/images/2019-12-30/zwory.jpg" alt="Przewody ciąg dalszy" />
Zestawy takie są, w stosunku do ich ceny, kompletnie bezużyteczne.
Zwory prawie nigdy nie miały potrzebnej długości gdy chciałem
ich użyć. Krótkie zworki kończyły się bardzo szybko, podczas
gdy długich zostawał nadmiar. Jednym słowem: nie polecam.</p>

<p>Polecam za to zakup elastycznych przewodów połączeniowych
(numer dwa i trzy na zdjęciu).
Przewody typu trzy dostępne są w zestawach o dość przystępnej
cenie. Przewody typu dwa występują we wstęgach, które można
rozrywać (nawet na pojedyncze przewody) wedle upodobań.</p>

<p>Do zabawy z płytkami stykowymi i Arduino potrzebne nam będą przede
wszystkim przewody z wtykami męskimi (patrz numer trzy).
Do zabawy z Rasbperry PI,
a także z modułami do Arduino (np. czujniki ruchu) przydadzą się
przewody męsko-żeńskie (patrz numer dwa).</p>

<p>Czasami zdarza się, że przewody będące częścią zestawów mają
końcówki wtyków pokryte ochronną warstwą plastiku którą łatwo
przeoczyć. Jeżeli przewód “źle łączy” należy sprawdzić czy
końcówki nie posiadają takiej ochronnej izolacji i ewentualnie
ją usunąć.</p>

<p>Warto zarezerwować sobie dwa kolory (np. czarny i czerwony)
na oznaczenie przewodów które mają potencjał masy i plusa zasilania.
Warto też pomyśleć o konwencji użycia kolorów, na przykład: przewód biały to
zawsze sygnał zegara.
Poza tym im więcej kolorów mamy do dyspozycji tym lepiej.</p>

<h4 id="pozostałe-narzędzia">Pozostałe narzędzia</h4>

<p>Pozostałe przydatne narzędzia to:</p>

<ol>
  <li>Mały płaski śrubokręt</li>
  <li><em>Szczypce tnące boczne</em>
 do ucinania zbyt długich wyprowadzeń elementów
 (<a href="https://botland.com.pl/pl/szczypce/5851-szczypce-tnace-boczne-yato-yt-2081-115mm-5906083920813.html">model ze zdjęcia</a>)</li>
  <li>Oraz najbardziej przydatna z całej tej
 trójki, bo pozwalająca wygodnie wyjmować i wkładać przewody
 połączeniowe - pęseta
 (<a href="https://sklep.avt.pl/peseta-antystatyczna-122mm-prosta-ostra-esd-10.html">model ze zdjęcia</a>)</li>
</ol>

<p><img src="assets/images/2019-12-30/szczypce.jpg" alt="Przydatne narzędzia" /></p>

<p>Przycinanie wyprowadzeń elementów za pomocą
szczypiec może być odrobinę niebezpieczne.
Nóżki, na przykład dużych diod LED, podczas przycinania mają tendencje to
“wystrzeliwania” w znanym tylko sobie kierunku, dlatego
warto też pomyśleć o zakupie 
<a href="https://botland.com.pl/en/goggles/5626-okulary-yt-7367-5906083973611.html">okularów ochronnych</a>.</p>

<p>Ostatnim, naprawdę niezbędnym narzędziem, w jaki
powinniśmy się zaopatrzyć jest multimetr.
Ja używam następującego modelu, mało znanej chińskiej
marki i jestem z niego całkowicie zadowolony:
<img src="assets/images/2019-12-30/multi.jpg" alt="Multimetr" /></p>

<h4 id="elementy-elektroniczne">Elementy elektroniczne</h4>

<p>Można by pomyśleć, że po całym tym zamieszaniu z płytkami,
narzędziami i multimetrem zakup elementów elektronicznych 
będzie czystą przyjemnością.
Nic bardziej mylnego!
Pierwszym zaskoczeniem jakie mnie spotkało, była niewielka
średnica wyprowadzeń resystorów zakupionych w zestawie
“dla początkujących”. Średnica była tak mała, że czasami
trudno było uzyskać dobre połączenie z płytką stykową.
Ostatecznie skończyłem z <a href="https://botland.com.pl/pl/rezystory-przewlekane/13895-zestaw-rezystorow-cf-tht-14w-velleman-kres-e3-480szt-5410329241803.html">tym zestawem rezystorów</a></p>

<p><img src="assets/images/2019-12-30/vkit.jpg" alt="Zestaw velleman-kit" /></p>

<p>Dobrze ilustruje to powyższe zdjęcie, rezystor oznaczony
numerem jeden pochodzi z taniego zestawu “dla początkujących”.
Posiada długie i cienkie wyprowadzenia słabo współpracujące z
płytkami stykowymi. Rezystor oznaczony numerem dwa pochodzi
z zestawu velleman’a - wyraźnie widać krótsze, ale za to
grubsze i bardziej masywne wyprowadzenia.</p>

<p>Osobiście odradzam również zakup rezystorów o mocy większej
niż 0,25W. Rezystory 1W w porównaniu do 0,25W to prawdziwe olbrzymy.</p>

<p>W przeciwieństwie do rezystorów, zakup diod LED
(polecam “duże” 5mm) czy kondensatorów nie sprawiał
większych problemów, elementy po prostu działały.</p>

<p>Z kolei zakup przycisków (“switchy”) i potencjometrów
sprawił mi trochę kłopotów. Okazuje się że wiele elementów
występuje w dwóch wersjach: do wlutowania i do płytek stykowych.
Popatrzmy na zdjęcie:
<img src="assets/images/2019-12-30/proste.jpg" alt="Elementy do wlutowania i do płytek stykowych" />
Elementy z grupy pierwszej są przeznaczone do wlutowania.
Elementy z grupy drugiej, charakteryzującej się prostymi
wyprowadzeniami, są przewidziane do umieszczenia na płytkach
stykowych. Zawsze należy dokładnie sprawdzić czy na pewno
kupujemy takie elementy, jakich naprawdę potrzebujemy.</p>

<p>Na koniec, żeby nie tracić czasu na mozolne odnajdywanie potrzebnych
elementów, warto zaopatrzyć się w dobry organizer:
<img src="assets/images/2019-12-30/organizer.jpg" alt="Organizer" /></p>

<h4 id="zasilanie">Zasilanie</h4>

<p>Początkowo zasilałem moje układy z baterii 9V.
Wykorzystywałem do tego celu kijankę (numer jeden),
gniazdo które można włożyć w szynę zasilania płytki stykowej (numer trzy) oraz
konwerter (numer dwa):
<img src="assets/images/2019-12-30/zas1.jpg" alt="Zasilanie z bateri 9V" />
Konwerter okazał się konieczny, ponieważ zakupu
gniazda dokonałem “na oko”, nie będąc świadom że
istnieje wiele różnych rozmiarów wtyków zasilania.</p>

<p>Osobiście nie polecam tego sposobu zasilania.
Po pierwsze jesteśmy zdani na napięcie baterii, a wiele
układów wymaga niestandardowych napięć 3,3V lub 5V.
Po drugie zaśmiecamy środowisko zużytymi bateriami,
przy jednoczesnym zubożaniu naszego portfela.</p>

<p>Najlepszym rozwiązaniem, dla osób dysponujących zapasem
gotówki jest kupno zasilacza laboratoryjnego,
nazywanego również zasilaczem warsztatowym.
Dla wszystkich pozostałych, przynajmniej na początku,
dobrym kompromisem jest zakup 
<a href="https://sklep.avt.pl/avt3072.html">zasilacza płytek stykowych</a>:
<img src="assets/images/2019-12-30/zas2.jpg" alt="Zasilacz do płytek stykowych" />
Należy pamiętać że sam zasilacz to tylko prosta płytka PCB
(ang. printed circuit board, pl. płytka drukowana), do
pracy potrzebny jej jest <a href="https://sklep.avt.pl/zasilacz-impulsowy-12v-1-5a-18w-dc2-5-5-5.html">zasilacz impulsowy</a> - oznaczony na zdjęciu numerem dwa.</p>

<p>Przedstawiony powyżej zasilacz, który służy mi już kilka miesięcy,
niestety nie jest pozbawiony wad.
Najpoważniejsza z nich jest taka, że nie jesteśmy ostrzegani
o zwarciu przewodów zasilania.
Istnieją na rynku zasilacze które np. piszczą
gdy dojdzie do zwarcia.
W powyższym zasilaczu, zwarcie można rozpoznać jedynie po
silnie rozgrzanym radiatorze.
Dlatego, pomimo że podałem linki do sklepu, zachęcam was do
poszukania lepszego modelu lub jeżeli już taki
posiadacie do pozostawienia komentarza z linkiem.</p>

<h4 id="sklepy">Sklepy</h4>

<p>Na koniec lista sklepów z których jestem
względnie zadowolony:</p>

<ul>
  <li>
    <p><a href="https://sklep.avt.pl/">Sklep AVT</a> związany od wielu lat
 z czasopismem “Elektronika dla wszystkich”</p>
  </li>
  <li>
    <p><a href="https://botland.com.pl/pl/">Botland</a></p>
  </li>
</ul>

<p>Z zagranicznych warto wspomnieć:</p>

<ul>
  <li><a href="https://pl.mouser.com/">Mouser</a> - ten sklep
 śmiało można nazwać profesjonalnym.
 Można łatwo i szybko (czas dostawy nie przekracza tygodnia)
 dostać układy praktycznie niedostępne na polskim rynku.
 Ale uwaga, ceny produktów podane są na modłę amerykańską, 
 a więc nie zawierają
 23% podatku VAT. Najeży o tym pamiętać porównując oferty.</li>
</ul>

<p>Oczywiście zawsze warto korzystać z porównywarek cen
i sprawdzać opinie sklepów na forach internetowych.
Bardziej odważni i cierpliwi mogą spróbować szczęścia na AliExpressie.</p>

<p>Na zakończenie, “starożytne” i niestety niedziałające, układy
scalone polskiej produkcji (sic!), które otrzymałem od jednego
z polskich sklepów:
<img src="assets/images/2019-12-30/cemi.jpg" alt="Polskie scalaki" /></p>


	  ]]></description>
	</item>


</channel>
</rss>

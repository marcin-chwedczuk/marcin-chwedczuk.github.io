<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Iterative solution to Towers of Hanoi problem</title>
	  <link>//iterative-solution-to-towers-of-hanoi-problem</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-11-26T01:00:00+01:00</pubDate>
	  <guid>//iterative-solution-to-towers-of-hanoi-problem</guid>
	  <description><![CDATA[
	     <p>Towers of Hanoi is a simple programming riddle often used 
in programming courses to
introduce recursion.
Not many people are aware that Towers of Hanoi has
also a beautiful iterative solution.</p>

<p>Here I assume that you already know this problem if not 
<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">please check Wikipedia Tower of Hanoi page</a>.</p>

<p>The key to discover how iterative algorithm work is to actually observe how
disks are moved by recursive algorithm.
To make move patterns more visible we will put rots 
on a circle, we will be moving discs from rot marked by FROM label to
rot marked by TO label using third rot only to temporary store discs.
We will use animation below to
observe how disks move. We will start by observing how the smallest disk (red)
is moving when total number of disk is even (so try it for 2, 4, 6 and 8 disks).
After you find the pattern how smallest disk moves try to find out how other
disk are moving - this should not be difficult.
Then repeat observation for odd number of disks (1,3,5 and 7).<br />
TIP: Patterns may be more easily revealed when you use x3 or x5 animation speed</p>

<iframe src="assets/apps/hanoi/index.html" width="850" height="810" style="border:none; margin-left:-48px; margin-top:-20px;"></iframe>

<p style="color: gray;">
Scroll below when you have enough of pattern finding or if want to check if
your patterns are correct.
</p>

<p>For any number of disks we start by moving the smallest disk.
For even total number of disks we move the smallest disk clockwise for
odd total number of disks we move the smallest disk counterclockwise.
After every move that involves the smallest disk we perform one
valid move 
(we move smaller disk on top of bigger, or we move disk to empty rod)
that doesn’t involve the
smallest disk. We stop when all disks were moved to TO rod.</p>

<p>Formal proof that above algorithm works can be found in 
<a href="http://www.cs.nott.ac.uk/~psarb2/MPC/Hanoi.ps.gz">The Associativity of Equivalence and the Towers of Hanoi Problem</a>.</p>

<p>Iterative algorithm implemented in JavaScript:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">generateHanoiMovesIterative</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">numberOfDisks</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// direction of rotation of the smallest disk</span>
  <span class="kd">var</span> <span class="nx">dir</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numberOfDisks</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">rods</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]];</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">rodMin</span><span class="p">;</span>

  <span class="c1">// push disks on our virtual rod's</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numberOfDisks</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rods</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">numberOfDisks</span> <span class="o">-</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// rodMin will point to rod with smallest disk</span>
  <span class="nx">rodMin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// we need (2^numberOfDisks - 1) moves</span>
  <span class="kd">var</span> <span class="nx">numberOfMoves</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">numberOfDisks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// To avoid using % operator we precompute next and prev tables</span>
  <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">prev</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>

  <span class="kd">var</span> <span class="nx">moves</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">moveSmallest</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numberOfMoves</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">moveSmallest</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">oldRodMin</span> <span class="o">=</span> <span class="nx">rodMin</span><span class="p">;</span>
        <span class="c1">// in JS -1 % 3 === -1, we add 3 to get positive result</span>
        <span class="nx">rodMin</span> <span class="o">=</span> <span class="p">(</span><span class="nx">oldRodMin</span> <span class="o">+</span> <span class="nx">dir</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>

        <span class="nx">moveDisk</span><span class="p">(</span><span class="nx">oldRodMin</span><span class="p">,</span> <span class="nx">rodMin</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">topDiskSize</span><span class="p">(</span><span class="nx">next</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nx">topDiskSize</span><span class="p">(</span><span class="nx">prev</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">]))</span> <span class="p">{</span>
          <span class="nx">moveDisk</span><span class="p">(</span><span class="nx">prev</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">],</span> <span class="nx">next</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">moveDisk</span><span class="p">(</span><span class="nx">next</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">],</span> <span class="nx">prev</span><span class="p">[</span><span class="nx">rodMin</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">moveSmallest</span> <span class="o">=</span> <span class="o">!</span><span class="nx">moveSmallest</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">moves</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">topDiskSize</span><span class="p">(</span><span class="nx">rodIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">rods</span><span class="p">[</span><span class="nx">rodIndex</span><span class="p">].</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">rod</span> <span class="o">=</span> <span class="nx">rods</span><span class="p">[</span><span class="nx">rodIndex</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">rod</span><span class="p">[</span><span class="nx">rod</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">moveDisk</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1-FROM ROD, 2-USING ROD, 3-TO ROD</span>
    <span class="nx">moves</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">from</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">to</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">' -&gt; '</span><span class="p">));</span>
    <span class="nx">rods</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">rods</span><span class="p">[</span><span class="nx">from</span><span class="p">].</span><span class="nx">pop</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>References:</p>

<ul>
  <li>[1] <a href="http://www.cs.nott.ac.uk/~psarb2/MPC/Hanoi.ps.gz">The Associativity of Equivalence and the Towers of Hanoi Problem</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Iterative algorithm for drawing Hilbert curve</title>
	  <link>//iterative-algorithm-for-drawing-hilbert-curve</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-08-06T02:00:00+02:00</pubDate>
	  <guid>//iterative-algorithm-for-drawing-hilbert-curve</guid>
	  <description><![CDATA[
	     <p>In this post I will describe how to draw Hilbert curve iteratively.
To avoid recursion we will use <code class="highlighter-rouge">hindex2xy</code> algorithm that
translates Hilbert curve node index to 
Cartesian coordinates.</p>

<p>To index Hilbert curve nodes we assume that
curve starts in the left bottom corner and ends in the right bottom corner.
Indexes start at zero. Here is example numbering of <code class="highlighter-rouge">N=8</code> Hilbert curve:
<img src="assets/images/2016-08-13/hnumbering.svg" alt="N=8 Hilbert curve node indexing" />
We expect that <code class="highlighter-rouge">hindex2xy(17) = (x:1, y:4)</code> and <code class="highlighter-rouge">hindex2xy(40) = (x:6, y:6)</code>.</p>

<p><code class="highlighter-rouge">hindex2xy</code> algorithm uses bottom-up approach to compute node coordinates without
using recursion. When we look at the binary representation of the node indexes we may
notice that the last two bits represent node position inside <code class="highlighter-rouge">N=2</code> Hilbert curve.
Next two bits represent where that <code class="highlighter-rouge">N=2</code> Hilbert curve is located inside bigger
<code class="highlighter-rouge">N=4</code> curve etc.</p>

<p>Example will show us
how it works for <code class="highlighter-rouge">N=4</code> Hilbert curve and <code class="highlighter-rouge">index=7</code>:
<img src="assets/images/2016-08-13/hbottomup.svg" alt="Computing coordinates bottom-up" />
Let’s start by writing index value as binary number: 7 <sub>dec</sub> is equal 0111<sub>bin</sub>.
The last two bits of 0111<sub>bin</sub> are
11<sub>bin</sub>, they
corresponds to the bottom right node of the <code class="highlighter-rouge">N=2</code> Hilbert curve (marked green on the image).
This node has Cartesian coordinates <code class="highlighter-rouge">(x:1, y:0)</code>.
Now let’s move to the next two bits:
01<sub>bin</sub>, these bits corresponds to the left upper corner of <code class="highlighter-rouge">N=4</code> Hilbert curve
(marked yellow on the image).
To transform <code class="highlighter-rouge">N=2</code> into <code class="highlighter-rouge">N=4</code> coords we must notice that 
left upper corner of <code class="highlighter-rouge">N=4</code> curve is just translated copy of <code class="highlighter-rouge">N=2</code> curve.
So to get <code class="highlighter-rouge">N=4</code> coords we must apply translation <code class="highlighter-rouge">(x:0, y:2)</code> to <code class="highlighter-rouge">N=2</code> coords:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">(x:1, y:2) = (x:1, y:0) + (x:0, y:2)</code></pre></figure>

<p>We end with <code class="highlighter-rouge">(x:1, y:2)</code> point that correctly 
represent node with index 7 inside <code class="highlighter-rouge">N=4</code> curve.</p>

<p>Let’s assume that we want to find out coords of node in <code class="highlighter-rouge">N=2K</code> Hilbert curve,
given that we have coords <code class="highlighter-rouge">(x,y)</code> of node in <code class="highlighter-rouge">N=K</code> curve.
In general when computing coords bottom-up we have four cases:
<img src="assets/images/2016-08-13/hblocks.svg" alt="Computing coordinates bottom-up" />
Cases B and C are really simple since <code class="highlighter-rouge">N=2K</code> curve contains copies
of <code class="highlighter-rouge">N=K</code> curve in B and C squares. In case B we should
transform coords using equation:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">coords_2K = coords_K + (x:0, y:K)</code></pre></figure>

<p>And in case C we should use equation:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">coords_2K = coords_K + (x:K, y:K)</code></pre></figure>

<p>In cases A and D we must be careful when transforming coords because we must
preserve order of traversal of <code class="highlighter-rouge">N=K</code> curve inside <code class="highlighter-rouge">N=2K</code> curve.
I marked each curve start and end with red and blue dots so we can
see better how we should perform transformation.</p>

<p>In case A first node of <code class="highlighter-rouge">N=K</code> curve should coincide with first node of <code class="highlighter-rouge">N=2K</code> curve
and <code class="highlighter-rouge">N=K</code> curve should end next to the start of “case B” curve.
We can achieve this by flipping coords around diagonal:
<img src="assets/images/2016-08-13/casea.svg" alt="Case A transformation" /></p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">coords_2K.x = coords_K.y
coords_2K.y = coords_K.x</code></pre></figure>

<p>Case D is similar to case A, we must flip coords but around second diagonal:
<img src="assets/images/2016-08-13/cased.svg" alt="Case D transformation" />
In addition to that we must translate node coords to the right:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">coords_2K.x = (K-1) - coords_K.y
coords_2K.y = (K-1) - coords_K.x

coords_2K.x = coords_2K.x + K</code></pre></figure>

<p>Finally let’s see full algorithm code in JavaScript:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">last2bits</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span> <span class="p">}</span>

<span class="kd">function</span> <span class="nx">hindex2xy</span><span class="p">(</span><span class="nx">hindex</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. compute position of node in N=2 curve</span>
    <span class="kd">var</span> <span class="nx">positions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="cm">/* 0: */</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="cm">/* 1: */</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="cm">/* 2: */</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="cm">/* 3: */</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">];</span>

    <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">positions</span><span class="p">[</span><span class="nx">last2bits</span><span class="p">(</span><span class="nx">hindex</span><span class="p">)];</span>
    <span class="nx">hindex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hindex</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

    <span class="c1">// 2. iteratively compute coords</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">n</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="nx">last2bits</span><span class="p">(</span><span class="nx">hindex</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="err">:</span> <span class="cm">/* case A: left-bottom */</span>
            <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">1</span><span class="err">:</span> <span class="cm">/* case B: left-upper */</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
            <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">n2</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">2</span><span class="err">:</span> <span class="cm">/* case C: right-upper */</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">n2</span><span class="p">;</span>
            <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">n2</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">3</span><span class="err">:</span> <span class="cm">/* case D: right-bottom */</span>
            <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
            <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">x</span><span class="p">;</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">n2</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nx">hindex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hindex</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>Having this algorithm we may draw Hilbert curve as follows:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">prev</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="nx">curr</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="o">*</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">hindex2xy</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>

    <span class="nx">dot</span><span class="p">(</span><span class="nx">curr</span><span class="p">);</span>
    <span class="nx">line</span><span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">);</span>

    <span class="nx">prev</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And here are results:
<img src="assets/images/2016-08-13/hilb.png" alt="Hilbert curve" /></p>

<h5 id="github">Github</h5>
<p>Source code: <a href="https://github.com/marcin-chwedczuk/hilbert_curve">hilbert_curve</a></p>


	  ]]></description>
	</item>


</channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Iterative solution to Towers of Hanoi problem</title>
	  <link>//iterative-solution-to-towers-of-hanoi-problem</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-11-26T01:00:00+01:00</pubDate>
	  <guid>//iterative-solution-to-towers-of-hanoi-problem</guid>
	  <description><![CDATA[
	     Towers of Hanoi is a simple programming riddle often used 
in programming courses to
introduce recursion.
Not many people are aware that Towers of Hanoi has
also a beautiful iterative solution.

Here I assume that you already know this problem if not 
[please check Wikipedia Tower of Hanoi page](https://en.wikipedia.org/wiki/Tower_of_Hanoi).

The key to discover how iterative algorithm work is to actually observe how
disks are moved by recursive algorithm.
To make move patterns more visible we will put rots 
on a circle, we will be moving discs from rot marked by FROM label to
rot marked by TO label using third rot only to temporary store discs.
We will use animation below to
observe how disks move. We will start by observing how the smallest disk (red)
is moving when total number of disk is even (so try it for 2, 4, 6 and 8 disks).
After you find the pattern how smallest disk moves try to find out how other
disk are moving - this should not be difficult.
Then repeat observation for odd number of disks (1,3,5 and 7).  
TIP: Patterns may be more easily revealed when you use x3 or x5 animation speed

<iframe src="assets/apps/hanoi/index.html" 
	width="850" height="810"
	style="border:none; margin-left:-48px; margin-top:-20px;"></iframe>


<p style="color: gray;">
Scroll below when you have enough of pattern finding or if want to check if
your patterns are correct.
</p>

For any number of disks we start by moving the smallest disk.
For even total number of disks we move the smallest disk clockwise for
odd total number of disks we move the smallest disk counterclockwise.
After every move that involves the smallest disk we perform one
valid move 
(we move smaller disk on top of bigger, or we move disk to empty rod)
that doesn't involve the
smallest disk. We stop when all disks were moved to TO rod.

Formal proof that above algorithm works can be found in 
[The Associativity of Equivalence and the Towers of Hanoi Problem](http://www.cs.nott.ac.uk/~psarb2/MPC/Hanoi.ps.gz).

Iterative algorithm implemented in JavaScript:
{% highlight javascript %}
var generateHanoiMovesIterative = function(numberOfDisks) {
  // direction of rotation of the smallest disk
  var dir = (numberOfDisks % 2 === 0) ? 1 : -1;

  var rods = [[], [], []];
  var i, rodMin;

  // push disks on our virtual rod's
  for (i = 0; i < numberOfDisks; i += 1) {
    rods[0].push(numberOfDisks - i);
  }

  // rodMin will point to rod with smallest disk
  rodMin = 0;

  // we need (2^numberOfDisks - 1) moves
  var numberOfMoves = (1 << numberOfDisks) - 1;

  // To avoid using % operator we precompute next and prev tables
  var next = [1, 2, 0];
  var prev = [2, 0, 1];

  var moves = [];
  var moveSmallest = true;

  for (i = 0; i < numberOfMoves; i++) {
      if (moveSmallest) {
        var oldRodMin = rodMin;
        // in JS -1 % 3 === -1, we add 3 to get positive result
        rodMin = (oldRodMin + dir + 3) % 3;

        moveDisk(oldRodMin, rodMin);
      }
      else {
        if (topDiskSize(next[rodMin]) > topDiskSize(prev[rodMin])) {
          moveDisk(prev[rodMin], next[rodMin]);
        }
        else {
          moveDisk(next[rodMin], prev[rodMin]);
        }
    }
    moveSmallest = !moveSmallest;
  }

  return moves;

  function topDiskSize(rodIndex) {
    if (rods[rodIndex].length === 0) return Number.MAX_VALUE;

    var rod = rods[rodIndex]
    return rod[rod.length-1];
  }

  function moveDisk(from, to) {
    // 1-FROM ROD, 2-USING ROD, 3-TO ROD
    moves.push([from+1, to+1].join(' -> '));
    rods[to].push(rods[from].pop());
  }
};
{% endhighlight %}

References:

* [1] [The Associativity of Equivalence and the Towers of Hanoi Problem](http://www.cs.nott.ac.uk/~psarb2/MPC/Hanoi.ps.gz)


	  ]]></description>
	</item>

	<item>
	  <title>Iterative algorithm for drawing Hilbert curve</title>
	  <link>//iterative-algorithm-for-drawing-hilbert-curve</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-08-06T02:00:00+02:00</pubDate>
	  <guid>//iterative-algorithm-for-drawing-hilbert-curve</guid>
	  <description><![CDATA[
	     In this post I will describe how to draw Hilbert curve iteratively.
To avoid recursion we will use `hindex2xy` algorithm that
translates Hilbert curve node index to 
Cartesian coordinates.

To index Hilbert curve nodes we assume that
curve starts in the left bottom corner and ends in the right bottom corner.
Indexes start at zero. Here is example numbering of `N=8` Hilbert curve:
![N=8 Hilbert curve node indexing](assets/images/2016-08-13/hnumbering.svg)
We expect that `hindex2xy(17) = (x:1, y:4)` and `hindex2xy(40) = (x:6, y:6)`.

`hindex2xy` algorithm uses bottom-up approach to compute node coordinates without
using recursion. When we look at the binary representation of the node indexes we may
notice that the last two bits represent node position inside `N=2` Hilbert curve.
Next two bits represent where that `N=2` Hilbert curve is located inside bigger
`N=4` curve etc.

Example will show us
how it works for `N=4` Hilbert curve and `index=7`:
![Computing coordinates bottom-up](assets/images/2016-08-13/hbottomup.svg)
Let's start by writing index value as binary number: 7 <sub>dec</sub> is equal 0111<sub>bin</sub>.
The last two bits of 0111<sub>bin</sub> are
11<sub>bin</sub>, they
corresponds to the bottom right node of the `N=2` Hilbert curve (marked green on the image).
This node has Cartesian coordinates `(x:1, y:0)`.
Now let's move to the next two bits:
01<sub>bin</sub>, these bits corresponds to the left upper corner of `N=4` Hilbert curve
(marked yellow on the image).
To transform `N=2` into `N=4` coords we must notice that 
left upper corner of `N=4` curve is just translated copy of `N=2` curve.
So to get `N=4` coords we must apply translation `(x:0, y:2)` to `N=2` coords:
{% highlight no-highlight %}
(x:1, y:2) = (x:1, y:0) + (x:0, y:2)
{% endhighlight %}
We end with `(x:1, y:2)` point that correctly 
represent node with index 7 inside `N=4` curve.

Let's assume that we want to find out coords of node in `N=2K` Hilbert curve,
given that we have coords `(x,y)` of node in `N=K` curve.
In general when computing coords bottom-up we have four cases:
![Computing coordinates bottom-up](assets/images/2016-08-13/hblocks.svg)
Cases B and C are really simple since `N=2K` curve contains copies
of `N=K` curve in B and C squares. In case B we should
transform coords using equation:
{% highlight no-highlight %}
coords_2K = coords_K + (x:0, y:K)
{% endhighlight %}
And in case C we should use equation:
{% highlight no-highlight %}
coords_2K = coords_K + (x:K, y:K)
{% endhighlight %}

In cases A and D we must be careful when transforming coords because we must
preserve order of traversal of `N=K` curve inside `N=2K` curve.
I marked each curve start and end with red and blue dots so we can
see better how we should perform transformation.

In case A first node of `N=K` curve should coincide with first node of `N=2K` curve
and `N=K` curve should end next to the start of "case B" curve.
We can achieve this by flipping coords around diagonal:
![Case A transformation](assets/images/2016-08-13/casea.svg)
{% highlight no-highlight %}
coords_2K.x = coords_K.y
coords_2K.y = coords_K.x
{% endhighlight %}

Case D is similar to case A, we must flip coords but around second diagonal:
![Case D transformation](assets/images/2016-08-13/cased.svg)
In addition to that we must translate node coords to the right:
{% highlight no-highlight %}
coords_2K.x = (K-1) - coords_K.y
coords_2K.y = (K-1) - coords_K.x

coords_2K.x = coords_2K.x + K
{% endhighlight %}

Finally let's see full algorithm code in JavaScript:
{% highlight js %}
function last2bits(x) { return (x & 3); }

function hindex2xy(hindex, N) {
    // 1. compute position of node in N=2 curve
    var positions = [
    /* 0: */ [0, 0],
    /* 1: */ [0, 1],
    /* 2: */ [1, 1],
    /* 3: */ [1, 0]
    ];

    var tmp = positions[last2bits(hindex)];
    hindex = (hindex >>> 2);

    // 2. iteratively compute coords
    var x = tmp[0];
    var y = tmp[1];
    
    for (var n = 4; n <= N; n *= 2) {
        var n2 = n / 2;

        switch (last2bits(hindex)) {
        case 0: /* case A: left-bottom */
            tmp = x; x = y; y = tmp;
            break;

        case 1: /* case B: left-upper */
            x = x;
            y = y + n2;
            break;

        case 2: /* case C: right-upper */
            x = x + n2;
            y = y + n2;
            break;

        case 3: /* case D: right-bottom */
            tmp = y;
            y = (n2-1) - x;
            x = (n2-1) - tmp;
            x = x + n2;
            break;
        }
        
        hindex = (hindex >>> 2);
    }
    return [x, y];
}
{% endhighlight %}

Having this algorithm we may draw Hilbert curve as follows:
{% highlight js %}
var N = 32;

var prev = [0, 0],
    curr;

for (var i = 0; i < N*N; i += 1) {
    curr = hindex2xy(i, N);

    dot(curr);
    line(prev, curr);

    prev = curr;
}
{% endhighlight %}

And here are results:
![Hilbert curve](assets/images/2016-08-13/hilb.png)

##### Github
Source code: [hilbert_curve](https://github.com/marcin-chwedczuk/hilbert_curve)


	  ]]></description>
	</item>


</channel>
</rss>

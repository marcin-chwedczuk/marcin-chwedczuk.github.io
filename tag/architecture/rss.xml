<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>NSubstitute and the search for perfect error messages</title>
	  <link>//nsubstitute-and-the-search-for-perfect-error-messages</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-12-15T01:00:00+01:00</pubDate>
	  <guid>//nsubstitute-and-the-search-for-perfect-error-messages</guid>
	  <description><![CDATA[
	     <p>Those of us that practice TDD daily already know how important good
error messages in tests are. After all writing a failing test that
<em>clearly</em> states what functionality the program 
is missing is the first step in TDD cycle.
The rest of us that either can’t or simply don’t want to practice TDD
must put extra effort to ensure that tests always fail
with meaningful error messages.
Unfortunately, according to what I have learned from my personal experience, 
the most devs either don’t have
enough time or simply don’t bother to check if their tests fail with
something meaningful. For average Joe developer writing tests and
making them green is already a lot of work. 
Things like good test names and proper error messages are often forgotten.</p>

<p>But the developers are not the only one here to blame. 
Too often tools and libraries that supposedly should make unit testing
simpler and easier, generate horrible and often cryptic error messages.</p>

<p>In this post we will take a close look at 
<a href="http://nsubstitute.github.io/">NSubstitute</a>,
a modern and popular mocking libary for .NET and see 
how we can improve messages generated by its argument matchers.</p>

<p>Let’s start by looking at a simple test. 
It demonstrates how NSubstitute is often used to assert that 
a method was called with an argument in a certain state:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">PlainArgument</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">EmailAddress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">PlainArgument</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">emailAddress</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Id</span> <span class="p">=</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">FirstName</span> <span class="p">=</span> <span class="n">firstName</span><span class="p">;</span>
        <span class="n">LastName</span> <span class="p">=</span> <span class="n">lastName</span><span class="p">;</span>
        <span class="n">EmailAddress</span> <span class="p">=</span> <span class="n">emailAddress</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IFooService</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="kt">object</span> <span class="n">argument</span><span class="p">);</span>
<span class="p">}</span>

<span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Checking_argument_using_Arg_Is</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Act
</span>    <span class="n">_component</span><span class="p">.</span><span class="nf">DoStuff</span><span class="p">();</span>

    <span class="c1">// Assert
</span>    <span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;(</span>
            <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="m">9</span> <span class="p">&amp;&amp;</span>
                 <span class="n">e</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">==</span> <span class="s">"jan"</span> <span class="p">&amp;&amp;</span>
                 <span class="n">e</span><span class="p">.</span><span class="n">LastName</span> <span class="p">==</span> <span class="s">"kowalski"</span> <span class="p">&amp;&amp;</span>
                 <span class="n">e</span><span class="p">.</span><span class="n">EmailAddress</span> <span class="p">==</span> <span class="s">"jan.kowalski@gmail.com"</span>
                 <span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>When the argument passed to the checked method
was in an unexpected state (e.g. first name was not “jan” but “john”),
we get an error message similar to (formatting added):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">Expected to receive a call matching:
    DoStuff(e =&gt; ((((e.Id == 9) AndAlso 
        (e.FirstName == "jan")) AndAlso 
        (e.LastName == "kowalski")) AndAlso 
        (e.EmailAddress == "jan.kowalski@gmail.com")))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*PlainArgument*)</code></pre></figure>

<p>This error message is terrible.
It contains a lot of informations that are easily obtainable by looking at the
test method’s source code. Yet it does not contain
the most important piece of information that we need: which properties 
have unexpected values and what these values are.</p>

<p>We can slightly improve this error message by overloading <code class="highlighter-rouge">ToString</code> method
on <code class="highlighter-rouge">PlainArgument</code> class. 
Let’s call this new class <code class="highlighter-rouge">StringableArgument</code>:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">StringableArgument</span> <span class="p">{</span>
    <span class="c1">// the same code as in PlainArgument
</span>    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="err">$</span><span class="s">"{nameof(StringableArgument)}(id: {Id}, firstName: \"{FirstName}\", "</span> <span class="p">+</span>
            <span class="err">$</span><span class="s">"lastName: \"{LastName}\", emailAddres: \"{EmailAddress}\")"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// in a test method:
</span><span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">StringableArgument</span><span class="p">&gt;(</span>
        <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="m">9</span> <span class="p">&amp;&amp;</span>
             <span class="n">e</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">==</span> <span class="s">"jan"</span> <span class="p">&amp;&amp;</span>
             <span class="n">e</span><span class="p">.</span><span class="n">LastName</span> <span class="p">==</span> <span class="s">"kowalski"</span> <span class="p">&amp;&amp;</span>
             <span class="n">e</span><span class="p">.</span><span class="n">EmailAddress</span> <span class="p">==</span> <span class="s">"jan.kowalski@gmail.com"</span>
             <span class="p">));</span></code></pre></figure>

<p>Now the error message looks similar to (formatting added):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">Expected to receive a call matching:
    DoStuff(e =&gt; ((((e.Id == 9) AndAlso 
        (e.FirstName == "jan")) AndAlso 
        (e.LastName == "kowalski")) AndAlso 
        (e.EmailAddress == "jan.kowalski@gmail.com")))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*StringableArgument(
        id: 7, firstName: "john", 
        lastName: "doe", 
        emailAddres: "john.doe@gmail.com")*)</code></pre></figure>

<p>This is better than before. 
Now we can see both expected and actual values of the 
matched argument’s properties.</p>

<p>One drawback of this approach is that 
the quality of the error message depends on the quality of
<code class="highlighter-rouge">ToString</code> implementation. 
If we are using AOP solution like
<a href="https://github.com/Fody/Fody">Fody</a> to generate <code class="highlighter-rouge">ToString</code> implementations
for most of our classes, then this solution may be good enough. 
On the other hand if we are generating and updating our <code class="highlighter-rouge">ToString</code> methods
manually (even if this means pressing a shortcut in our IDE)
then I would prefer to look for a better solution that is totally automatic.</p>

<p>There is also another problem that we were ignoring so far.
Consider what will happen if we add a new field to our <code class="highlighter-rouge">StringableArgument</code>
class. 
Because we are using property access syntax inside of a lambda expression,
our existing matchers will not only compile without any problems when
we add a new field, they will also pass!
In order to ensure that our matchers and tests remain valid,
we must go through all argument matchers 
for <code class="highlighter-rouge">StringableArgument</code> class and make sure that they use 
the newly added field.</p>

<p>The above problem may be solved by moving equality checking
to the <code class="highlighter-rouge">StringableArgument</code> class itself. 
Let’s call this new class <code class="highlighter-rouge">EquotableArgument</code>:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">EquotableArgument</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">EquotableArgument</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">EmailAddress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">EquotableArgument</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">emailAddress</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Id</span> <span class="p">=</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">FirstName</span> <span class="p">=</span> <span class="n">firstName</span><span class="p">;</span>
        <span class="n">LastName</span> <span class="p">=</span> <span class="n">lastName</span><span class="p">;</span>
        <span class="n">EmailAddress</span> <span class="p">=</span> <span class="n">emailAddress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="err">$</span><span class="s">"{nameof(StringableArgument)}(id: {Id}, firstName: \"{FirstName}\", "</span> <span class="p">+</span>
            <span class="err">$</span><span class="s">"lastName: \"{LastName}\", emailAddres: \"{EmailAddress}\")"</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">EquotableArgument</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nf">ToTuple</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">==</span> <span class="nf">ToTuple</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">EquotableArgument</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="nf">ToTuple</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">GetHashCode</span><span class="p">();</span>

    <span class="k">private</span> <span class="k">static</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nf">ToTuple</span><span class="p">(</span><span class="n">EquotableArgument</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">LastName</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">EmailAddress</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// in a test method:
</span><span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
    <span class="c1">// NOTICE: We no longer use a lambda expression.
</span>    <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="k">new</span> <span class="nf">EquotableArgument</span><span class="p">(</span>
        <span class="n">id</span><span class="p">:</span> <span class="m">9</span><span class="p">,</span> 
        <span class="n">firstName</span><span class="p">:</span> <span class="s">"jan"</span><span class="p">,</span> 
        <span class="n">lastName</span><span class="p">:</span> <span class="s">"kowalski"</span><span class="p">,</span>
        <span class="n">emailAddress</span><span class="p">:</span> <span class="s">"jan.kowalski@gmail.com"</span><span class="p">)));</span></code></pre></figure>

<p>With this solution it is impossible to forget to update our matchers
when we add a new field.
We also get a slightly better error message (formatting added):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">Expected to receive a call matching:
    DoStuff(StringableArgument(
        id: 9, firstName: "jan", 
        lastName: "kowalski", 
        emailAddres: "jan.kowalski@gmail.com"))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments 
indicated with '*' characters):
    DoStuff(*StringableArgument(
        id: 7, firstName: "john", 
        lastName: "doe", 
        emailAddres: "john.doe@gmail.com")*)</code></pre></figure>

<p>So far so good. But what if our argument has ten or more properties.
With complex arguments looking for a one property with
unexpected value may quickly change into “Where’s Wally?” game.
The only way to further improve error messages is to stop relaying on
NSubstitute/hand-carfted <code class="highlighter-rouge">Equals</code> implementation 
and instead to use specialized assertion library like
<a href="https://fluentassertions.com/">FluentAssertions</a> or
<a href="http://www.n-fluent.net/">NFluent</a>.</p>

<p>Here is how our test would look like if we decide to use FluentAssertions:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Catching_argument_and_checking_manually_with_fluent_assertions</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange
</span>    <span class="n">PlainArgument</span> <span class="n">arg</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

    <span class="n">_fooService</span>
        <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Do</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">arg</span> <span class="p">=</span> <span class="n">x</span><span class="p">));</span>

    <span class="c1">// Act
</span>    <span class="n">_component</span><span class="p">.</span><span class="nf">DoStuff</span><span class="p">();</span>

    <span class="c1">// Assert
</span>    <span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Any</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;());</span>

    <span class="n">arg</span><span class="p">.</span><span class="nf">Should</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">BeEquivalentTo</span><span class="p">(</span><span class="k">new</span> <span class="nf">PlainArgument</span><span class="p">(</span>
            <span class="n">id</span><span class="p">:</span> <span class="m">11</span><span class="p">,</span> 
            <span class="n">firstName</span><span class="p">:</span> <span class="s">"jan"</span><span class="p">,</span> 
            <span class="n">lastName</span><span class="p">:</span> <span class="s">"kowlaski"</span><span class="p">,</span> 
            <span class="n">emailAddress</span><span class="p">:</span> <span class="s">"jan.kowalski@gmail.com"</span><span class="p">));</span>        
<span class="p">}</span></code></pre></figure>

<p>The error message is:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">Expected member Id to be 11, but found 7.
Expected member FirstName to be "jan" with a length of 3, but "john" has a length of 4, differs near "ohn" (index 1).
Expected member LastName to be "kowlaski" with a length of 8, but "doe" has a length of 3, differs near "doe" (index 0).
Expected member EmailAddress to be 
"jan.kowalski@gmail.com" with a length of 22, but 
"john.doe@gmail.com" has a length of 18, differs near "ohn" (index 1).

With configuration:
// (skipped)
// Here FluentAssertions describes configuration
// that it used to compare the two objects.</code></pre></figure>

<p>Not bad, I must say. We get a list of only these properties that have
unexpected values. Certain messages seem a little bit too verbose for me
e.g. <code class="highlighter-rouge">Expected member FirstName to be "jan" with a length of 3</code>,
 <code class="highlighter-rouge">but "john" has a length of 4, differs near "ohn" (index 1).</code>
Maybe <code class="highlighter-rouge">Expected FirstName to be "jan" but was "john".</code> would be
just enough?
Still it is the best solution that we have so far.</p>

<p>The only downside that I see 
is that the test code is now a little more verbose and less readable.
Mainly because 
we are now responsible for manually capturing argument’s value:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">PlainArgument</span> <span class="n">arg</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="n">_fooService</span>
    <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Do</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">arg</span> <span class="p">=</span> <span class="n">x</span><span class="p">));</span></code></pre></figure>

<p>With a bit of C# magic we may make argument capturing less painful:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">_fooService</span>
    <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="nf">Capture</span><span class="p">(</span><span class="k">out</span> <span class="n">Arg</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;</span> <span class="n">arg</span><span class="p">));</span>

<span class="c1">// Act
</span><span class="n">_component</span><span class="p">.</span><span class="nf">DoStuff</span><span class="p">();</span>

<span class="c1">// Assert
</span><span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">Any</span><span class="p">&lt;</span><span class="n">PlainArgument</span><span class="p">&gt;());</span>

<span class="c1">// This time we use NFluent
</span><span class="n">Check</span><span class="p">.</span><span class="nf">That</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">Value</span><span class="p">).</span><span class="nf">HasFieldsWithSameValues</span><span class="p">(</span>
    <span class="k">new</span> <span class="nf">PlainArgument</span><span class="p">(</span>
        <span class="n">id</span><span class="p">:</span> <span class="m">7</span><span class="p">,</span> 
        <span class="n">firstName</span><span class="p">:</span> <span class="s">"john"</span><span class="p">,</span> 
        <span class="n">lastName</span><span class="p">:</span> <span class="s">"doe"</span><span class="p">,</span> 
        <span class="n">emailAddress</span><span class="p">:</span> <span class="s">"john.doe@gmail.com"</span><span class="p">));</span> </code></pre></figure>

<p>To see how it works please check <a href="https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages/blob/master/Library.Test/ArgCapture.cs">ArgCapture.cs</a> file.</p>

<p>Catching argument’s value manually is cumbersome and 
makes tests less readable. On the other hand using some “magical”
syntactic sugar also does not looks like a good idea. 
After all our code should be simple. If we can avoid using “magic”
we should do it!</p>

<p>Our final solution is to create a custom NSubstitute argument matcher.
The matcher uses undercover FluentAssertions library to perform the check.
Here is how the test code looks like with this approach:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Checking_argument_using_custom_NSubstitute_matcher</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange
</span>
    <span class="c1">// Act
</span>    <span class="n">_component</span><span class="p">.</span><span class="nf">DoStuff</span><span class="p">();</span>

    <span class="c1">// Assert
</span>    <span class="n">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PlainArgument</span><span class="p">(</span>
        <span class="n">id</span><span class="p">:</span> <span class="m">11</span><span class="p">,</span> 
        <span class="n">firstName</span><span class="p">:</span> <span class="s">"jan"</span><span class="p">,</span> 
        <span class="n">lastName</span><span class="p">:</span> <span class="s">"kowlaski"</span><span class="p">,</span> 
        <span class="n">emailAddress</span><span class="p">:</span> <span class="s">"jan.kowalski@gmail.com"</span><span class="p">);</span>

    <span class="n">_fooService</span><span class="p">.</span><span class="nf">Received</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">DoStuff</span><span class="p">(</span><span class="n">WithArg</span><span class="p">.</span><span class="nf">EquivalentTo</span><span class="p">(</span><span class="n">expected</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>The error message generated for an argument that does
not overload <code class="highlighter-rouge">ToString</code> looks like this (formatting added):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">Expected to receive a call matching:
    DoStuff(PlainArgument)
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*PlainArgument*)
        arg[0]: Expected member Id to be 11, but found 7.
                Expected member FirstName to be "jan" with a length of 3, 
                but "john" has a length of 4, differs near "ohn" (index 1).
                Expected member LastName to be "kowlaski" with a length of 8, 
                but "doe" has a length of 3, differs near "doe" (index 0).
                Expected member EmailAddress to be 
                "jan.kowalski@gmail.com" with a length of 22, but 
                "john.doe@gmail.com" has a length of 18, differs near "ohn" 
                (index 1).</code></pre></figure>

<p>It is clear that the problem occurred at the first argument (<code class="highlighter-rouge">arg[0]</code>). 
Also we can see the actual and expected values of the argument’s 
fields and properties.
And the test code is simple and clean.
If you are interested how it is implemented please see
<a href="https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages/blob/master/Library.Test/CustomMatcher.cs">CustomMatcher.cs</a>
file.</p>

<p>As we can see there exists no perfect solution. Still with a little effort
we can make our error messages much more readable and pleasurable to work with.
I personally suggest to use either the last solution or 
the solution presented in <code class="highlighter-rouge">Catching_argument_and_checking_manually_with_fluent_assertions</code> test.</p>

<p>Source code and examples: <a href="https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages">GitHub</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>Inheritance? Just say no!</title>
	  <link>//inheritance-just-say-no</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-12-12T01:00:00+01:00</pubDate>
	  <guid>//inheritance-just-say-no</guid>
	  <description><![CDATA[
	     Recently during a code review I have found the following piece
of code:
{% highlight csharp %}
public class TemplateCache 
    : ConcurrentDictionary<TemplateName, Template> { }
{% endhighlight %}
Here the programmer broke one of the most fundamental principles
of modern object oriented programming:

> Prefer composition over inheritance

Why inheritance is bad in most of the cases? Here are the reasons:

###### Watered down component API

What methods would you expect on a cache? Something that gets
values from the cache if they are already there. Let us call 
this operation `TryGetValue(cacheKey, out value)`. 
And of course a method to
add a new or overwrite an existing cache entry, let's call it
`SetValue(cacheKey, value)`. Do we need more methods on a cache
from the client point of view? Maybe in the future we will want to
extend `SetValue` operation to allow client to specify for how
long items added to the cache should be stored? Who knows. 
But still we would end up with only two operations. 

> NOTE A truly generic and reusable cache 
> is usually slightly more complicated - instead of two
> we have three methods! For example please see
> [IMemoryCache](https://github.com/aspnet/Caching/blob/master/src/Microsoft.Extensions.Caching.Abstractions/IMemoryCache.cs) interface.

On the other hand if we use inheritance we end up with something 
like this:
![Cache API when we use inheritance](assets/images/2018-12-12/cache_api.png)
This is much more than we asked for. We actually get operations
that make no sense for a cache like `IsEmpty`. I mean either an item
that we are looking for is in the cache or it is not - who cares
if the cache is empty itself? 

I hope that I managed to persuade you that a good component
API should be small, focused and easy to use. We get none of these 
if we use inheritance.

###### Broken encapsulation

By using inheritance we are making it clear to the clients of
our component that it is implemented using `ConcurrentDictionary` class.
If we wait long enough we will notice that some of them 
will start relaying on that knowledge in their code. 
For example they may use `ContainsKey` method for checking if
the cache contains a given entry. 
What will happen later, when we decide that we want to change 
the cache implementation and use for example 
[IMemoryCache](https://dotnetcoretutorials.com/2017/03/05/using-inmemory-cache-net-core/) instead?
Clients of our component will get angry, because
our new version of the cache  
introduced a breaking change into their code.

Just to sum up: Inheritance both exposes implementation
details of components and makes evolution of their APIs more difficult.

###### Liskov substitution principle is violated 

In short some operations that make sense for a dictionary
may not make sense for a cache. For example it makes no
sense to cache a template that does not exists, yet with
inheritance we may write:

{% highlight csharp %}
var foo = new TemplateName("foo");

ConcurrentDictionary<TemplateName, Template> dict 
   = new TemplateCache();

dict.GetOrAdd(foo, (Template)null);

// Ops we have a null template here...
Console.WriteLine("value is: " + 
   dict.GetOrAdd(foo, (Template)null));
{% endhighlight %}

When we use inheritance we are telling the type system that
`TemplateCache` *is a* `ConcurrentDictionary`. 
From logical point of view this makes no sense. They are two
different components that have two different purposes and also
different usage patterns. 
They should have nothing in common.

> BTW You should avoid putting `null`s into collection classes of any sort.

Let's finish this post by seeing how composition can be used
to improve our `TemplateCache` component:
{% highlight csharp %}
public class TemplateCache {
  private readonly ConcurrentDictionary<TemplateName, Template> _cache 
      = new ConcurrentDictionary<TemplateName, Template>();

  public bool TryGetTemplate(TemplateName name, out Template template)
      => _cache.TryGetValue(name, out template);

  public void AddTemplate(Template template)
      => _cache.AddOrUpdate(
          template.Name, template, (name, existing) => template);
}
{% endhighlight %}
Yep, simple, clean and easy to use!


	  ]]></description>
	</item>

	<item>
	  <title>Abusing local functions to hide design problems</title>
	  <link>//abusing-local-functions-to-hide-design-problems</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-10-08T02:00:00+02:00</pubDate>
	  <guid>//abusing-local-functions-to-hide-design-problems</guid>
	  <description><![CDATA[
	     Recently I was browsing through a certain code base
and I saw a code similar to this:
{% highlight csharp %}
public class EnterpriseNotificationSender {
    private readonly IUserManagementService _userManagementService;
    // ctor and stuff...
  
    public void SendNotificationsToUsers(string companyId) {
        var addresses = GetRecipientsAddresses(companyId);
        foreach(var address in addresses) {
            SendNotification(address);
        }
    }
  
    private IEnumerable<EmailAddress> 
                     GetRecipientsAddresses(string companyId) {
        return _userManagementService
             .FindUsersBelongingToCompany(companyId)
             .Where(UserShouldReciveNotification)
             .Select(user => user.EmailAddress)
             .ToList();
  
        bool UserShouldReciveNotification(User user) {
            return user.EmailAddress != null
                && user.IsRegistered
                && !user.IsDisabled;
        }
    }
  
    private void SendNotification(EmailAddress address) {
        // do stuff...
    }
}
{% endhighlight %}
Especially `GetRecipientsAddresses` method draw my attention.
Someone extracted quite complicated lambda expression
to a local function.
At first I thought that this is indeed a very nice usage for local
functions.
LINQ query is much more readable
with expressions like `Where(UserShouldReciveNotification)`
instead of long lambdas.

It took me a while to realize that the local function
in the code above, was used to hide design problems.
Let's take a closer look at the condition encapsulated by
`UserShouldReciveNotification` function:
{% highlight csharp %}
return user.EmailAddress != null
    && user.IsRegistered
    && !user.IsDisabled;
{% endhighlight %}
We should deal with the simplest to fix problems first:

**Bad naming:** We should always format predicates in "a positive way".
For examples we should prefer `IsOpen` and `IsAvailable` to `IsClose`
and `IsUnavailable`. Here `IsDisabled` should be named `IsEnabled`.
As a first step in refactoring we may add `IsEnabled` property
to the `User` class:
{% highlight csharp %}
public bool IsEnabled => !IsDisabled;
{% endhighlight %}

**Unreadable condition:** If a user has optional email then we may expect
that our codebase is littered with little `user.EmailAddres != null` checks.
To increase readability we should encapsulate this check into a separate property:
{% highlight csharp %}
public bool HasEmailAddress => (EmailAddress != null);
{% endhighlight %}

**Missing entity attributes:** When I looked closely at the condition
`user.IsRegistered && !user.IsDisabled` I found out that it occurs
in many places in that codebase. For some reason the system was creating
users before they actually registered. A user that not registered yet was basically
a stub not a real user. Users could also be disabled by admins (registered or not),
this is what the second part of the condition was responsible for.
Clearly `User` entity is missing an attribute that could tell us whatever
a user is active, so let's add one:
{% highlight csharp %}
public bool IsActive
    => IsRegistered && IsEnabled;
{% endhighlight %}

After all these refactorings we may finally rewrite our LINQ query:
{% highlight csharp %}
return _userManagementService
    .FindUsersBelongingToCompany(companyId)
    .Where(user => user.IsActive)
    .Where(user => user.HasEmailAddress)
    .Select(user => user.EmailAddress)
    .ToList();
{% endhighlight %}
This version is as readable as version with the local function,
but does not attempt to hide code smells.

Conclusion: Every time when you have a too long or too complicated
lambda expression, that you what to extract to a local function,
think if you can simplify that lambda by extracting conditions and checks
into new methods and properties on processed objects.


	  ]]></description>
	</item>

	<item>
	  <title>Avoid hidden coupling to interface implementation</title>
	  <link>//avoid-hidden-coupling-to-interface-implementation</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-09-21T02:00:00+02:00</pubDate>
	  <guid>//avoid-hidden-coupling-to-interface-implementation</guid>
	  <description><![CDATA[
	     A few days ago I was reviewing a pull request at work and
one line of code catch my eye:
{% highlight csharp %}
var @event = new CupOfCoffeeReadyEvent(/* ... */);
_logger.LogInformation(
    "Publishing cup of coffee event: {@Event}.", @event); // <== this one
_mediator.Publish(@event);
{% endhighlight %}
At my workplace we are using standard `ILogger` interface from 
`Microsoft.Extensions.Logging.Abstractions`
package. Also logged variable name starts with `@` (`@event`). 
And so I started to suspect that 
the log statement contains an error and instead it should be written as:
{% highlight csharp %}
// {@Event} -> {Event}
_logger.LogInformation(
    "Publishing cup of coffee event: {Event}.", @event);
{% endhighlight %}
Without thinking any further I put a friendly comment, that 
this logging statement should be fixed.
After half an hour, instead of a fix I get the following response:

> In this microservice we are using Serilog as third-party logging provider.
>
> In Serilog `@` is used as destructuring operator,
> please see: 
> https://github.com/serilog/serilog/wiki/Structured-Data#preserving-object-structure
>
> Basically this means that the argument will be logged in JSON form.

So `@` character was put there on purpose. OK, fine.
But there still was something fishy about this code. 
On the one hand we are using `ILogger` from 
`Microsoft.Extensions.Logging.Abstractions` to decouple ourselves 
from any specific logging provider,
on the other hand we are using Serilog specific extensions.
This results in a false sense of security. 
We may think that since we are
using standard `ILogger`, changing logging provider to e.g.
Azure Web App Diagnostics would be as simple as changing `Startup` 
class of our application.
Unfortunately since we coupled ourselves with Serilog 
(by Serilog specific extensions to the log message template),
some of our log statements may not work with the new logging provider.

So what is the solution to this problem? We must choose whatever we
want to use Serilog specific features. If we want to use them, then 
we should not hide the fact that we are using Serilog. Fortunately for
us Serilog provides it's own, ready to use `ILogger` interface.
And we should use that interface instead of standard one accross
the entire application.

On the other hand, if we expect that we may need to change logging
provider in the future, we should stick with 
`Microsoft.Extensions.Logging.Abstractions` `ILogger` and we should
use only the features that are described in 
[the official documentation](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.1). 
If our needs are not fully covered
by the standard `ILogger` 
e.g. we must log objects as JSON, then we must implement them
ourselves by e.g. creating wrappers around parameters:
{% highlight csharp %}
_logger.LogInformation(
    "Publishing cup of coffee {Event}.", new LogAsJson(@event));
{% endhighlight %}

It is really interesting that a similar coupling happens when using
`IEnumerable<T>` interface as the return type of a method.
How many times have you seen a code similar to:
{% highlight csharp %}
public void SomeMethod() {
    // IEnumerable<User>
    var users = userService.FindAllUsers();
    
    users
        .ToList()
        .ForEach(user => user.IsActive = false);
    
    userService.SaveAll(users.ToArray());
}
class UserSerivce {
    public IEnumerable<User> FindAllUsers() {
        return new List<User> {
            new User { IsActive = true },
            new User { IsActive = false }
        };
    }
    public void SaveAll(params User[] users) {
        foreach (var user in users) {
            Console.WriteLine(user.IsActive);
        }
    }
}
public class User {
    public bool IsActive { get; set; }
}
{% endhighlight %}
Again we have here a bad case of hidden coupling to the interface implementation.
We are using `IEnumerable<T>`
interface but we are assuming that it is backed by
a collection for which multiple enumerations always
return the same elements. 
Our code will break 
when someone will change `FindAllUsers` implementation to
e.g.:
{% highlight csharp %}
public IEnumerable<User> FindAllUsers() {
    yield return new User { IsActive = true };
    yield return new User { IsActive = false };
}
{% endhighlight %}

The solution to this problem is honesty. If you have
a value of type `IEnumerable<T>`, tread it as 
a value of type `IEnumerable<T>`. Nothing more, nothing less.
Do not assume that multiple enumerations
will return the same elements. 
This is not guaranteed by that interface.

If you want to return a sequence of elements from a method with
this additional guarantee, then please use a more specific 
interface like `ICollection<T>` or `IReadOnlyList<T>` or 
maybe even something from `System.Collections.Immutable` package.



	  ]]></description>
	</item>

	<item>
	  <title>How NOT to use the repository pattern</title>
	  <link>//repository-pattern-my-way</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-07-08T02:00:00+02:00</pubDate>
	  <guid>//repository-pattern-my-way</guid>
	  <description><![CDATA[
	     ### Generic repository pattern

First, to avoid misunderstandings, let me explain what I understand
by generic repository. Have your ever seen an interface like this:
{% highlight csharp %}
public interface IGenericRepository<TEntity> 
    where TEntity : class 
{
    IEnumerable<TEntity> Get(
        Expression<Func<TEntity, bool>> filter = null,
        Func<IQueryable<TEntity>, IOrderedQueryable<TEntity>> orderBy = null,
        string includeProperties = "");
    TEntity GetById(object id);

    void Insert(TEntity entity);

    void Update(TEntity entityToUpdate);

    void Delete(object id);
    void Delete(TEntity entityToDelete);
}
{% endhighlight %}
Or maybe you saw it's twin brother that have a slightly 
different variant of `Get` method:
{% highlight csharp %}
IQueryable<TEntity> GetAll();
{% endhighlight %}

Inspiration for the first of these examples comes from 
[official Microsoft documentation for ASP.NET MVC 4](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application#implement-a-generic-repository-and-a-unit-of-work-class).
As for the second example you can find countless number of blogs that
describe this variant of the repository pattern e.g.
[here](http://www.tugberkugurlu.com/archive/generic-repository-pattern-entity-framework-asp-net-mvc-and-unit-testing-triangle),
[and here](https://deviq.com/repository-pattern/),
[and also here](https://www.codeproject.com/Articles/814768/CRUD-Operations-Using-the-Generic-Repository-Patte)
sometimes with slight variantions like returning `IEnumerable<TEntity>` instead of
`IQueryable<TEntity>`. 
And in the later case often with an additional method for generating
queries like:
{% highlight csharp %}
IEnumerable<T> FindAll(Expression<Func<T, bool>> predicate);
{% endhighlight %}

So what is wrong with them you may ask? So far almost nothing,
not counting of course badly naming of the methods from Microsoft example(
they should be called `Find` and `FindAll` not `Get` and `GetAll`).

But "almost nothing" does not equal "nothing". One problem that I find with
these interfaces is that they violate Interface Segregation Principle.
They expose full set of CRUD operations even for entities for which 
e.g. deleting does not make sense (for example when you deactivate users
instead of deleting them from DB;
also see [Udi Dahan post about deleting data](http://udidahan.com/2009/09/01/dont-delete-just-dont/)).
But this problem can be easily solved by splitting this interface into three -
one for reading, one for updating and one for deleting entities.

The real problem that I have with these interfaces comes from their *improper*
usage. The original idea behind them is that they should be used as a base
interfaces for your custom repository interfaces, just like this:
{% highlight csharp %}
public interface IFooRepository : IGenericRepository<Foo> {
    Foo FindNewest();
    IEnumerable<Foo> FindAllOutdated();
}
{% endhighlight %}
And that your command handlers and services 
(in other words clients of your custom repositories) 
should decide what methods are
needed and should be put on your custom repository interfaces.

That is the theory. Unfortunately what I already saw a few times in my career 
instead is this:
{% highlight csharp %}
// notice: this is NOT an abstract class
public class GenericRepostiory<TEntity> : IGenericRepository<TEntity> {
    // implementation details skiped

    public IQueryable<TEntity> GetAll() { /* code */ }
    public TEntity GetById(object id) { /* code */ }

    public void Insert(TEntity entity) { /* code */ }
    public void Update(TEntity entityToUpdate) { /* code */ }

    public void Delete(object id) { /* code */ }
    public void Delete(TEntity entityToDelete) { /* code */ }
}
{% endhighlight %}
Someone has created a working implementation of `IGenericRepostory` interface.
What is worse this implementation is almost always registered in IoC container and
can be injected into your command handlers and
services like any other dependency:
{% highlight csharp %}
public class OrderService {
    private readonly IGenericRepository<Order> _orderRepository;

    // ctor and other stuff...

    public NewestOrderDto FindNewestOrderForCurrentUser() {
        var newestOrders = _orderRepository.GetAll()
            .Where(order => order.AssignedTo.Id == _currentUser.Id)
            .Where(order => order.State != OrderState.Closed)
            .OrderByDescending(order => order.CreationDate)
            .Take(10)
            .ToList();

        return _mapper.MapTo<NewestOrderDto>(newestOrders);
    }
}
{% endhighlight %}

This *looks* nice and clean but is not. I will tell you more about why
this is wrong later. Now I want to deal with one "solution" to the
`GenericRepository<T>` misinterpretation that 
I often hear from other developers. 
This solution sounds like this (dialog during code-review):

JIM SENIOR: Have you ever heard that
NHibernate `ISession` or Entity Framework `DbSet` *is a* repository?
Indeed what you just created is a tin wrapper over either 
`ISession` or `DbSet`.
Actually we can replace this `GenericRepository<T>` by e.g.
`DbSet` and get pretty must the same results.
The only service that `IGenericRepository<T>` provides is that it hides
most of the thirty methods that `DbSet` has. 
JONNY JUNIOR: Oh, indeed what you just said make sense.
I guess using generic repository
pattern here was a bit of overengineering. (Happily gets back to coding...)

For me using either `GenericRepository<T>` or raw `DbSet` is wrong most of the
time (one exception that I can accept is when you write 
the most CRUDest application ever, then don't bother
and use `DbSet` in your services). And why? Due to the following reasons:

- The only option to make sure that your LINQ queries will be properly translated
 to SQL is to test them against **the same** kind of database that you use 
 in production environment. But when your queries are scattered over methods 
 of your services it may be hard to create integration tests for them.
 For example look at the code:

{% highlight csharp %}
if (/* some complicated condition */) {
	if (/* some other complicated condition */) {
		 var result = _orderRepository.GetAll()
			  .Where(order => order.AssignedTo.Id == _currentUser.Id)
			  .Where(order => order.State != OrderState.Closed)
			  .OrderByDescending(order => order.CreationDate)
			  .Take(10)
			  .ToList(); 

		 return _mapper.MapTo<NewestOrderDto>(newestOrders);
	}
	// some code here
}
// more code here
{% endhighlight %}

To execute above query you must fulfill two if's conditions. This will make
an integration test for the above query less readable and more fragile. 
Instead imagine that this query is encapsulated by a repository method.
In integration test you would just call that repo method and check the 
results - simple isn't it?

- I am sure that you agree with me 
 that inline LINQ queries inside services 
 are not reusable and that they have a nasty tendency to
 duplicate themselves over the codebase. Even when a programmer decides to
 extract query to it's own method, it will usually be a private method on 
 a particular service. Moving queries to repository 
 methods makes them automatically reusable
 across entire application. 

- Inline LINQ queries are not named. Usually the only clue what a particular
 query does (without going deep it's logic) is the name of the variable that
 holds query result. Unfortunately for us inventing a good variable names is a skill
 that only comes with the experience and since we have a lot of junior devs in our 
 industry we are faced with names like `result`, `ordersToProcess` or just `orders`.
 Wrapping the query inside a repo method will automatically give it a name. 
 Even if this name is not perfect we can refactor it later and all places 
 that call this method will benefit from our refactoring automatically!

- Sometimes for performance reasons we are forced to use raw SQL to get our
 data from DB. Do you really want to litter your business logic with low
 level technical stuff like `DbConnection`s, query parameters and `SqlException`s?
 Let's hide this low level stuff inside a repository and let our business code 
 concentrate on business logic. Also see 
 [Single level of abstraction principle](http://principles-wiki.net/principles:single_level_of_abstraction).

So what is the solution you may ask? Get ready...

### What we need is the "specific" repository pattern

We should start repository design by specifying it's interface. 
The interface should contain only methods required by clients of 
the repository. In other words if nobody needs to delete entities of a given type
or it does not make sense from business point of view
we will not add `Delete` method to the interface.

If you are afraid that you will end up with different names for
basic CRUD operations like `Delete` on one repo and `Remove` on the other
you may create helper interfaces like `ICanDeleteEntity<TEntity>`,
`ICanUpdateEntity<TEntity>` etc. that will contain only methods for
specific usage like deleting, updating etc. 
Then the repository interface can inherit 
appropriate subset of them.

None of the methods on the repository interface should return `IQueryable<T>`
type.
Also make sure that the repository implementation does not 
return `IQueryable<T>` value hidden as `IEnumerable<T>` one. 
Always call `ToList()`
or `ToArray()` to materialize query results before returning them 
to the client.

When it comes to the repository implementation, the implementation is free
to inherit from *abstract* `GenericRepository<TEntity>` base class. 
Alternatively it may use `ISession` or `DbSet` directly if it is more convenient. 
No matter what approach you choose remember that "excessive" methods
like `Delete`
inherited from base class
may be hidden by the repository interface.

Please remember that your repository is NOT responsible for managing
database transactions. This concern is best managed using 
[Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).
This pattern is already implemented by both `ISession` and `DatabaseContext`
(think change tracking and dirty checking),
we only need a better interface over them:
{% highlight csharp %}
public interface IUnitOfWork {
    // or just Begin()
    void BeginTransaction();

    void Commit();
    void Rollback();
}
{% endhighlight %}

For the most web applications it is enough to start transaction using `IUnitOfWork`
at the beginning of the HTTP request and either `Commit` or `Rollback` at
the end of the request. This can be done by using either an action filter
or a decorator around command handlers and/or services. 

Example repository created using the above guidelines:
{% highlight csharp %}
public interface IOrderRepository {
	// We do not need FindById so we do not included it
	IEnumerable<Order> FindActiveOrdersAssignedToUser(UserId id); 
}

public class OrderRepository : GenericRepository<Order>, IOrderRepository {
    public IEnumerable<Order> FindActiveOrdersAssignedToUser(UserId id) {
        return base.FindAll()
                .Where(order => order.AssignedTo.Id == id.Value)
                .Where(order => order.State != OrderState.Closed)
                .ToList();
    }
}
{% endhighlight %}

This should be obvious by now, but let's not take chances.
Every method of our repositories should be covered by one or more
integration tests, which should use the same kind of DB that we use 
in production environment. Remember always use *integration* tests to
test your repositories.

### Turbocharging the repository pattern

There is no rose without thorns and presented above approach also has some
serious drawbacks. Some of them can be fixed by using a different
architecture than classic 3-layer arch.
Most common problems with "specific" repositories are as follows:

- Repositories can over long periods of time accumulate 
 dozens and dozens of `Find*` methods. Often these methods will be very similar
 to each other. There are two ways to combat this unwanted grow. One is to use 
 a query object pattern. Basically you group several of these `Find*` methods together
 into one more general `Find` method. That method should accept an object that will
 represent a query criteria. For example:

{% highlight csharp %}
var ordersToCancel = _orderRepository.FindAllMatching(
	// Alternatively you may use the builder pattern
	// to create a criteria object.
	new OrderCriteria {
		StatusIsIn = new[] { OrderStatus.New, OrderStatus.InProgres },
		OrderedItemsContainAll = new[] { searchedItem },
		CustomerIs = GetCurrentCustomer()
	});
{% endhighlight %}

To create a query from the criteria object we examine each search criteria and
build query step-by-step:
{% highlight csharp %}
IQueryable<Order> q = base.FindAll();

if (criteria.StatusIsIn != null) {
	q = q.Where(o => criteria.StatusIsIn.Contains(o.Status));
}

// A long list of other conditions here..

return q.ToList();
{% endhighlight %}

A closely related yet different aproach is to use the query object pattern (see 
[this](https://martinfowler.com/eaaCatalog/queryObject.html) and
[this](https://lostechies.com/jimmybogard/2012/10/08/favor-query-objects-over-repositories)).

The second solution to this problem is more robust and reliable.
Usually too big repositories are accompanied by huge services and 
overgrown entities. You can slim down both your repos and services 
by using something that I call CQRS-light. It differs from full-blown
CQRS by using exactly the same database tables for both reads and writes.
When doing CQRS-light we can use the same ORM framework for both reading and
writing data and slowly migrate to real CQRS only in these parts of our
application that really need it (do recall this 80+ columns searchable grid that
generates 20+ inner join query that halts your DB server? - real CQRS can help here).

The diagram below presents typical architecture of CQRS-light application:
![CQRS-light architecture](assets/images/2018-07-08/cqrs-light.svg)

The key principles of CQRS-light are:

- Split all user actions into two categories. In the first put all actions that
 can modify the state of the system like e.g. creating a new order in an e-commerce app.
 In the second  
 category put all actions that do not modify state of the system e.g. 
 viewing an order details. First category represents commands (writes), the second one
 queries (reads). Only commands can change state of the system.

- Query handlers do NOT use repositories to access data. They access DB 
 using whatever technology they want.
 Usual configurations include a single ORM on both read and write sides, 
 ORM for writes and micro-ORM like Dapper for reads or 
 using ORM for writes and raw SQL for reads.

- Command handlers can only use repositories to access and modify data. 
 Command handlers 
 should not call query handlers to fetch data from database. 
 If a command handler needs to execute 
 a complex query and this query can be answered by a query handler
 you should duplicate this query logic and put it
 in both query handler and in a repository method
 (read and write sides must be separated).

- Query handlers are tested only using integration tests.
 For command handlers you will have unit and optionally integration tests.
 Repositories will be tested using integration tests.

CQRS even in the "light" version is a huge topic and deserves a blog post of it's own.
[MediatR](https://github.com/jbogard/MediatR) library is a good starting point
if you want to find out more about CQRS-light approach.

Let us return to the subject of the "specific" repository pattern drawbacks. 
The second drawback that I want to mention is unwanted migration of the business
logic into query definitions. For example even this simple query:
{% highlight csharp %}
public IEnumerable<Order> FindActiveOrders() {
  return base.FindAll()
          .Where(order => order.State != OrderState.Closed 
                       && order.State != OrderState.Canceled)
          .ToList();
}
{% endhighlight %}
contains a piece of business logic that describes what 
it means for an order to be active.
Usually ORM's prevent us from encapsulating such pieces of logic
into a separate properties like `IsActive`.

What we need here is the specification pattern.
You can find pretty decent overview of the specification pattern
[here](https://enterprisecraftsmanship.com/2016/02/08/specification-pattern-c-implementation/).
Our query method when we use the specification pattern should look similar to:
{% highlight csharp %}
public IEnumerable<Order> FindActiveOrders() {
  return base.FindBySpec(new ActiveOrders())
          .ToList();
}
{% endhighlight %}



	  ]]></description>
	</item>


</channel>
</rss>

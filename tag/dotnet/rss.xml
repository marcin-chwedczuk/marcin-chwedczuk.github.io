<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>FluentAssertions and code formatting</title>
	  <link>//fluent-assertions-and-code-formatting</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2019-02-10T01:00:00+01:00</pubDate>
	  <guid>//fluent-assertions-and-code-formatting</guid>
	  <description><![CDATA[
	     <p>Recently I was playing with
<a href="https://fluentassertions.com/">FluentAssertions</a>
library.
I was really amazed by the beautiful error messages generated by FluentAssertions.
For example, for this failing test:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_its_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange
</span>    <span class="n">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>
    
    <span class="c1">// Assert
</span>    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">).</span><span class="nf">Should</span><span class="p">().</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>FluentAssertions generates a message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected service.Add(1, 2) to be 3, but found 42.</code></pre></figure>

<p>Unfortunatelly my joy did not last long.
When I added an explanation to an assertion and
broke the line because it got too long:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_its_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange
</span>    <span class="n">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>

    <span class="c1">// Assert
</span>    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">Should</span><span class="p">().</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="n">because</span><span class="p">:</span> <span class="s">"three is sum of one and two"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>FluentAssertions reproted just:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected value to be 3 because three is sum of one and two,
    but found 42.</code></pre></figure>

<p>It turns out, in order to have these fancy error messages,
we must place <code class="highlighter-rouge">.Should()</code> on the same line as the
tested expression:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange
</span>    <span class="n">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>

    <span class="c1">// Assert
</span>    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span><span class="cm">/*abra cadabra*/</span><span class="p">.</span><span class="nf">Should</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="n">because</span><span class="p">:</span> <span class="s">"three is sum of one and two"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The above test generates a message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected service.Add(1, 2)/*abra cadabra*/ to be 3 because three
   is sum of one and two, but found 42.</code></pre></figure>

<p>Notice that comment was also include in the message.</p>

<p>This behavior of FluentAssertions really suprised me.
Why the way we format our code have influence over
the readability of error messages?</p>

<p>Anyway this is how FluentAssertions works,
moreover this behaviour is described 
(with short explanation how it works) on the <em>first</em> page
of <a href="https://fluentassertions.com/documentation/#subject-identification">the official documentation</a>.
If only I have spend ten minutes reading the friendly docs instead of
skimming it…</p>

<p>From now on I will follow “Read The Friendly Manual” (RTFM) advice!!!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Random thoughts on Maybe</title>
	  <link>//random-thoughts-on-maybe</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2019-01-01T01:00:00+01:00</pubDate>
	  <guid>//random-thoughts-on-maybe</guid>
	  <description><![CDATA[
	     With functional programming on the rise nowadays, 
more and more people start using functional 
patterns in their code.
One of the simplest patterns is `Maybe<T>` monad
also called `Option<T>` or `Optional<T>`.
`Maybe<T>`'s primary use case is to represent a possibly
missing value. 

I have already use `Maybe<T>` a few times in real
codebases and in this post I want to gather my thoughts
on `Maybe<T>` and how, I think, it should be used.

#### Why we use `Maybe<T>`?

Most people that use `Maybe<T>` generally fall into
one of the two categories.

##### Category 1: Wants to eliminate `NullReferenceException`

For a long time before `Maybe<T>` programmers tried to
clearly state to the clients of their API that a given
method may return `null` instead of an object.
Some of them used special naming conventions or 
comments, for example:
{% highlight csharp %}
// Naming convention and XML documentation
// comments in action.
public interface IUserRepository {
    /// <returns>
    /// Returns <c>null</c> if user is not found.
    /// </returns>
    User FindById(UserId id);

    /// <exception cref="EntityNotFound">
    /// If user is not found.
    /// </exception>
    User FindRequiredById(UserId id);
}
{% endhighlight %}
Others resorted to using special marking attributes and
static code analysis tools. 
A good example of this category is 
[JetBrains.Annotations](https://www.nuget.org/packages/JetBrains.Annotations) package, that can be used together with ReSharper
to detect missing null checks:
{% highlight csharp %}
public interface IUserRepository {
    [CanBeNull]
    User FindById(UserId id);
}

public interface IUserService {
    void ActivateUser([NotNull] User user);
}
{% endhighlight %}
Yet another solution to this problem were 
[Code Contracts](https://www.infoq.com/articles/code-contracts-csharp)
developed by Microsoft.

None of those solutions is perfect and `Maybe<T>` seems
to offer a better alternative. 
Why? Because it is checked by the compiler,
does not require additional tools and does not slow
down compilation.
But remember there is 
[no silver bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet),
and `Maybe<T>` is not perfect either.

We can use `Maybe<T>` like this:
{% highlight csharp %}
public interface IUserRepository {
    Maybe<User> FindById(UserId id);
}
// and usage:
var user = usersRepository.FindById(userId);
if (user.HasValue) {
    return Ok(user);
}
else {
    return NotFound();
}
{% endhighlight %}

If you find yourself in this category of programmers, 
you would definitely
want to use a lightweight library that
does not force you to embrace a more functional style.
One good library that I can recommend is: 
[CSharpFunctionalExtensions](https://github.com/vkhorikov/CSharpFunctionalExtensions).

If you choose a different library, please make sure to check
that `Maybe<T>` is implemented using `struct`, otherwise you
may be surprised:
{% highlight csharp %}
Maybe<string> GetUserAgent() {
    return null;
}
{% endhighlight %}
One small downside of using a `struct` is
possibility of declaration of a nullable `Maybe<T>` type:
{% highlight csharp %}
// Don't do this:
Maybe<string>? bad;
{% endhighlight %}

When I was writing this article I tried to gather some
best practices of using `Maybe<T>`. 
Unfortunately it was very difficult to provide a comprehensive
list. There is not much material on this on the web (I mean using 
`Maybe<T>` *not* in the FP fashion) and the available
material is often contradictory. 
And so instead of providing you with a list of best practices, 
I will only give you some hints where you can look for advice.

We should start our search by looking at
Java 8, which was published in 2014 and introduced 
`java.util.Optional<T>` class. 
The purpose of this class is to be a nullability marker
for method results just like our `Maybe<T>`. 
There are a lot of articles about how `Optional<T>` should
and should not be used. 
A good starting point will be 
[this SO question](https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type)
with the first two answers. 
From this question alone we may learn e.g. to never wrap
a collection into `Maybe<T>`, 
instead of we should return a possibly empty collection.

The downside of reading Java's best practices is that some
of them do not apply to C#. For example let's look at the
advice given in [this SO answer](https://stackoverflow.com/a/39005452/1779504):

> When a method can accept optional parameters, 
> it's preferable to adopt the well-proven approach 
> and design such case using method overloading.

In other words author suggest to change:
{% highlight csharp %}
// this ctor:
public SystemMessage(
    string title,
    string body,
    Maybe<Attachment> attachment);

// into two ctor's:
public SystemMessage(
    string title,
    string body,
    Attachment attachment);

public SystemMessage(
    string title,
    string body);

// Because using these ctor's would be easier for
// the clients. Consider:
new SystemMessage("foo", "bar", Maybe<Attachment>.None)
new SystemMessage("foo", "bar", 
    Maybe<Attachment>.From(attachment))
// vs
new SystemMessage("foo", "bar");
new SystemMessage("foo", "bar", attachment);
{% endhighlight %}
But this argument does not applies to C#, where we can
use implicit conversion operator with default parameters
to achieve exactly the same effect without using overloads:
{% highlight csharp %}
public struct Maybe<T> { 
    private T _value;
    private bool _present;
    
    public Maybe(T value) { 
        _value = value;
        _present = (value != null);
    }
    
    public static implicit operator Maybe<T>(T value)
        => value == null ? new Maybe<T>() : new Maybe<T>(value); 
}

public class Attachment { }

public class SystemMessage {
    public SystemMessage(
        string title, string body, 
        Maybe<Attachment> attachment = default(Maybe<Attachment>)) { 
    }
}   

public class Program
{
    public static void Main() { 
        new SystemMessage("foo", "bar");
        new SystemMessage("foo", "bar", new Attachment());
    }
}
{% endhighlight %}
As we can see every Java'ish advice must be taken with 
a grain of salt.

Fortunately for us there is more and more C# posts about
using `Maybe<T>`. For example [this one](https://enterprisecraftsmanship.com/2015/03/13/functional-c-non-nullable-reference-types/)
from the author of CSharpFunctionalExtensions library.

Although I cannot provide you with a list of best practices,
I think I have gathered enough experience to provide
you with a list of `Maybe<T>` code smells:

* Nested `Maybe`s are wrong, for example `Maybe<Maybe<string>>`.
 Usually this is a sign that you should replace one of
 `Map` calls by a `FlatMap` (alternatively a `Select` by a `SelectMany` call).
* `Maybe`s that wrap collections are wrong, for example `Maybe<List<User>>`.
 Instead return a non-empty or empty collection.
* `Maybe`s wrapping nullable types are wrong, for example `Maybe<int?>`.
 Instead convert nullable type `T?` to `Maybe<T>`. 
 Even if you chosen library does not support such conversion out of 
 the box, you may write an extension method that provides this functionality
 yourself:

{% highlight csharp %}
public static Maybe<T> ToMaybe<T>(this T? value)
        where T: struct
    => value.HasValue ? Maybe<T>.From(value.Value) : Maybe<T>.None;
{% endhighlight %}

* Nested callbacks when using `Maybe<T>` fluent interface are wrong.
 For example:

{% highlight csharp %}
// BAD Fluent interface spaghetti
var cultureBad = user.Select(
    u => LoadPreferences(u)
        .Select(prefs => prefs.Culture));

// GOOD, only one operation per Select method call
var cultureGood = user
    .Select(u => LoadPreferences(u))
    .Select(prefs => prefs.Culture);
{% endhighlight %}

Also be mindful when using `Maybe<T>` with properties.
A declaration like:
{% highlight csharp %}
public Maybe<string> Culture { get; set; }
{% endhighlight %}
Means that you may both get and set an optional value.
In other words assignment of `None` value to this 
property should be valid:
{% highlight csharp %}
foo.Culture = Maybe<string>.None;
{% endhighlight %}
A property that can return `None` but must be
set to some value should be split into a getter and a method:
{% highlight csharp %}
// AVOID:
Maybe<string> Culture {
    get { return Maybe<string>.From(_culture); }
    set {
        if (value.HasNoValue)
            throw new ArgumentException("Culture cannot be empty.");
        _culture = value.Value;
    }
}

// PREFER:
Maybe<string> Culture
    => Maybe<string>.From(_culture);

void SetCulture(string culture) {
    if (culture == null)
        throw new ArgumentException("Culture cannot be empty.");
    _culture = culture;
}
{% endhighlight %}

As you probably heard C# 8.0 is going to introduce a nullable reference types (NRT).
Will NRT replace `Maybe<T>`?
For "Category 1" programmers, NRTs offer a better
alternative to `Maybe<T>`. On the other hand a lot of people
that start in "Category 1", slowly begin to embrace more FP approach.
Usually people start by using `Maybe<T>` fluent interface to transform
one `Maybe<T>` value into another. After some time they take a leap and
switch to writing in a more functional fashion.

We may also take a look at [Kotlin](https://kotlinlang.org/),
a language created by JetBrains that from the very beginning 
[offered nullable reference types](https://kotlinlang.org/docs/reference/null-safety.html). 
And yet the most popular Kotlin functional library
[funKTionale](https://github.com/MarioAriasC/funKTionale) 
still offers an `Option` type. 
So it looks like NRT or not, `Maybe<T>` is going to stay with us for sure.

##### Category 2: Wants to embrace FP paradigm

Programmers belonging to this category embraced FP. They
often think about using F# at work and are a bit disappointed
by poor C# pattern matching facilities. 

Code written in FP fashion will never use `if` to check
if `Maybe<T>` contains some value, instead a fluent interface
will be used to transform `Maybe<T>`s into some other values, for example:
{% highlight csharp %}
private UserRepository _userRepository;

// NOTICE: No if's in code
public static Option<string> GetUserCulture(int userId)
    => _userRepository.FindById(userId)
        .BiMap(
            Some: user => GetUserCulture(user),
            None: _ => null);

public static string GetUserCulture(User user)
    => user.Preferences    
            .Map(prefs => prefs.Culture)
            .IfNone("en-US");

public class UserRepository {
    private readonly List<User> _users = new List<User> {
        new User(1, null),
        new User(2, new UserPreferences {
            Culture = "pl-PL"
        })
    };

    // NOTICE: Extra extension methods for IEnumerable<T>
    // that return Option<T> instead of null's.
    public Option<User> FindById(int userId) {
        return _users.Find(u => u.UserId == userId);
    }
}

public class User {
    public int UserId { get; }

    private UserPreferences _preferences;
    public Option<UserPreferences> Preferences
        => Optional(_preferences);

    public User(int userId, UserPreferences preferences) {
        UserId = userId;
        _preferences = preferences;
    }
}

public class UserPreferences {
    public string Culture { get; set; }
}
{% endhighlight %}

Alternatively we may change our previous method to:
{% highlight csharp %}
public static string GetUserCulture2(int userId)
    => _userRepository.FindById(userId)
        .Bind(user => user.Preferences) // FlatMap
        .Map(prefs => prefs.Culture)
        .IfNone("en-US"); // default culture
{% endhighlight %}
The only difference between these two methods
is the value returned for users not present in the repository.
`GetUserCulture` returns for them `None()` but `GetUserCulture2`
returns a default culture (`Some("en-US")`).

Another sign of a functional design, is that monads like `Maybe<T>`
will be unpacked only on the outskirts of the application.
For example in a typical RESTful service, `Maybe<T>` value will 
be unpacked only in the controller:
{% highlight csharp %}
// GET /user/{userId}/culture
public IActionResult Get(int userId) {
    // WARNING: In real apps do not return bare strings 
    // from the REST api. 
    // Always wrap them in DTOs / ViewModels / QueryResponses.
    Maybe<string> culture = GetUserCulture();
    return Maybe(culture);
}

// Presumably in the base controller
public IActionResult Maybe<T>(Maybe<T> m)
    => m.Map(value => Ok(value))
        .IfNone(() => NotFound());
{% endhighlight %} 

In this category of programmers there is also a small group
of zealots, that in my opinion go a little bit to far in their cult of monads. 
They propose to use LINQ query syntax to transform monads.
Let my explain this using an example:
{% highlight csharp %}
// We want to sum three Option<int> values.
private static Option<int> GetOptionalInt()
    => 3;

// Using fluent interface:
var sum = GetOptionalInt()
    .SelectMany(_ => GetOptionalInt(), (a,b) => a+b)
    .SelectMany(_ => GetOptionalInt(), (a,b) => a+b);

// Using LINQ query:
var sum2 =  from n1 in GetOptionalInt()
            from n2 in GetOptionalInt()
            from n3 in GetOptionalInt()
            select n1+n2+n3;
{% endhighlight %}
I must admin that LINQ query offers some advantages like
ability to use `let` and `where` keywords. Also some transformations
may be easier to express using LINQ query syntax, for example:
{% highlight csharp %}
var sum2 =  
    from n1 in GetOptionalInt()
    from n2 in GetOptionalInt()
    from n3 in GetOptionalInt()
    let max = Math.Max(n1, Math.Max(n2, n3))
    let min = Math.Min(n1, Math.Min(n2, n3))
    where min != 0
    select max / min;
{% endhighlight %} 
Yet in my opinion fluent interface is in 90% of cases 
a more readable and understandable way 
to transform `Maybe<T>`s and other monads.
For example we may rewrite the last code snippet to:
{% highlight csharp %}
var res = Combine(
        GetOptionalInt(),
        GetOptionalInt(),
        GetOptionalInt()
    )
    .Map(nnn => {
        (var n1, var n2, var n3) = nnn;
        return new { 
            Max = Math.Max(n1, Math.Max(n2, n3)),
            Min = Math.Min(n1, Math.Min(n2, n3))
        };
    })
    .Filter(m => m.Min != 0)
    .Map(m => m.Max / m.Min);

// We need a few utils
private static Option<(T,T)> Combine<T>(Option<T> a, Option<T> b)
    => a.SelectMany(
            _ => b,
            (aValue, bValue) => (aValue, bValue));

private static Option<(T,T,T)> Combine<T>(Option<T> a, Option<T> b, Option<T> c)
    => Combine(a, b)
        .SelectMany(
            _ => c,
            (tt, cValue) => (tt.Item1, tt.Item2, cValue));
{% endhighlight %}
Not as pretty as LINQ query but still readable. 

At the end of the day consistency is what matters on real
projects. Choose one style and follow it consistently.

In this category we find libraries like 
[LanguageExt](https://github.com/louthy/language-ext).
This library has many flaws but still it is the best 
functional library on the market. 
My biggest disappointment with LanguageExt is poor documentation,
which basically consists of just a list of functions without any guidelines how
this library should be used and how it affects overall architecture.
Compare this with [Vavr](https://www.vavr.io/vavr-docs/)
(the most popular FP library for JVM) and you can clearly
see the difference.

If you decided that you want to use FP in you code, you
should definitively check awesome
[Railway oriented programming](https://fsharpforfunandprofit.com/rop/)
talk.

`Maybe<T>` is not the only monad that is popular, other
frequently used one is `Either<L,R>`. 
`Either<L,R>` is used to represent either a result of computation or an error.
You may think of `Either<L,R>` as a functional response to exceptions.
If you want to use `Maybe<T>` efficiently, you must learn 
how it can be transformed it into other monads, in particular into `Either<L,R>`.
E.g. we may make our last example more robust if we provide
information to the user why the computation failed:
{% highlight csharp %}
var result = Combine(
    GetOptionalInt(),
    GetOptionalInt(),
    GetOptionalInt()
    )
    .Map(ttt => {
        (var n1, var n2, var n3) = ttt;
        return new { 
            Max = Math.Max(n1, Math.Max(n2, n3)),
            Min = Math.Min(n1, Math.Min(n2, n3))
        };
    })
    .ToEither(() => Error("Not all values are available."))
    .Bind(m => Divide(m.Max, m.Min)); // FlatMap

Either<Error, int> Divide(int a, int b) {
    if (b == 0) return Left(Error("Cannot divide by zero"));
    return Right(a / b);
}

// Helper classes:
public class Error {
    public string Message { get; }

    public Error(string message) {
        Message = message;
    }

    public override string ToString()
        => $"Error({Message})";
}

public class ErrorHelpers {
    // For `using static` import...
    public static Error Error(string message)
        => new Error(message);
}
{% endhighlight %}

Since FP is on the rise, you will find a lot of books, blogs, podcasts
and MOOC's about using FP in C#. Also .NET has amazing F# community
that is very welcoming to the beginners.
One of the best blogs about FP in C# is in my opinion
[Mark Seemann blog](http://blog.ploeh.dk/archive/).

#### What to do with None?

How much value you will be able to extract from `Maybe<T>` depends on
your attitude towards `None`s. 
Every time when you have to handle `None`, you must decide if it is 
the result of 
[the accidental complexity](https://www.quora.com/What-are-essential-and-accidental-complexity)
e.g. someone passed a wrong id to the REST API) 
or if you just discovered a new edge case in your domain.

To better understand the problem let's follow an imaginary example.
Joe must write a simple function that will
send an email message to all users whose subscriptions will end in the next month.
During implementation Joe notices that `EmailAddress` field in `User` entity 
is declared as `Option<Email>`:
{% highlight csharp %}
public class User {
    public Option<Email> EmailAddress { get; }
    // ...
}
{% endhighlight %}
Now Joe knows that for some strange reason not all users have email addresses.
Joe logs into production DB to confirm that some email addresses are missing 
and indeed they are. Looks like Joe just discovered a new edge case.
Joe goes to Mark a business analyst to describe the problem. Mark is a long
timer in the company and knows that for a short period of time users
were able to log into the platform using their phone numbers instead of emails.
A new solution is created. Users that have no email address will receive 
a text message instead of an email. Also users without email will be asked to
enter their email address next time they log into the platform. Success!

On the other hand consider what will happen if Joe just
dig out the email address from `Maybe<T>` by accessing `Value` or if he just
log a warning about missing email address 
without telling anyone from the business side?

##### End of the part I 

Soon I will write a follow up to this post in which 
we will try to implement a perfect `Maybe<T>` type on our own and we will see
that it is not an easy task in C#.


	  ]]></description>
	</item>

	<item>
	  <title>NSubstitute and the search for perfect error messages</title>
	  <link>//nsubstitute-and-the-search-for-perfect-error-messages</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-12-15T01:00:00+01:00</pubDate>
	  <guid>//nsubstitute-and-the-search-for-perfect-error-messages</guid>
	  <description><![CDATA[
	     Those of us that practice TDD daily already know how important good
error messages in tests are. After all writing a failing test that
*clearly* states what functionality the program 
is missing is the first step in TDD cycle.
The rest of us that either can't or simply don't want to practice TDD
must put extra effort to ensure that tests always fail
with meaningful error messages.
Unfortunately, according to what I have learned from my personal experience, 
the most devs either don't have
enough time or simply don't bother to check if their tests fail with
something meaningful. For average Joe developer writing tests and
making them green is already a lot of work. 
Things like good test names and proper error messages are often forgotten.

But the developers are not the only one here to blame. 
Too often tools and libraries that supposedly should make unit testing
simpler and easier, generate horrible and often cryptic error messages.

In this post we will take a close look at 
[NSubstitute](http://nsubstitute.github.io/),
a modern and popular mocking libary for .NET and see 
how we can improve messages generated by its argument matchers.

Let's start by looking at a simple test. 
It demonstrates how NSubstitute is often used to assert that 
a method was called with an argument in a certain state:
{% highlight csharp %}
public class PlainArgument {
    public int Id { get; }
    public string FirstName { get; }
    public string LastName { get; }
    public string EmailAddress { get; }

    public PlainArgument(int id, string firstName, string lastName, string emailAddress) {
        Id = id;
        FirstName = firstName;
        LastName = lastName;
        EmailAddress = emailAddress;
    }
}

public interface IFooService {
    void DoStuff(object argument);
}

[Fact]
public void Checking_argument_using_Arg_Is() {
    // Act
    _component.DoStuff();

    // Assert
    _fooService.Received()
        .DoStuff(Arg.Is<PlainArgument>(
            e => e.Id == 9 &&
                 e.FirstName == "jan" &&
                 e.LastName == "kowalski" &&
                 e.EmailAddress == "jan.kowalski@gmail.com"
                 ));
}
{% endhighlight %}
When the argument passed to the checked method
was in an unexpected state (e.g. first name was not "jan" but "john"),
we get an error message similar to (formatting added):
{% highlight nohighlight %}
Expected to receive a call matching:
    DoStuff(e => ((((e.Id == 9) AndAlso 
        (e.FirstName == "jan")) AndAlso 
        (e.LastName == "kowalski")) AndAlso 
        (e.EmailAddress == "jan.kowalski@gmail.com")))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*PlainArgument*)
{% endhighlight %}
This error message is terrible.
It contains a lot of informations that are easily obtainable by looking at the
test method's source code. Yet it does not contain
the most important piece of information that we need: which properties 
have unexpected values and what these values are. 

We can slightly improve this error message by overloading `ToString` method
on `PlainArgument` class. 
Let's call this new class `StringableArgument`:
{% highlight csharp %}
public class StringableArgument {
    // the same code as in PlainArgument
    public override string ToString()
        => $"{nameof(StringableArgument)}(id: {Id}, firstName: \"{FirstName}\", " +
            $"lastName: \"{LastName}\", emailAddres: \"{EmailAddress}\")";
}

// in a test method:
_fooService.Received()
    .DoStuff(Arg.Is<StringableArgument>(
        e => e.Id == 9 &&
             e.FirstName == "jan" &&
             e.LastName == "kowalski" &&
             e.EmailAddress == "jan.kowalski@gmail.com"
             ));
{% endhighlight %}
Now the error message looks similar to (formatting added):
{% highlight nohighlight %}
Expected to receive a call matching:
    DoStuff(e => ((((e.Id == 9) AndAlso 
        (e.FirstName == "jan")) AndAlso 
        (e.LastName == "kowalski")) AndAlso 
        (e.EmailAddress == "jan.kowalski@gmail.com")))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*StringableArgument(
        id: 7, firstName: "john", 
        lastName: "doe", 
        emailAddres: "john.doe@gmail.com")*)
{% endhighlight %}
This is better than before. 
Now we can see both expected and actual values of the 
matched argument's properties.

One drawback of this approach is that 
the quality of the error message depends on the quality of
`ToString` implementation. 
If we are using AOP solution like
[Fody](https://github.com/Fody/Fody) to generate `ToString` implementations
for most of our classes, then this solution may be good enough. 
On the other hand if we are generating and updating our `ToString` methods
manually (even if this means pressing a shortcut in our IDE)
then I would prefer to look for a better solution that is totally automatic.

There is also another problem that we were ignoring so far.
Consider what will happen if we add a new field to our `StringableArgument`
class. 
Because we are using property access syntax inside of a lambda expression,
our existing matchers will not only compile without any problems when
we add a new field, they will also pass!
In order to ensure that our matchers and tests remain valid,
we must go through all argument matchers 
for `StringableArgument` class and make sure that they use 
the newly added field.

The above problem may be solved by moving equality checking
to the `StringableArgument` class itself. 
Let's call this new class `EquotableArgument`:
{% highlight csharp %}
public class EquotableArgument : IEquatable<EquotableArgument> {
    public int Id { get; }
    public string FirstName { get; }
    public string LastName { get; }
    public string EmailAddress { get; }

    public EquotableArgument(int id, string firstName, string lastName, string emailAddress) {
        Id = id;
        FirstName = firstName;
        LastName = lastName;
        EmailAddress = emailAddress;
    }

    public override string ToString()
        => $"{nameof(StringableArgument)}(id: {Id}, firstName: \"{FirstName}\", " +
            $"lastName: \"{LastName}\", emailAddres: \"{EmailAddress}\")";

    public bool Equals(EquotableArgument other) {
        if (other is null) return false;

        return ToTuple(this) == ToTuple(other);
    }

    public override bool Equals(object obj) {
        if (obj is EquotableArgument other) {
            return Equals(other);
        }

        return false;
    }

    public override int GetHashCode()
        => ToTuple(this).GetHashCode();

    private static (int, string, string, string) ToTuple(EquotableArgument arg) {
        return (arg.Id, arg.FirstName, arg.LastName, arg.EmailAddress);
    }
}

// in a test method:
_fooService.Received()
    // NOTICE: We no longer use a lambda expression.
    .DoStuff(Arg.Is(new EquotableArgument(
        id: 9, 
        firstName: "jan", 
        lastName: "kowalski",
        emailAddress: "jan.kowalski@gmail.com")));
{% endhighlight %}
With this solution it is impossible to forget to update our matchers
when we add a new field.
We also get a slightly better error message (formatting added):
{% highlight nohighlight %}
Expected to receive a call matching:
    DoStuff(StringableArgument(
        id: 9, firstName: "jan", 
        lastName: "kowalski", 
        emailAddres: "jan.kowalski@gmail.com"))
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments 
indicated with '*' characters):
    DoStuff(*StringableArgument(
        id: 7, firstName: "john", 
        lastName: "doe", 
        emailAddres: "john.doe@gmail.com")*)
{% endhighlight %}

So far so good. But what if our argument has ten or more properties.
With complex arguments looking for a one property with
unexpected value may quickly change into "Where's Wally?" game.
The only way to further improve error messages is to stop relaying on
NSubstitute/hand-carfted `Equals` implementation 
and instead to use specialized assertion library like
[FluentAssertions](https://fluentassertions.com/) or
[NFluent](http://www.n-fluent.net/).

Here is how our test would look like if we decide to use FluentAssertions:
{% highlight csharp %}
[Fact]
public void Catching_argument_and_checking_manually_with_fluent_assertions() {
    // Arrange
    PlainArgument arg = null;

    _fooService
        .DoStuff(Arg.Do<PlainArgument>(x => arg = x));

    // Act
    _component.DoStuff();

    // Assert
    _fooService.Received()
        .DoStuff(Arg.Any<PlainArgument>());

    arg.Should()
        .BeEquivalentTo(new PlainArgument(
            id: 11, 
            firstName: "jan", 
            lastName: "kowlaski", 
            emailAddress: "jan.kowalski@gmail.com"));        
}
{% endhighlight %}
The error message is:
{% highlight nohighlight %}
Expected member Id to be 11, but found 7.
Expected member FirstName to be "jan" with a length of 3, but "john" has a length of 4, differs near "ohn" (index 1).
Expected member LastName to be "kowlaski" with a length of 8, but "doe" has a length of 3, differs near "doe" (index 0).
Expected member EmailAddress to be 
"jan.kowalski@gmail.com" with a length of 22, but 
"john.doe@gmail.com" has a length of 18, differs near "ohn" (index 1).

With configuration:
// (skipped)
// Here FluentAssertions describes configuration
// that it used to compare the two objects.
{% endhighlight %}
Not bad, I must say. We get a list of only these properties that have
unexpected values. Certain messages seem a little bit too verbose for me
e.g. `Expected member FirstName to be "jan" with a length of 3`,
 `but "john" has a length of 4, differs near "ohn" (index 1).`
Maybe `Expected FirstName to be "jan" but was "john".` would be
just enough?
Still it is the best solution that we have so far.

The only downside that I see 
is that the test code is now a little more verbose and less readable.
Mainly because 
we are now responsible for manually capturing argument's value:
{% highlight csharp %}
PlainArgument arg = null;
_fooService
    .DoStuff(Arg.Do<PlainArgument>(x => arg = x));
{% endhighlight %}

With a bit of C\# magic we may make argument capturing less painful:
{% highlight csharp %}
_fooService
    .DoStuff(Capture(out Arg<PlainArgument> arg));

// Act
_component.DoStuff();

// Assert
_fooService.Received()
    .DoStuff(Arg.Any<PlainArgument>());

// This time we use NFluent
Check.That(arg.Value).HasFieldsWithSameValues(
    new PlainArgument(
        id: 7, 
        firstName: "john", 
        lastName: "doe", 
        emailAddress: "john.doe@gmail.com")); 
{% endhighlight %}
To see how it works please check [ArgCapture.cs](https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages/blob/master/Library.Test/ArgCapture.cs) file.

Catching argument's value manually is cumbersome and 
makes tests less readable. On the other hand using some "magical"
syntactic sugar also does not looks like a good idea. 
After all our code should be simple. If we can avoid using "magic"
we should do it!

Our final solution is to create a custom NSubstitute argument matcher.
The matcher uses undercover FluentAssertions library to perform the check.
Here is how the test code looks like with this approach:
{% highlight csharp %}
[Fact]
public void Checking_argument_using_custom_NSubstitute_matcher() {
    // Arrange

    // Act
    _component.DoStuff();

    // Assert
    var expected = new PlainArgument(
        id: 11, 
        firstName: "jan", 
        lastName: "kowlaski", 
        emailAddress: "jan.kowalski@gmail.com");

    _fooService.Received()
        .DoStuff(WithArg.EquivalentTo(expected));
}
{% endhighlight %}
The error message generated for an argument that does
not overload `ToString` looks like this (formatting added):
{% highlight nohighlight %}
Expected to receive a call matching:
    DoStuff(PlainArgument)
Actually received no matching calls.
Received 1 non-matching call (non-matching arguments indicated 
with '*' characters):
    DoStuff(*PlainArgument*)
        arg[0]: Expected member Id to be 11, but found 7.
                Expected member FirstName to be "jan" with a length of 3, 
                but "john" has a length of 4, differs near "ohn" (index 1).
                Expected member LastName to be "kowlaski" with a length of 8, 
                but "doe" has a length of 3, differs near "doe" (index 0).
                Expected member EmailAddress to be 
                "jan.kowalski@gmail.com" with a length of 22, but 
                "john.doe@gmail.com" has a length of 18, differs near "ohn" 
                (index 1).
{% endhighlight %}
It is clear that the problem occurred at the first argument (`arg[0]`). 
Also we can see the actual and expected values of the argument's 
fields and properties.
And the test code is simple and clean.
If you are interested how it is implemented please see
[CustomMatcher.cs](https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages/blob/master/Library.Test/CustomMatcher.cs)
file.

As we can see there exists no perfect solution. Still with a little effort
we can make our error messages much more readable and pleasurable to work with.
I personally suggest to use either the last solution or 
the solution presented in `Catching_argument_and_checking_manually_with_fluent_assertions` test.

Source code and examples: [GitHub](https://github.com/marcin-chwedczuk/blog-nsubstitute-error-messages)


	  ]]></description>
	</item>

	<item>
	  <title>Inheritance? Just say no!</title>
	  <link>//inheritance-just-say-no</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-12-12T01:00:00+01:00</pubDate>
	  <guid>//inheritance-just-say-no</guid>
	  <description><![CDATA[
	     Recently during a code review I have found the following piece
of code:
{% highlight csharp %}
public class TemplateCache 
    : ConcurrentDictionary<TemplateName, Template> { }
{% endhighlight %}
Here the programmer broke one of the most fundamental principles
of modern object oriented programming:

> Prefer composition over inheritance

Why inheritance is bad in most of the cases? Here are the reasons:

###### Watered down component API

What methods would you expect on a cache? Something that gets
values from the cache if they are already there. Let us call 
this operation `TryGetValue(cacheKey, out value)`. 
And of course a method to
add a new or overwrite an existing cache entry, let's call it
`SetValue(cacheKey, value)`. Do we need more methods on a cache
from the client point of view? Maybe in the future we will want to
extend `SetValue` operation to allow client to specify for how
long items added to the cache should be stored? Who knows. 
But still we would end up with only two operations. 

> NOTE A truly generic and reusable cache 
> is usually slightly more complicated - instead of two
> we have three methods! For example please see
> [IMemoryCache](https://github.com/aspnet/Caching/blob/master/src/Microsoft.Extensions.Caching.Abstractions/IMemoryCache.cs) interface.

On the other hand if we use inheritance we end up with something 
like this:
![Cache API when we use inheritance](assets/images/2018-12-12/cache_api.png)
This is much more than we asked for. We actually get operations
that make no sense for a cache like `IsEmpty`. I mean either an item
that we are looking for is in the cache or it is not - who cares
if the cache is empty itself? 

I hope that I managed to persuade you that a good component
API should be small, focused and easy to use. We get none of these 
if we use inheritance.

###### Broken encapsulation

By using inheritance we are making it clear to the clients of
our component that it is implemented using `ConcurrentDictionary` class.
If we wait long enough we will notice that some of them 
will start relaying on that knowledge in their code. 
For example they may use `ContainsKey` method for checking if
the cache contains a given entry. 
What will happen later, when we decide that we want to change 
the cache implementation and use for example 
[IMemoryCache](https://dotnetcoretutorials.com/2017/03/05/using-inmemory-cache-net-core/) instead?
Clients of our component will get angry, because
our new version of the cache  
introduced a breaking change into their code.

Just to sum up: Inheritance both exposes implementation
details of components and makes evolution of their APIs more difficult.

###### Liskov substitution principle is violated 

In short some operations that make sense for a dictionary
may not make sense for a cache. For example it makes no
sense to cache a template that does not exists, yet with
inheritance we may write:

{% highlight csharp %}
var foo = new TemplateName("foo");

ConcurrentDictionary<TemplateName, Template> dict 
   = new TemplateCache();

dict.GetOrAdd(foo, (Template)null);

// Ops we have a null template here...
Console.WriteLine("value is: " + 
   dict.GetOrAdd(foo, (Template)null));
{% endhighlight %}

When we use inheritance we are telling the type system that
`TemplateCache` *is a* `ConcurrentDictionary`. 
From logical point of view this makes no sense. They are two
different components that have two different purposes and also
different usage patterns. 
They should have nothing in common.

> BTW You should avoid putting `null`s into collection classes of any sort.

Let's finish this post by seeing how composition can be used
to improve our `TemplateCache` component:
{% highlight csharp %}
public class TemplateCache {
  private readonly ConcurrentDictionary<TemplateName, Template> _cache 
      = new ConcurrentDictionary<TemplateName, Template>();

  public bool TryGetTemplate(TemplateName name, out Template template)
      => _cache.TryGetValue(name, out template);

  public void AddTemplate(Template template)
      => _cache.AddOrUpdate(
          template.Name, template, (name, existing) => template);
}
{% endhighlight %}
Yep, simple, clean and easy to use!


	  ]]></description>
	</item>

	<item>
	  <title>Abusing local functions to hide design problems</title>
	  <link>//abusing-local-functions-to-hide-design-problems</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-10-08T02:00:00+02:00</pubDate>
	  <guid>//abusing-local-functions-to-hide-design-problems</guid>
	  <description><![CDATA[
	     Recently I was browsing through a certain code base
and I saw a code similar to this:
{% highlight csharp %}
public class EnterpriseNotificationSender {
    private readonly IUserManagementService _userManagementService;
    // ctor and stuff...
  
    public void SendNotificationsToUsers(string companyId) {
        var addresses = GetRecipientsAddresses(companyId);
        foreach(var address in addresses) {
            SendNotification(address);
        }
    }
  
    private IEnumerable<EmailAddress> 
                     GetRecipientsAddresses(string companyId) {
        return _userManagementService
             .FindUsersBelongingToCompany(companyId)
             .Where(UserShouldReciveNotification)
             .Select(user => user.EmailAddress)
             .ToList();
  
        bool UserShouldReciveNotification(User user) {
            return user.EmailAddress != null
                && user.IsRegistered
                && !user.IsDisabled;
        }
    }
  
    private void SendNotification(EmailAddress address) {
        // do stuff...
    }
}
{% endhighlight %}
Especially `GetRecipientsAddresses` method draw my attention.
Someone extracted quite complicated lambda expression
to a local function.
At first I thought that this is indeed a very nice usage for local
functions.
LINQ query is much more readable
with expressions like `Where(UserShouldReciveNotification)`
instead of long lambdas.

It took me a while to realize that the local function
in the code above, was used to hide design problems.
Let's take a closer look at the condition encapsulated by
`UserShouldReciveNotification` function:
{% highlight csharp %}
return user.EmailAddress != null
    && user.IsRegistered
    && !user.IsDisabled;
{% endhighlight %}
We should deal with the simplest to fix problems first:

**Bad naming:** We should always format predicates in "a positive way".
For examples we should prefer `IsOpen` and `IsAvailable` to `IsClose`
and `IsUnavailable`. Here `IsDisabled` should be named `IsEnabled`.
As a first step in refactoring we may add `IsEnabled` property
to the `User` class:
{% highlight csharp %}
public bool IsEnabled => !IsDisabled;
{% endhighlight %}

**Unreadable condition:** If a user has optional email then we may expect
that our codebase is littered with little `user.EmailAddres != null` checks.
To increase readability we should encapsulate this check into a separate property:
{% highlight csharp %}
public bool HasEmailAddress => (EmailAddress != null);
{% endhighlight %}

**Missing entity attributes:** When I looked closely at the condition
`user.IsRegistered && !user.IsDisabled` I found out that it occurs
in many places in that codebase. For some reason the system was creating
users before they actually registered. A user that not registered yet was basically
a stub not a real user. Users could also be disabled by admins (registered or not),
this is what the second part of the condition was responsible for.
Clearly `User` entity is missing an attribute that could tell us whatever
a user is active, so let's add one:
{% highlight csharp %}
public bool IsActive
    => IsRegistered && IsEnabled;
{% endhighlight %}

After all these refactorings we may finally rewrite our LINQ query:
{% highlight csharp %}
return _userManagementService
    .FindUsersBelongingToCompany(companyId)
    .Where(user => user.IsActive)
    .Where(user => user.HasEmailAddress)
    .Select(user => user.EmailAddress)
    .ToList();
{% endhighlight %}
This version is as readable as version with the local function,
but does not attempt to hide code smells.

Conclusion: Every time when you have a too long or too complicated
lambda expression, that you what to extract to a local function,
think if you can simplify that lambda by extracting conditions and checks
into new methods and properties on processed objects.


	  ]]></description>
	</item>

	<item>
	  <title>Avoid hidden coupling to interface implementation</title>
	  <link>//avoid-hidden-coupling-to-interface-implementation</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-09-21T02:00:00+02:00</pubDate>
	  <guid>//avoid-hidden-coupling-to-interface-implementation</guid>
	  <description><![CDATA[
	     A few days ago I was reviewing a pull request at work and
one line of code catch my eye:
{% highlight csharp %}
var @event = new CupOfCoffeeReadyEvent(/* ... */);
_logger.LogInformation(
    "Publishing cup of coffee event: {@Event}.", @event); // <== this one
_mediator.Publish(@event);
{% endhighlight %}
At my workplace we are using standard `ILogger` interface from 
`Microsoft.Extensions.Logging.Abstractions`
package. Also logged variable name starts with `@` (`@event`). 
And so I started to suspect that 
the log statement contains an error and instead it should be written as:
{% highlight csharp %}
// {@Event} -> {Event}
_logger.LogInformation(
    "Publishing cup of coffee event: {Event}.", @event);
{% endhighlight %}
Without thinking any further I put a friendly comment, that 
this logging statement should be fixed.
After half an hour, instead of a fix I get the following response:

> In this microservice we are using Serilog as third-party logging provider.
>
> In Serilog `@` is used as destructuring operator,
> please see: 
> https://github.com/serilog/serilog/wiki/Structured-Data#preserving-object-structure
>
> Basically this means that the argument will be logged in JSON form.

So `@` character was put there on purpose. OK, fine.
But there still was something fishy about this code. 
On the one hand we are using `ILogger` from 
`Microsoft.Extensions.Logging.Abstractions` to decouple ourselves 
from any specific logging provider,
on the other hand we are using Serilog specific extensions.
This results in a false sense of security. 
We may think that since we are
using standard `ILogger`, changing logging provider to e.g.
Azure Web App Diagnostics would be as simple as changing `Startup` 
class of our application.
Unfortunately since we coupled ourselves with Serilog 
(by Serilog specific extensions to the log message template),
some of our log statements may not work with the new logging provider.

So what is the solution to this problem? We must choose whatever we
want to use Serilog specific features. If we want to use them, then 
we should not hide the fact that we are using Serilog. Fortunately for
us Serilog provides it's own, ready to use `ILogger` interface.
And we should use that interface instead of standard one accross
the entire application.

On the other hand, if we expect that we may need to change logging
provider in the future, we should stick with 
`Microsoft.Extensions.Logging.Abstractions` `ILogger` and we should
use only the features that are described in 
[the official documentation](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.1). 
If our needs are not fully covered
by the standard `ILogger` 
e.g. we must log objects as JSON, then we must implement them
ourselves by e.g. creating wrappers around parameters:
{% highlight csharp %}
_logger.LogInformation(
    "Publishing cup of coffee {Event}.", new LogAsJson(@event));
{% endhighlight %}

It is really interesting that a similar coupling happens when using
`IEnumerable<T>` interface as the return type of a method.
How many times have you seen a code similar to:
{% highlight csharp %}
public void SomeMethod() {
    // IEnumerable<User>
    var users = userService.FindAllUsers();
    
    users
        .ToList()
        .ForEach(user => user.IsActive = false);
    
    userService.SaveAll(users.ToArray());
}
class UserSerivce {
    public IEnumerable<User> FindAllUsers() {
        return new List<User> {
            new User { IsActive = true },
            new User { IsActive = false }
        };
    }
    public void SaveAll(params User[] users) {
        foreach (var user in users) {
            Console.WriteLine(user.IsActive);
        }
    }
}
public class User {
    public bool IsActive { get; set; }
}
{% endhighlight %}
Again we have here a bad case of hidden coupling to the interface implementation.
We are using `IEnumerable<T>`
interface but we are assuming that it is backed by
a collection for which multiple enumerations always
return the same elements. 
Our code will break 
when someone will change `FindAllUsers` implementation to
e.g.:
{% highlight csharp %}
public IEnumerable<User> FindAllUsers() {
    yield return new User { IsActive = true };
    yield return new User { IsActive = false };
}
{% endhighlight %}

The solution to this problem is honesty. If you have
a value of type `IEnumerable<T>`, tread it as 
a value of type `IEnumerable<T>`. Nothing more, nothing less.
Do not assume that multiple enumerations
will return the same elements. 
This is not guaranteed by that interface.

If you want to return a sequence of elements from a method with
this additional guarantee, then please use a more specific 
interface like `ICollection<T>` or `IReadOnlyList<T>` or 
maybe even something from `System.Collections.Immutable` package.



	  ]]></description>
	</item>

	<item>
	  <title>Fluent Validation and complex dependencies between properties</title>
	  <link>//fluent-validation-and-complex-dependencies-between-properties</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-09-18T02:00:00+02:00</pubDate>
	  <guid>//fluent-validation-and-complex-dependencies-between-properties</guid>
	  <description><![CDATA[
	     [FluentValidation](https://fluentvalidation.net/) is one of the
best validation libraries for .NET. I use it daily both at work
and in my personal pet projects. Still from time to time I
encounter situations where it is not obvious how 
I should use FluentValidation.
In this blog post I describe one such situation that I have to
deal with recently.

In short I had to validate a simple DTO:
{% highlight csharp %}
public class SampleRequestDto {
    public AddressDto Address { get; set; }
    public ContactInfoDto ContactInfo { get; set; }
}

public class AddressDto {
    public string AddressLine1 { get; set; }
    public string AddressLine2 { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
    public string CountryIsoCode { get; set; }
}

public class ContactInfoDto {
    public string EmailAddress { get; set; }
    // Phone number validation depends on CountryIsoCode.
    public string PhoneNumber { get; set; }
}
{% endhighlight %}
With a small twist that `ContactInfo.PhoneNumber` was 
validated using country dependent format and information
about country itself was stored in `Address.CountryIsoCode` field.

This is generally a good use-case for FluentValidation `Custom` rule:
{% highlight csharp %}
RuleFor(x => x)
    .Custom((dto, context) => {
        var countryIsoCode = dto?.Address?.CountryIsoCode;
        if (string.IsNullOrEmpty(countryIsoCode)) 
            return;

        var country = Countries.FindCountryByIsoCode(countryIsoCode);
        // invalid country code - cannot validate phone number
        if (country == null)
            return;

        var phoneNumber = dto?.ContactInfo?.PhoneNumber;
        if (string.IsNullOrWhiteSpace(phoneNumber))
            return;

        if (!country.PhoneNumberFormat.Matches(phoneNumber)) {
            context.AddFailure(new ValidationFailure(
                $"ContactInfo.PhoneNumber", // property name
                $"'{phoneNumber}' is not a valid phone number in {country.Name}."));
        }
    });

{% endhighlight %}
Unfortunately in my case I also had a bunch of other country dependent 
values like VAT numbers scattered across many DTOs. And I needed
a more reusable and programmer friendly solution than `Custom` rule.

Ideally my validator definition should look like this:
{% highlight csharp %}
public class SampleRequestDtoValidator : AbstractValidator<SampleRequestDto> {
    public  SampleRequestDtoValidator() {
        RuleFor(x => x.Address)
            .SetValidator(new AddressDtoValidator());

        RuleFor(x => x.ContactInfo)
            .SetValidator(new ContactInfoDtoValidator());
    }
}

public class AddressDtoValidator : AbstractValidator<AddressDto> {
    public AddressDtoValidator() {
        RuleFor(x => x.CountryIsoCode)
            .NotEmpty()
            .CountryIsoCode(); // custom extension
        // other rules...
    }
}

public class ContactInfoDtoValidator : AbstractValidator<ContactInfoDto> {
    public ContactInfoDtoValidator() {
        RuleFor(x => x.PhoneNumber)
            .NotEmpty()
            .MaximumLength(50)
            .PhoneNumber(); // custom extension
        // other rules...
    }
}
{% endhighlight %}
Creating property validators like `CountryIsoCode` using FluentValidation
is very simple. You just extend `PropertyValidator` class,
provide an error message template to the base class ctor and override
`IsValid` method. 
Additionally you may define an extension method 
to the `IRuleBuilder<T,TProperty>`
interface to make your validator behave like build-in ones.
{% highlight csharp %}
public class CountryIsoCodeValidator : PropertyValidator {
    public CountryIsoCodeValidator() 
        : base("'{PropertyValue}' is not a valid country iso code.") { }

    protected override bool IsValid(PropertyValidatorContext context) {
        var isoCode = (string) context.PropertyValue;

        if (string.IsNullOrEmpty(isoCode)) {
            return true;
        }

        return Countries.IsKnownIsoCode(isoCode);
    }
}

public static class CountryIsoCodeValidatorExtension {
    public static IRuleBuilderOptions<T, string> CountryIsoCode<T>(
        this IRuleBuilder<T, string> rule
    ) {
        return rule.SetValidator(new CountryIsoCodeValidator());
    }
}
{% endhighlight %}

`CountryCode` validator was easy, what about `PhoneNumber` validator?
Here the only challenge that we must solve 
is finding a way to pass country ISO code from `Address` to 
phone number validator.
To solve this problem I decided to use "advanced" FluentValidation
feature called "Root Context Data". Basically this is a 
`IDictionary<string, object>` that can be prefilled with custom data
before validation starts and then is accessible to every validator
in validators tree.

Let's take a look at an example from 
[official documentation](https://fluentvalidation.net/start#root-context-data):
{% highlight csharp %}
var instanceToValidate = new Person();

var context = new ValidationContext<Person>(person);
context.RootContextData["MyCustomData"] = "Test";

var validator = new PersonValidator();
validator.Validate(context);

// usage inside validator:
RuleFor(x => x.Surname).Custom((x, context) => {
  if(context.ParentContext.RootContextData.ContainsKey("MyCustomData")) {
    context.AddFailure("My error message");
  }
});
{% endhighlight %}
Looks very promising, and what's better we can add values to `RootContextData`
straight inside top-level validators by overriding `PreValidate` method:
{% highlight csharp %}
public class SampleRequestDtoValidator : AbstractValidator<SampleRequestDto> {
    public  SampleRequestDtoValidator() {
        RuleFor(x => x.Address)
            .SetValidator(new AddressDtoValidator());

        RuleFor(x => x.ContactInfo)
            .SetValidator(new ContactInfoDtoValidator());
    }

    protected override bool PreValidate(
        ValidationContext<SampleRequestDto> context, ValidationResult result) 
    {
        var contextData = new ValidationContextData(
            context.RootContextData);

        contextData.CountryIsoCode = 
            context.InstanceToValidate?.Address?.CountryIsoCode;

        return true; // continue validation
    }
}
{% endhighlight %}
To avoid dealing with `object`s I have also created a strongly typed
wrapper (`ValidationContextData` class) around `RootContextData`
dictionary.

IMPORTANT: To make validators reusable you should set `RootContextData` only
in top level validators. Validators used with `SetValidator`
method are not considered top level.

Now implementing `PhoneNumberValidator` is easy:
{% highlight csharp %}
public class PhoneNumberValidator : PropertyValidator {
    public PhoneNumberValidator() 
        : base("'{PropertyValue}' is not a valid phone number in {Country}.") { }

    protected override bool IsValid(PropertyValidatorContext context) {
        var phoneNumber = (string) context.PropertyValue;
        if (string.IsNullOrEmpty(phoneNumber)) {
            return true;
        }

        var contextData = new ValidationContextData(
            context.ParentContext.RootContextData);

        var country = TryFindCountry(contextData.CountryIsoCode);
        if (country == null) {
            // without a country we cannot validate a phone number
            return true;
        }

        context.MessageFormatter.AppendArgument("Country", country.Name);

        return country.PhoneNumberFormat.Matches(phoneNumber);
    }

    private Country TryFindCountry(string countryIsoCode) {
        if (string.IsNullOrEmpty(countryIsoCode)) {
            return null;
        }

        return Countries.FindCountryByIsoCode(countryIsoCode);
    }
}

public static class PhoneNumberValidatorExtension {
    public static IRuleBuilderOptions<T, string> PhoneNumber<T>(
        this IRuleBuilder<T, string> rule
    ) {
        return rule.SetValidator(new PhoneNumberValidator());
    }
}
{% endhighlight %}
And we are done!

#### Unit-testing validators

FluentValidation provides several extension methods that
make unit-testing easy, just take a look:
{% highlight csharp %}
using FluentValidation.TestHelper;

public class SampleRequestDtoValidatorTest {
    private readonly SampleRequestDtoValidator _validator;

    public SampleRequestDtoValidatorTest() {
        _validator = new SampleRequestDtoValidator();
    }

    [Fact]
    public void Should_return_error_when_phone_number_is_invalid_and_countryIsoCode_is_set() {
        // Arrange
        var invalidRequest = 
            SampleRequestDtoFixture.CreateValidRequest();
        invalidRequest.Address.CountryIsoCode = "PL";
        invalidRequest.ContactInfo.PhoneNumber = "+48 123";

        // Assert
        _validator
            .ShouldHaveValidationErrorFor(
                x => x.ContactInfo.PhoneNumber, invalidRequest)
            .WithErrorMessage(
                "'+48 123' is not a valid phone number in Poland.");
    }
}
{% endhighlight %}

#### Design considerations

Everything works right now, but there is still place for improvement.
For example what happens when a programmer forgets to
override `PreValidate` method and set all required properties?
Validation of certain properties will be silently skipped.
This is not good.
To minimize this problem I put additional checks inside `ValidationContextData`
class. They will throw an exception with a descriptive message if
validator tries to access a property that was not previously set.

In my application values like phone numbers are always validated against
country specific formats. But I can imaging situations where
sometimes we use country agnostic phone number validator and
sometimes 
we use country specific one. In such cases it would be good
to call the country agnostic validator just a `PhoneNumberValidator` and
the country specific validator a `CountryDependentPhoneNumberValidator`.

I have a mixed feelings about `ValidationContextData` class because
it is used by every country specific validator in my code. Maybe 
instead of introducing this common dependency every validator should
access `RootContextData` and check if the property is set itself?

Sample source code: [GitHub](https://github.com/marcin-chwedczuk/blog-fluent-validation-adventure).


	  ]]></description>
	</item>

	<item>
	  <title>You can live without mocking frameworks</title>
	  <link>//you-can-live-without-your-mocking-framework</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-09-08T02:00:00+02:00</pubDate>
	  <guid>//you-can-live-without-your-mocking-framework</guid>
	  <description><![CDATA[
	     For a long time I have been fan of mocking frameworks like 
[Moq](https://github.com/Moq/moq4/wiki/Quickstart)
and [NSubstitute](http://nsubstitute.github.io).
These libraries seems indispensable while unit-testing.
They allow us to easily generate subs and mocks and assert that
certain interaction between components took place.

NOTE: If you do not remember difference between stub and mock
please read [this Martin Fowler article](https://martinfowler.com/articles/mocksArentStubs.html). 
In short mocks are used to test interactions between components 
(a method was called, a property was set) 
while stubs are used as dumb implementations of component dependencies 
(they usually either do nothing or provide some preset data).

But recently, after reading volume 1 of 
[Elegant Objects](https://www.yegor256.com/elegant-objects.html)
which by the way I strongly recommend, I changed my mind.
In one of the chapters author presents the idea that every interface
should have an associated fake object. A fake object is a simple
but *working* implementation of an interface and resides in the same
source code file as the interface itself.
Fake objects serve two purposes. First, they are example implementations
of interfaces that show users how the interfaces should be implemented.
And second they can be used as stubs and mocks in unit-tests.

Of course this idea seemed a bit extreme to me, so I decided to go with
a bit more evolutionary approach.
I **slowly** replaced all mock object that I had in my unit-tests 
with fakes (I put all fakes in my unit test projects - but I am still thinking that maybe they deserve a project of their own). 
During this process all interaction testing assertions 
that are usually performed using mocking frameworks
were replaced by behaviour testing assertions on fake objects.

It will be the best to illustrate this process using an example.
Say we have a simple component `EventPublishingComponent` that
publishes two events (order is not important):
{% highlight csharp %}
public class EventPublishingComponent {
    private readonly EventPublisher _eventPublisher;
    public EventPublishingComponent(EventPublisher eventPublisher)
        => _eventPublisher = eventPublisher;

    public async Task Publish() {
        await _eventPublisher.Publish(new FirstEvent(id: 3));
        await _eventPublisher.Publish(
          new SecondEvent(id: "ZDKA9JOPCKXI7"));
    }
}

public class FirstEvent : Event {
    public int Id { get; }
    public FirstEvent(int id)
        => Id = id;
}

public class SecondEvent : Event {
    public string Id { get; }
    public SecondEvent(string id)
        => Id = id;
}

public interface EventPublisher {
    Task Publish(Event @event);
}

public interface Event { }
{% endhighlight %}
A "classic" unit test for this component using NSubstitute 
could look like this:
{% highlight csharp %}
public class EventPublishingComponentTest {
    private readonly EventPublisher _eventPublisher;
    private readonly EventPublishingComponent _component;

    public EventPublishingComponentTest() {
        _eventPublisher = Substitute.For<EventPublisher>();
        _component = new EventPublishingComponent(_eventPublisher);
    }

    [Fact]
    public async Task Should_publish_FirstEvent() {
        // Arrange
        FirstEvent firstEvent = null;
        await _eventPublisher
            .Publish(Arg.Do<FirstEvent>(e => firstEvent = e));

        // Act
        await _component.Publish();

        // Assert
        await _eventPublisher.Received(1)
            .Publish(Arg.Any<FirstEvent>());

        Check.That(firstEvent)
            .IsNotNull();

        Check.That(firstEvent.Id)
            .IsNotZero();
    }
}
{% endhighlight %}
I am sure you have seen a lot of tests like this. 
The key points are: Your create mocks and stubs using your
favourite mocking library in the test constructor or setup method.
In the arrange (given) part of the test you define mocks and stubs
behaviour using library specific syntax. Here e.g. we are capturing
argument passed to `Publish` method for later use:
{% highlight csharp %}
FirstEvent firstEvent = null;
await _eventPublisher
    .Publish(Arg.Do<FirstEvent>(e => firstEvent = e));
{% endhighlight %}
In the assert (then) part of the test we use again library specific
syntax to check that a method on a mock 
was called with given set of arguments.

This approach is fine but it has some disadvantages:

1. It makes your tests very brittle. For example if I add a new method
 on `EventPublisher` called 
 `PublishAll(events)` that allows me to publish all events at once and
 refactor `EventPublishingComponent` to use it
 then `EventPublishingComponent` tests would stop working.
 The main problem here is that my tests check internal interaction
 between components 
 (was method `Publish` called?) instead of checking external behaviour 
 of the system (was event published?).

2. Mocking library is another tool that you must learn. 
 And please remember that most of the developers are not too eager to
 read documentation. Time presumably saved by using mocking library 
 will be lost on reading StackOverflow answers and on fighting with
 the library itself 
 (ever have a problem that your stub does not return intended value?). 

3. It makes your tests less readable. I must admit that 
 NSubstitute is a huge improvement over Moq in terms
 of readability but it still introduces a lot of visual noise in the test
 code. For example do see all 
 those `<`, `>`, `(` and `)` in the code below:

{% highlight csharp %}
FirstEvent firstEvent = null;
await _eventPublisher
    .Publish(Arg.Do<FirstEvent>(e => firstEvent = e));
{% endhighlight %}

Now let us see how our test can look like if we use fakes instead:
{% highlight csharp %}
public class EventPublishingComponentTest_UsingFakes {
    private readonly InMemoryEventPublisher _eventPublisher;
    private readonly EventPublishingComponent _component;

    public EventPublishingComponentTest_UsingFakes() {
        _eventPublisher = new InMemoryEventPublisher();
        _component = new EventPublishingComponent(_eventPublisher);
    }

    [Fact]
    public async Task Should_publish_FirstEvent() {
        // Act
        await _component.Publish();

        // Assert
        var firstEvent = _eventPublisher.PublishedEvents
            .OfType<FirstEvent>()
            .SingleOrDefault();

        Check.That(firstEvent)
            .IsNotNull();

        Check.That(firstEvent.Id)
            .IsNotZero();
    }
}
{% endhighlight %}
To make this test compile we also need to write a fake for 
`EventPublisher` interface. Please keep in mind that fake is a simple
but **working** implementation of the interface:
{% highlight csharp %}
public class InMemoryEventPublisher : EventPublisher {
    private readonly List<Event> _publishedEvents 
      = new List<Event>();

    public IReadOnlyList<Event> PublishedEvents
        => _publishedEvents;

    public Task Publish(Event @event) {
        if (@event == null)
            throw new ArgumentNullException(nameof(@event));

        _publishedEvents.Add(@event);
        return Task.CompletedTask;
    }
}
{% endhighlight %}

I am sure that after seeing both versions of the test 
you agree with me that both are quite short and readable,
yet the second version does not have the earlier mentioned disadvantages.
Now you may rightly say that with the second approach 
you are forced to create fakes for
almost all interfaces in your application. You are right, but
you actually want to create fakes. Here is why:

1. Fakes are like TDD for your interface **design**. By creating a fake
 you actually check how difficult it is for a client 
 of your API to provide an implementation. A fake too big or 
 too difficult to
 implement is a sign that maybe your interface is doing too much.
 Also fakes can be treated as "reference implementations" of interfaces
 and as such they are part of your API documentation.

2. Writing a fake is a one-time effort. After fake is written it can
 be reused across many tests. Compare this with subs and mocks that you
 need to setup every time you want to use them.

Now it is time for a more real world example. 
As you probably heard *Performance is a feature* but logging can 
also be a feature. Imagine an application where we must log
every failed login attempt. Since this is a business requirement
we want to code it as an acceptance test.
How difficult it can be to check that one method call was
performed:
{% highlight csharp %}
logger.LogDebug("User '{userName}' log into application.", "root");
{% endhighlight %}
In practice it can be more difficult than it seems especially if you use
notoriously hard to test `ILogger` from `Microsoft.Extensions.Logging.Abstractions` package.

Why is `ILogger` hard to test? 

1. `ILogger` interface contains only three methods 
 ([source code here](https://github.com/aspnet/Logging/blob/master/src/Microsoft.Extensions.Logging.Abstractions/ILogger.cs))
 rest of its functionality is provided via extension methods.

2. Extension methods that operate on `ILogger` often 
 create wrappers around original 
 arguments using classes like `FormattedLogValues`.
 Most of these wrapper classes does not 
 overload `Equals` and `GetHashCode` rendering
 argument matchers from mocking frameworks useless.

3. No easy access to the logged message.
 Only method responsible for actual logging on `ILogger` interface
 is `Log`:

{% highlight csharp %}
void Log<TState>(
  LogLevel logLevel, 
  EventId eventId, 
  TState state, 
  Exception exception, 
  Func<TState, Exception, string> formatter);
{% endhighlight %}

To gain access to the logged message we must either dig 
into `state` argument
or call `formatter(state, exception)`.

All this causes that naive testing aproachs like this fail:
{% highlight csharp %}
[Fact]
public async Task Naive_test() {
  var logger = Substitute.For<ILogger<SomeClass>>();
      
  logger
    .LogDebug("User '{userName}' log into application.", "root");

  logger.Received()
    .LogDebug("User '{userName}' log into application.", "root");
}
{% endhighlight %}
And how they fail? With confusing error messages like this one:
{% highlight no-highlight %}
Error Message:
 NSubstitute.Exceptions.ReceivedCallsException : 
  Expected to receive a call matching:
  Log<Object>(Debug, 0, User 'root' log into application., <null>, Func<Object, Exception, String>)
Actually received no matching calls.
Received 1 non-matching call 
 (non-matching arguments indicated with '*' characters):
  Log<Object>(Debug, 0, *User 'root' log into application.*, <null>, Func<Object, Exception, String>)
{% endhighlight %}
Not very helpful, isn't it?

If you really want to test `ILogger` using NSubstitute you must
use the following code:
{% highlight csharp %}
var logger = Substitute.For<ILogger<SomeClass>>();

dynamic state = null;
Exception exception = null; 
Func<object, Exception, string> formatter = null;

logger.Log(LogLevel.Debug, 
  Arg.Any<EventId>(), 
  Arg.Do<object>(s => state = s), 
  Arg.Do<Exception>(ex => exception = ex), 
  Arg.Do<Func<object, Exception, string>>(f => formatter = f));

logger
  .LogDebug("User '{userName}' log into application.", "root");

logger.Received(1)
  .Log(LogLevel.Debug, 
      Arg.Any<EventId>(), 
      Arg.Any<object>(), 
      Arg.Any<Exception>(), 
      Arg.Any<Func<object, Exception, string>>());

Check.That(formatter(state, exception))
    .IsEqualIgnoringCase("User 'root' log into application.");
{% endhighlight %}
Did I say something earlier about unreadable tests and a lot of 
visual noise caused by mocking frameworks? Now you can see it with your
own eyes!

Now it is time for our second approach using fakes. First we create
a fake logger:
{% highlight csharp %}
public class InMemoryListOfEntriesLogger : ILogger {
    private readonly List<LogEntry> _loggedEntries 
      = new List<LogEntry>();

    private readonly Dictionary<string, int> _bookmarks 
      = new Dictionary<string, int>();

    public IReadOnlyList<LogEntry> LoggedEntries 
        => _loggedEntries;

    public IDisposable BeginScope<TState>(TState state) {
        // Notice that we do not have to implement
        // all methods for interfaces that are *not
        // part* of our application.
        throw new NotImplementedException();
    }

    public bool IsEnabled(LogLevel logLevel) {
        return true;
    }

    public void Log<TState>(
        LogLevel logLevel, 
        EventId eventId, 
        TState state, 
        Exception exception, 
        Func<TState, Exception, string> formatter) 
    {
        _loggedEntries.Add(
          new LogEntry(
            logLevel, 
            formatter(state, exception), 
            exception));
    }
}

public class LogEntry {
  public LogLevel LogLevel { get; }
  public string Message { get; }
  public Exception Exception { get; }

  public LogEntry(LogLevel logLevel, string message, 
    Exception ex = null) {
      LogLevel = logLevel;
      Message = message;
      Exception = ex;
  }

  public override string ToString()
      => $"{LogLevel}: {Message}" + 
         (Exception != null 
            ? $" Exception: {Exception.GetType().Name}" 
            : "") +
         ".";
}
{% endhighlight %}
Notice that we did not implement all methods of `ILogger` interface.
For external interfaces that are not under our control we should
implement just enough functionality in our fakes to make them usable.

Now it is time for writing actual test:
{% highlight csharp %}
var logger = new InMemoryListOfEntriesLogger();

logger.LogDebug("User '{userName}' log into application.", "root");

Check.That(logger.LoggedEntries)
    .HasElementThatMatches(x => 
        x.Level == LogLevel.Debug &&
        x.Message == "User 'root' log into application.");
{% endhighlight %}
Wow! Test is short, readable and simple. Exactly what I was looking for.

I hope that this blog post persuaded you to start using fakes in your
unit tests. At least you now know that you have a good alternative to
mocking frameworks.

Sample source code (with a bit more complicated example): 
[GitHub](https://github.com/marcin-chwedczuk/blog-fakes-vs-mocks).


	  ]]></description>
	</item>

	<item>
	  <title>.NET Core, HttpClient, Proxy and localhost</title>
	  <link>//dotnet-core-http-client-proxy-and-localhost</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-05-03T02:00:00+02:00</pubDate>
	  <guid>//dotnet-core-http-client-proxy-and-localhost</guid>
	  <description><![CDATA[
	     Recently I wanted to spy network traffic between a `HttpClient` and
a REST service. This task turned out to be more difficult than I
though. 

My first challenge was to force `HttpClient` to use a proxy.
After a bit of googling I have found 
the following code:
{% highlight csharp %}
using System.Net;
using System.Net.Http;

var builder = new ConfigurationBuilder()
	 .SetBasePath(Directory.GetCurrentDirectory())
	 .AddJsonFile("appsettings.json");
var configuration = builder.Build();

var webProxy = new WebProxy(
	 new Uri(configuration["ProxyUri"]), 
	 BypassOnLocal: false);

var proxyHttpClientHandler = new HttpClientHandler {
	 Proxy = webProxy,
	 UseProxy = true,
};

var httpClient = new HttpClient(proxyHttpClientHandler) {
	 BaseAddress = new Uri(configuration["RestServiceUri"])
};
{% endhighlight %}
Unfortunately my REST service was exposed on `localhost`
and later I found out that proxies are not used for local requests:
{% highlight json %}
/* appsettings.json */
{
    "RestServiceUri": "http://localhost:5001/api",
    "ProxyUri": "http://localhost:8080"
}
{% endhighlight %}

OK, no problem I though,
let's just add another DNS alias to localhost - 
just to fool `Uri` class to think 
that we are accessing some other machine.
This can be done by modifying `hosts` file, which
on my Ubuntu machine is located in `/etc` directory:
{% highlight no-highlight %}
127.0.0.1   localhost
127.0.0.2   mymachine
{% endhighlight %}
Then I had to change my `appsettings.json` file:
{% highlight json %}
/* appsettings.json */
{
    "RestServiceUri": "http://mymachine:5001/api",
    "ProxyUri": "http://localhost:8080"
}
{% endhighlight %}
And my REST service configuration so that it will listen for
incoming connections on all interfaces:
{% highlight csharp %}
public static IWebHost BuildWebHost(string[] args) =>
	WebHost.CreateDefaultBuilder(args)
		 .UseStartup<Startup>()
		 .UseUrls("http://0.0.0.0:5001")
		 .Build();
{% endhighlight %}

After all these preparations I was able to intercept traffic
using [ZAP Proxy](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project):
![Intercepted traffix](assets/images/2018-05-03/zap_1.png)

But was this all necessary? Turns out that not really.
You may use your vanilla `HttpClient`:
{% highlight csharp %}
var restServiceUri = new Uri(configuration["RestServiceUri"]);
var httpClient = new HttpClient() {
    BaseAddress = restServiceUri
};
{% endhighlight %}
And then just set `http_proxy` environmental variable to get
exactly the same behaviour (without any need to modify `hosts`, or
to force REST service to listen on all interfaces).
Just run in Bash:
{% highlight no-highlight %}
http_proxy=http://localhost:8080 dotnet run
{% endhighlight %}

Since I don't have any machine with Windows/MacOS I cannot
confirm that it works on all OS'es, but at least it works
on my Ubuntu.


	  ]]></description>
	</item>


</channel>
</rss>

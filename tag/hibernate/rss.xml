<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Introduction to Hibernate embeddable types</title>
	  <link>//introduction-to-hibernate-embeddable-types</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-07-16T02:00:00+02:00</pubDate>
	  <guid>//introduction-to-hibernate-embeddable-types</guid>
	  <description><![CDATA[
	     #### Entities vs Value types

When we create domain model we must deal with two kinds of objects:
entities and value types. Entities represents objects that have some notion of 
identity like person or a vehicle. Person may change name or even sex but we still use
*the same* object to represent that particular person, we only update object attributes
(e.g. even if I change my name I'm still myself).
Entities always have some kind of identifier that allows us to
distinguish them, this may be a 
[surrogate key](https://en.wikipedia.org/wiki/Surrogate_key) like `Long id` or
a [natural key](https://en.wikipedia.org/wiki/Natural_key) 
like national id/social security number in case of person.

The other kind of objects that we encounter in domain model are value types.
Value types represent things like addresses, phone numbers, money amounts, currencies etc.
Value types are immutable and don't need to have any identifier -
two value types are equal if they contents are equal. If we need to update value type
we just create a new instance of value type with updated attributes.

What this have to do with embeddable types?
In most cases embeddable types should be used to represent only value types
of your domain model.  
Now let's see the code!

#### Embeddable in Hibernate

We will start by creating `User` entity that will have two embeddable value types
`PhoneNumber` and `MoneyAmount`:
{% highlight java %}
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue
    private Long id;

    private String username;
    private PhoneNumber contactPhoneNumber;
    private MoneyAmount availableFunds;

    // constructors, getters, setters, methods etc.
}
{% endhighlight %}
We don't need to use any additional annotations to map embeddable types,
we just declare them like any other field. Later we will see that
we may change embeddable type mappings when needed.

Now let's see how `PhoneNumber` value type looks like.
Since it is our first value type I will present entire class: 
{% highlight java %}
@Embeddable
public class PhoneNumber implements Serializable {
    @Column(length = 16, nullable = false)
    private String phoneNumber;

    protected PhoneNumber() { }

    public PhoneNumber(String phoneNumber) {
        // You can add validation here
        this.phoneNumber = Objects.requireNonNull(phoneNumber);
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || !(o instanceof PhoneNumber)) return false;

        PhoneNumber that = (PhoneNumber) o;
        return phoneNumber.equals(that.phoneNumber);
    }

    @Override
    public int hashCode() {
        return phoneNumber.hashCode();
    }

    @Override
    public String toString() {
        return "phone: " + phoneNumber;
    }
}
{% endhighlight %}
First thing we should notice is that `PhoneNumber` instances are immutable.
We can set `phoneNumber` using constructor,
but we cannot change it.
Notice also that we overriden `equals()` and `hashCode()` to
provide value equality - two phone numbers are equal if they string
representations are equal.
To improve debugging experience we also overriden `toString()` method.

The other class `MoneyAmount` looks like this:
{% highlight java %}
@Embeddable
public class MoneyAmount implements Serializable {
    private BigDecimal amount;

    @Column(length = 3, nullable = false)
    private String currency;

    // constructor getters etc.

    public MoneyAmount add(MoneyAmount m) { /* ... */ }
    public MoneyAmount subtract(MoneyAmount m) { /* ... */ }
    public boolean isLessThan(MoneyAmount other) { /* ... */ }

    // equals, hashCode, toString 
}
{% endhighlight %}
Notice that this class provides additional operations like `add()`. 
Because value types are immutable we cannot change already
exiting `MoneyAmount` instance, instead we return a new object that
will represent result of the `add()` operation.

Now let's get to the Hibernate part.
Embeddable types must be marked with 
`@Embeddable` annotation,
they can contain one or more fields and every 
field may carry `@Column` mappings.
Embeddable types may contain other embeddable types,
but they cannot contain `@Id` field.

When Hibernate stores embeddable types in database they are
stored in table of the entity that contains them.
For example for our `User` entity Hibernate will generate table:
{% highlight sql %}
CREATE TABLE users
(
  id bigint NOT NULL, -- User

  amount numeric(19,2), -- MoneyAmount
  currency character varying(3) NOT NULL,

  phonenumber character varying(16) 
        NOT NULL, -- PhoneNumber

  username character varying(255), -- User
  
  CONSTRAINT users_pkey PRIMARY KEY (id)
)
{% endhighlight %}

Sometimes we want to change e.g. one of the column names of the embeddable type 
but only in certain containing type. 
For example let's say that we want to map `PhoneNumber`
in `User` to `phone_number` column. We may do this using `@AttributeOverride` annotation:
{% highlight java %}
public class User {
    // ...

    @AttributeOverrides({
        @AttributeOverride(name = "phoneNumber",
                column = @Column(name = "phone_number", length = 16, nullable = false))
    })
    private PhoneNumber contactPhoneNumber;

    // ...
}
{% endhighlight %}
Unfortunately when we override column attributes we must redefine *all* of them, and
syntax to do so it pretty verbose.

Now it's time to save some ickle embeddables to database:
{% highlight java %}
User bob = new User(
    "bob",
    new PhoneNumber("111-222-333"),
    new MoneyAmount(new BigDecimal(100), "EUR"));

entityManager.persist(bob);
{% endhighlight %}
This operation will result in SQL:
{% highlight sql %}
insert into users
    (amount, currency, phone_number, username, id) 
values
    (100, 'EUR', '111-222-333', 'bob', 1)
{% endhighlight %}

We may also update embeddable type by providing new instance:
{% highlight java %}
public class User {
    // ...
    public void chargeUser(MoneyAmount amount) {
        if (availableFunds.isLessThan(amount))
            throw new IllegalStateException(
                    "User don't have enough money available.");

        availableFunds = availableFunds.subtract(amount);
    }
    // ...
}

User bob = entityManager.find(User.class, 1);

bob.chargeUser(
    new MoneyAmount(new BigDecimal(10), "EUR")
    );
{% endhighlight %}
This will generate `UPDATE`:
{% highlight sql %}
update users 
set
    amount=90.00,
    currency='EUR',
    phone_number='111-222-333',
    username='bob' 
where
    id=1
{% endhighlight %}

##### Embeddable types and nullability

Hibernate stores null embeddable type as `NULL` values in
all embeddable type columns. You can save object with `null`
embeddable type only if all embeddable type columns are nullable.
When you try to do this with embeddable type that contains non-null 
columns Hibernate will throw exception:
{% highlight java %}
Dummy d = new Dummy();
d.setPhoneNumber(null);
entityManager.persist(d);

// at commit:
// ERROR: null value in column "phonenumber" violates not-null constraint
{% endhighlight %}

##### Sharing embeddable types between entities

Embeddable types follow value semantics, this means when we save the same
instance of embeddable type in two different entities and then read back
these entities we will get two *instances* of embeddable type:
{% highlight java %}
PhoneNumber phoneNumber = new PhoneNumber("111-222-333");

Dummy d1 = new Dummy();
d1.setPhoneNumber(phoneNumber);

Dummy d2 = new Dummy();
d2.setPhoneNumber(phoneNumber);

// true
System.out.println(d1.getPhoneNumber() == d2.getPhoneNumber());

entityManager.persist(d1);
entityManager.persist(d2);
entityManager.flush();
entityManager.clear();

d1 = entityManager.find(Dummy.class, d1.getId());
d2 = entityManager.find(Dummy.class, d2.getId());

// false
System.out.println(d1.getPhoneNumber() == d2.getPhoneNumber());

// true
System.out.println(d1.getPhoneNumber().equals(d2.getPhoneNumber()));
{% endhighlight %}
This is generally not a problem because we should compare value types
using `equals()` anyway.

##### Mapping many instances of embeddable type in the same entity

Let's say we want to extend our `User` entity to allow users to provide
second phone number. If we only add second `PhoneNumber` field to the `User` class,
Hibernate will not know how to name columns of the second `PhoneNumber`. 
This will result in the exception:
{% highlight no-highlight %}
org.hibernate.MappingException: 
    Repeated column in mapping for entity: User column: phoneNumber 
{% endhighlight %}
We can easly fix this using `@AttributeOverride` annotation:
{% highlight java %}
public class User {
    // ...
    private PhoneNumber contactPhoneNumber;

    @AttributeOverrides({
            @AttributeOverride(name = "phoneNumber",
                    column = @Column(name = "backup_phone_number", length = 16, nullable = false))
    })
    private PhoneNumber backupPhoneNumber;

    // ...
}
{% endhighlight %}

#### Collections of embeddable types

Embeddable types may be used as collection elements. Let's extend our `User` class
so that user can have any number of phone numbers:
{% highlight java %}
public class User {
    // ...

    @ElementCollection
    @CollectionTable(
            name = "user_phone_numbers",
            joinColumns = @JoinColumn(name = "user_id"))
    private Set<PhoneNumber> phoneNumbers = new HashSet<>();

    public Collection<PhoneNumber> getPhoneNumbers() {
        return Collections.unmodifiableCollection(phoneNumbers);
    }

    public void addPhoneNumber(PhoneNumber number) {
        phoneNumbers.add(number);
    }

    public void removePhoneNumber(PhoneNumber number) {
        phoneNumbers.remove(number);
    }

    // ...
{% endhighlight %}
In this case collection elements are owned by entity class, if entity is removed
all collection elements are removed as well. 
In database this will be represented by two tables:
![How embeddable collections are stored in database](assets/images/2016-07-16/embeddable_collection.png)

Before you start using this method you must know 
how Hibernate will perform inserts/updates. 
Basically Hibernate first will remove all rows associated with given entity
and then will perform many inserts (one insert per one collection element).
This is horrible from performance point of view so use this mapping only with small collections.

Here is a bit of code to illustrate the point:
{% highlight java %}
User b = entityManager.find(User.class, 1);
// user already have one phone number
b.addPhoneNumber(new PhoneNumber("333-555-666"));
{% endhighlight %}
This will result in SQL:
{% highlight sql %}
delete from user_phone_numbers 
where
    user_id=1

insert into user_phone_numbers
    (user_id, phoneNumber) 
values
    (1, '333-555-666')

insert into user_phone_numbers
    (user_id, phoneNumber) 
values
    (1, '111-222-333')
{% endhighlight %}

##### Allowing duplicates in collection

If we want to allow duplicates in embeddable type collection we should map
it as a bag:
{% highlight java %}
@ElementCollection
@CollectionTable(
        name = "user_phone_numbers",
        joinColumns = @JoinColumn(name = "user_id"))
@org.hibernate.annotations.CollectionId(
        columns = @Column(name = "phone_number_id"),
        type = @org.hibernate.annotations.Type(type = "long"),
        generator = "sequence"
)
private Collection<PhoneNumber> phoneNumbers = new ArrayList<>();
{% endhighlight %}
This will result in database schema:
![How embeddable collections are stored in database](assets/images/2016-07-16/embeddable_collection2.png)
Unfortunatelly this will not improve bad performance of embeddable type collections.

You can improve performance a bit (mainly with inserts) using `@OrderColumn` annotation,
more informations can be found in these articles:

* [StackOverflow: strange delete/insert behaviour](http://stackoverflow.com/questions/3742897/hibernate-elementcollection-strange-delete-insert-behavior)
* [How to Optimize Hibernate ElementCollection Statements](https://dzone.com/articles/how-optimize-hibernate)

#### The End

In this blog post I only scratched the surface of the embeddable types, 
there is more to learn about them. If you want to dig deeper I advice reading
great book: [Java Persistence with Hibernate 2nd](https://amzn.com/1617290459).

Thats all for today, thanks for reading!


	  ]]></description>
	</item>

	<item>
	  <title>Mapping class inheritance in Hibernate 5</title>
	  <link>//mapping-inheritance-in-hibernate</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-30T02:00:00+02:00</pubDate>
	  <guid>//mapping-inheritance-in-hibernate</guid>
	  <description><![CDATA[
	     In this post I want to present four basic strategies for mapping class inheritance
in Hibernate:

1. No inheritance - just copy superclass properties to subclasses
2. Table per class hierarchy
3. Table per concrete class
4. Table per every class

#### No inheritance

This strategy is used if we want to share Java code between entity classes.
An example will show us how it works. 
Let's say we want to avoid declaring `id` and `version` fields in every entity
class. 
We can solve this by creating abstract superclass `BaseEntity` that will hold common code
and annotating it with
`@MappedSuperclass` to enable no inheritance strategy.
Here is `BaseEntity` class code:
{% highlight java %}
@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue
    private Long id;

    @Version
    private long version;

    // getters/setters etc.
}
{% endhighlight %}
Now we may create two independent entity classes `User` and `Product` that
will inherit `id` and `version` fields with mappings from `BaseEntity`:
{% highlight java %}
@Entity
@Table(name = "\"user\"")
public class User extends BaseEntity {
    private String username;

    @org.hibernate.annotations.Type(type = "yes_no")
    private boolean isAdmin;

    // constructor/getters/setters etc.
}
{% endhighlight %}
{% highlight java %}
@Entity
public class Product extends BaseEntity {
    public String name;
    public BigDecimal price;

    // constructor/getters/setters etc.
}
{% endhighlight %}
For given classes Hibernate will generate database schema:
![DB Schema generated for User and Product](assets/images/2016-06-30/noinh_1.png)

Since this strategy is used to only share Java code we should not query database
for `BaseEntity` instances. If we do Hibernate will execute many select statements -
one for every class inheriting from `BaseEntity`.
For example:
{% highlight java %}
entityManager.unwrap(Session.class)
        .createCriteria(BaseEntity.class)
        .list();
{% endhighlight %}
Will result in queries:
{% highlight sql %}
select
    this_.id as id1_0_0_,
    this_.version as version2_0_0_,
    this_.name as name3_0_0_,
    this_.price as price4_0_0_ 
from
    product this_

select
    this_.id as id1_1_0_,
    this_.version as version2_1_0_,
    this_.isAdmin as isAdmin3_1_0_,
    this_.username as username4_1_0_ 
from
    "user" this_
{% endhighlight %}
NOTE: Querying for `BaseEntity` via JPA will throw exception with message
`Not an entity: class BaseEntity`. We
can query for `BaseEntity` only via Hibernate `Session` object.

We will use our `BaseEntity` class in the example code of the remaining strategies to show that
it can be mixed with "real" ORM inheritance.

#### Table per class hierarchy

In this strategy all subclasses data will be stored in single table.
A special column called discriminator is added to that table
to help Hibernate know which subclass is stored in given row.

An example will show how it works. We start by creating a superclass called `Animal`:
{% highlight java %}
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "animal_type")
public abstract class Animal extends BaseEntity {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
{% endhighlight %}
And two subclasses `Cat` and `Dog`:
{% highlight java %}
@Entity
@DiscriminatorValue("cat")
public class Cat extends Animal {
    private boolean isPurring;

    // getters/setter etc.
}
{% endhighlight %}
{% highlight java %}
@Entity
@DiscriminatorValue("dog")
public class Dog extends Animal {
    private boolean isBarking;

    // getters/setter etc.
}
{% endhighlight %}

To enable table per hierarchy strategy, superclass must be marked as `@Entity` and must have
`@Inheritance(strategy = InheritanceType.SINGLE_TABLE)` annotation.
We can choose discriminator column name and type using `@DiscriminatorColumn` annotation.
Subclasses must be marked as `@Entity` and can provide values for 
discriminator column via `@DiscriminatorValue` annotation (discriminator value defaults to class name).

For this example Hibernate will generate schema:
![Schema generated by Hibernate](assets/images/2016-06-30/single_1.png)

Let's save some data:
{% highlight java %}
Cat cat = new Cat();
cat.setName("kitty");
cat.setPurring(true);
entityManager.persist(cat);

Dog dog = new Dog();
dog.setName("barky");
dog.setBarking(false);
entityManager.persist(dog);
{% endhighlight %}
And check how they are stored in database:
![Data stored in database](assets/images/2016-06-30/single_2.png)

Saving was easy, now let's check querying. We start
by getting all `Animal` instances from database:
{% highlight java %}
entityManager.createQuery("from Animal")
        .getResultList()
        .forEach(a -> System.out.println(a));
{% endhighlight %}
This will result in SQL query:
{% highlight sql %}
select
    animal0_.id as id2_0_,
    animal0_.version as version3_0_,
    animal0_.name as name4_0_,
    animal0_.isBarking as isBarkin5_0_,
    animal0_.isPurring as isPurrin6_0_,
    animal0_.animal_type as animal_t1_0_ 
from
    Animal animal0_
{% endhighlight %}
With this strategy we may also query specific animal types e.g. cats:
{% highlight java %}
entityManager.createQuery(
    "select c from Cat c where c.isPurring = true")
{% endhighlight %}
This will result in the following SQL:
{% highlight sql %}
select
    cat0_.id as id2_0_,
    cat0_.version as version3_0_,
    cat0_.name as name4_0_,
    cat0_.isPurring as isPurrin6_0_ 
from
    Animal cat0_ 
where
    cat0_.animal_type='cat' 
    and cat0_.isPurring=true
{% endhighlight %}
We can see that Hibernate added test for discriminator column `animal_type='cat'` to
limit returned animals to cats only.

Before we move to next strategy let's 
see what are pros and cons of table per hierarchy strategy:

| pros |
| ----- |
| Fast - no joins are needed to retrieve data |
| Simple - only single table is needed in database |

| cons |
| ---- |
| Cannot create constrains in database - all columns representing subclass data must be nullable. This is serious drawback because without constrains data can be easily corrupted by application bug or by inattentive users |
| Wasted space - when subclasses have many fields shared table will contain many columns most of which will contain `NULL`s |


#### Table per concrete class

This inheritance strategy will generate database table per each concrete class in 
the hierarchy. Let's demonstrate on example. 
Given classes (abstract classes are in the blue boxes):
![UML diagram of classes used in this example](assets/images/2016-06-30/tpcc_1.svg)
This strategy will generate tables for `Dog`, `GrumpyCat` and `Kitten` classes.

Here is code for all classes used in this example:
{% highlight java %}

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Animal extends BaseEntity {
    private String name;
    // ...
}

@Entity
public class Dog extends Animal {
    private boolean isBarking;
    // ...
}

@Entity
public abstract class AbstractCat extends Animal {
    private boolean isPurring;
    // ...
}

@Entity
public class GrumpyCat extends AbstractCat {
    private int grumpiness;
    // ...
}

@Entity
public class Kitten extends AbstractCat {
    public int sweetness;
    // ...
}
{% endhighlight %}
To enable table per concrete class strategy, root of the inheritance hierarchy must
be marked as `@Entity` and must have `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`
annotation. All subclasses (even abstract ones) must be marked as `@Entity`. Abstract classes
will not be represented in database.

For our `Animal` example Hibernate will generate database schema:
![Schema generated by Hibernate for our animal example](assets/images/2016-06-30/tpcc_2.png)

When we query for all instances of `Animal`:
{% highlight java %}
entityManager.createQuery("from Animal")
        .getResultList();
{% endhighlight %}
Hibernate uses SQL subquery and `union all` operator to gather rows from
all tables containing subclasses data. To differentiate between subclasses
in the result set, Hibernate adds special column `clazz_` that will contain different numbers
for different subclasses:
{% highlight sql %}
select
        animal0_.id as id1_1_, animal0_.version as version2_1_, animal0_.name as name3_1_, animal0_.isBarking as isBarkin1_2_, animal0_.isPurring as isPurrin1_0_, animal0_.grumpiness as grumpine1_3_, animal0_.sweetness as sweetnes1_4_, 
        animal0_.clazz_ as clazz_ 
    from
        ( select
            id, version, name, null::boolean as isBarking, isPurring, grumpiness, null::int4 as sweetness, 
            3 as clazz_ 
        from
            GrumpyCat 

        union all 
        
        select
            id, version, name, null::boolean as isBarking, isPurring, null::int4 as grumpiness, sweetness, 
            4 as clazz_ 
        from
            Kitten
        
        union all 

        select
            id, version, name, isBarking, null::boolean as isPurring, null::int4 as grumpiness, null::int4 as sweetness, 
            1 as clazz_ 
        from
            Dog 
    ) animal0_
{% endhighlight %}

When we query for one of the concrete subclasses Hibernate will directly query
table containing that subclass data. For example:
{% highlight java %}
entityManager.createQuery(
        "select gc from GrumpyCat gc where gc.grumpiness > 0"
    ).getResultList()
{% endhighlight %}
Will generate SQL query:
{% highlight sql %}
select
    grumpycat0_.id as id1_1_,
    grumpycat0_.version as version2_1_,
    grumpycat0_.name as name3_1_,
    grumpycat0_.isPurring as isPurrin1_0_,
    grumpycat0_.grumpiness as grumpine1_3_ 
from
    GrumpyCat grumpycat0_ 
where
    grumpycat0_.grumpiness>0
{% endhighlight %}

Before we move to the next strategy let's consider one more example. Say
we want to store photos of animals using `Photo` entity:
{% highlight java %}
@Entity
public class Photo extends BaseEntity {
    @ManyToOne
    private Animal animal;

    private String photoFilename;

    // ...
}
{% endhighlight %}
For this class Hibernate will generate table:
{% highlight sql %}
CREATE TABLE photo
(
  id bigint NOT NULL,
  version bigint NOT NULL,
  photofilename character varying(255),
  animal_id bigint,

  CONSTRAINT photo_pkey PRIMARY KEY (id)
)
{% endhighlight %}
This time I used SQL instead of table picture to show an important fact.
Do you see `animal_id` column in that table, it will be used to
connect photos to animals. Unfortunately because various types of  animals are
stored in different tables we cannot create foreign key constraint on
that column, this is serious drawback of table per concrete class strategy.

When we query for all photos with animals:
{% highlight java %}
entityManager.createQuery(
        "select p from Photo p join fetch p.animal"
    ).getResultList()
{% endhighlight %}
Hibernate will execute this monstrous query:
{% highlight sql %}
select
    photo0_.id as id1_5_0_, animal1_.id as id1_1_1_, photo0_.version as version2_5_0_, photo0_.animal_id as animal_i4_5_0_, photo0_.photoFilename as photoFil3_5_0_, animal1_.version as version2_1_1_, animal1_.name as name3_1_1_, animal1_.isBarking as isBarkin1_2_1_, animal1_.isPurring as isPurrin1_0_1_, animal1_.grumpiness as grumpine1_3_1_, animal1_.sweetness as sweetnes1_4_1_, animal1_.clazz_ as clazz_1_ 
from
    Photo photo0_ 
inner join
    (
        select
            id, version, name, null::boolean as isBarking, isPurring, grumpiness, null::int4 as sweetness, 3 as clazz_ 
        from
            GrumpyCat 
        union
        all select
            id, version, name, null::boolean as isBarking, isPurring, null::int4 as grumpiness, sweetness, 4 as clazz_ 
        from
            Kitten 
        union
        all select
            id, version, name, isBarking, null::boolean as isPurring, null::int4 as grumpiness, null::int4 as sweetness, 1 as clazz_ 
        from
            Dog 
    ) animal1_ 
        on photo0_.animal_id=animal1_.id
{% endhighlight %}
I only add that complicated queries like this may cause serious performance problems.

To sum up here are pros and cons of table per concrete class strategy:

| pros |
| ----- |
| Constraint friendly - You can introduce separate database constrains for each concrete subclass |
| Fast when querying concrete subclasses (queries directly access subclass table) |

| cons |
| ---- |
| May be slow when you query/lazy load abstract superclasses (`union all` and subquery) |
| Cannot introduce foreign key constrains for superclasses references (like in `Photo` example) |

As you see when you are not using references to superclasses in your model this is
strategy to go. When you have many references to superclasses it is better to use
single table or table per every class strategies.

#### Table per every class

To demonstrate table per every class strategy we'll use the same example
that was used in the 
description of table per concrete class strategy:
![UML diagram of classes used in this example](assets/images/2016-06-30/tpcc_1.svg)

Here are Java classes annotated to use table per every class strategy:
{% highlight java %}
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Animal extends BaseEntity {
    private String name;
    // ...
}

@Entity
@PrimaryKeyJoinColumn(name = "cat_id")
public abstract class AbstractCat extends Animal {
    private boolean isPurring;
    // ...
}

@Entity
public class GrumpyCat extends AbstractCat {
    private int grumpiness;
    // ...
}

@Entity
public class Kitten extends AbstractCat {
    public int sweetness;
    // ...
}

@Entity
@PrimaryKeyJoinColumn(name = "dog_id")
public class Dog extends Animal {
    private boolean isBarking;
    // ...
}
{% endhighlight %}
Notice that every class is marked as `@Entity` and root of inheritance hierarchy is
annotated with `@Inheritance(strategy = InheritanceType.JOINED)`. By default
primary keys in tables corresponding to mapped classes will be named `id`. Sometimes
it is useful to change name of the primary key column, we can use
`@PrimaryKeyJoinColumn(name = "primary_key_name")` to provide new primary key column name.

For given example Hibernate will generate database schema:
![DB Schema generated for table per every class strategy](assets/images/2016-06-30/tpec_1.png)
Notice that Hibernate generated table per every class in the hierarchy. Lines between tables
represent foreign key constrains inside database. 

In table per every class strategy data from 
superclasses will be stored in dedicated tables, SQL joins will be used
to gather entity data from all superclasses. When we add new entity to database Hibernate will
split it according to inheritance hierarchy and will execute many inserts.
An example will help us understand how it works.

First let's try to insert some grumpy animals into database:
{% highlight java %}
GrumpyCat cat = new GrumpyCat();
cat.setName("grumpy");
cat.setPurring(true);
cat.setGrumpiness(130);

entityManager.persist(cat);
{% endhighlight %}
To save single `GrumpyCat` entity to database Hibernate must generate three inserts:
{% highlight sql %}
insert into
    Animal
    (version, name, id) 
values
    (0, 'grumpy', 1)

insert into
    AbstractCat
    (isPurring, cat_id) 
values
    (true, 1)

insert into
    GrumpyCat
    (grumpiness, cat_id) 
values
    (130, 1)
{% endhighlight %}

Let's see what will happen when we try to load all `GrupyCat`s from database:
{% highlight java %}
entityManager
        .createQuery("from GrumpyCat")
        .getResultList()
{% endhighlight %}
Hibernate will execute following SQL query:
{% highlight sql %}
select
    grumpycat0_.cat_id as id1_1_,
    grumpycat0_2_.version as version2_1_,
    grumpycat0_2_.name as name3_1_,
    grumpycat0_1_.isPurring as isPurrin1_0_,
    grumpycat0_.grumpiness as grumpine1_3_ 
from
    GrumpyCat grumpycat0_ 
inner join
    AbstractCat grumpycat0_1_ 
        on grumpycat0_.cat_id=grumpycat0_1_.cat_id 
inner join
    Animal grumpycat0_2_ 
        on grumpycat0_.cat_id=grumpycat0_2_.id
{% endhighlight %}
As we can see Hibernate used `inner join`s to gather `GrumpyCat` data
that was split into `GrumpyCat`, `AbstractCat` and `Animal` tables.
If we would query for `Animal`s there would be ever more `join`s.

Now let's see how storing/retrieving animal photos changed in table
per every class strategy. We will use the same `Photo` class as in previous example:
{% highlight java %}
@Entity
public class Photo extends BaseEntity {
    @ManyToOne
    private Animal animal;

    private String photoFilename;
    // ...
}
{% endhighlight %}
First we must notice that `Photo` table now has a foreign key constrain to `Animal` table:
{% highlight sql %}
CREATE TABLE photo
(
  id bigint NOT NULL,
  version bigint NOT NULL,
  photofilename character varying(255),
  animal_id bigint,
  CONSTRAINT photo_pkey PRIMARY KEY (id),

  CONSTRAINT fk6mbbc9717gifwpiqhd13t060r FOREIGN KEY (animal_id)
      REFERENCES animal (id) MATCH SIMPLE
)
{% endhighlight %}

When we try to query database for all photos with animals:
{% highlight java %}
entityManager.createQuery(
        "select p from Photo p join fetch p.animal"
    ).getResultList()
{% endhighlight %}
Hibernate will execute query:
{% highlight sql %}
select
    photo0_.id as id1_5_0_, animal1_.id as id1_1_1_, photo0_.version as version2_5_0_, photo0_.animal_id as animal_i4_5_0_, photo0_.photoFilename as photoFil3_5_0_, animal1_.version as version2_1_1_, animal1_.name as name3_1_1_, animal1_1_.isBarking as isBarkin1_2_1_, animal1_2_.isPurring as isPurrin1_0_1_, animal1_3_.grumpiness as grumpine1_3_1_, animal1_4_.sweetness as sweetnes1_4_1_,
    case 
        when animal1_3_.cat_id is not null then 3 
        when animal1_4_.cat_id is not null then 4 
        when animal1_1_.dog_id is not null then 1 
        when animal1_2_.cat_id is not null then 2 
        when animal1_.id is not null then 0 
    end as clazz_1_ 
from
    Photo photo0_ 
inner join
    Animal animal1_ 
        on photo0_.animal_id=animal1_.id 
left outer join
    Dog animal1_1_ 
        on animal1_.id=animal1_1_.dog_id 
left outer join
    AbstractCat animal1_2_ 
        on animal1_.id=animal1_2_.cat_id 
left outer join
    GrumpyCat animal1_3_ 
        on animal1_.id=animal1_3_.cat_id 
left outer join
    Kitten animal1_4_ 
        on animal1_.id=animal1_4_.cat_id
{% endhighlight %}
This is really heavy query if plenty of `join`s, it may cause some performance problems.

Let's end by presenting pros and cons of table per every class strategy:

| pros |
| ----- |
| Constraint friendly - we may easily add constrains to database. References to superclasses are guarded by foreign key constrains. |

| cons |
| ---- |
| Poor performance - simple operations like saving entity to database or reading entity from database often require many SQL statements or complicated SQL queries with joins |

Before using this strategy you should consider using simpler and faster 
table per hierarchy strategy. Use this strategy only if you have many subclasses that define
many fields that cannot by shared using superclass.

#### The End

That was really long post, I hope it help you understand various inheritance strategies
that we can use in Hibernate. As always with ORM's the key to master this material is
to spend few hours creating dummy models with mappings and checking what queries Hibernate
generate.
![Party over meme](assets/images/2016-06-30/grumpy.gif)



	  ]]></description>
	</item>

	<item>
	  <title>Hibernate hello world application</title>
	  <link>//hibernate-hello-world-app</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-22T02:00:00+02:00</pubDate>
	  <guid>//hibernate-hello-world-app</guid>
	  <description><![CDATA[
	     In this tutorial we'll create minimal application that will allow us 
to start playing with Hibernate ORM. I will present two hello world's one for
vanilla Hibernate and one for Hibernate via JPA [(Java Persistence API)](http://stackoverflow.com/questions/9881611/whats-the-difference-between-jpa-and-hibernate).  
We will use:

* Java 8 (with new `java.time` date time API)
* Hibernate 5
* [Maven](https://maven.apache.org/) as build tool
* [Log4j](https://logging.apache.org/log4j/1.2) to log executed SQL queries 

There is one more thing before we start - we need to setup database. I assume 
that you will be using PostgreSQL but you should have no trouble using
this tutorial with other databases like MySQL. Here are PostgreSQL 
installation instructions [for Windows](http://www.postgresqltutorial.com/install-postgresql/) 
and [for Ubuntu](http://www.indjango.com/ubuntu-install-postgresql-and-pgadmin/). 
If you are Linux user and you feel adventureous you may try to
[run PostgreSQL inside Docker container](https://github.com/sameersbn/docker-postgresql).

One more thing if you decided to install PostgreSQL don't forget to install
[pgAdmin](https://www.pgadmin.org/download/), this is great tool that helps you
manage your database:
![pgAdmin GUI](assets/images/2016-06-22/pgadmin_gui.png)

#### Common steps

##### Prepare Maven Project

Let's start with generating project structure using Maven:
{% highlight no-highlight %}
$ cd where/to/put/my/project/code

$ mvn archetype:generate -DgroupId=mc.hibernatetutorial \
-DartifactId=hibernateTutorial \
-DarchetypeArtifactId=maven-archetype-quickstart \
-DinteractiveMode=false
{% endhighlight %}
This will generate folder structure:
{% highlight no-highlight %}
$ tree hibernateTutorial/

hibernateTutorial/
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `-- mc
    |           `-- hibernatetutorial
    |               `-- App.java
    `-- test
        `-- java
            `-- mc
                `-- hibernatetutorial
                    `-- AppTest.java

{% endhighlight %}
Next we will need to create `resources` directory to hold Hibernate and Log4j configuration
files:
{% highlight no-highlight %}
$ mkdir hibernateTutorial/src/main/resources
{% endhighlight %}

Let's check if everything is OK by compiling our project:
{% highlight no-highlight %}
$ cd hibernateTutorial/
$ mvn compile

....
[INFO] ------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------
....
{% endhighlight %}
Compilation was successful so it's time to replace `pom.xml` file with:
{% highlight xml %}
<?xml version="1.0"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>mc.hibernatetutorial</groupId>
  <artifactId>hibernateTutorial</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>hibernateTutorial</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>
        UTF-8
    </project.build.sourceEncoding>
  </properties>

  <build>
    <plugins>
      <!-- enable Java 8 support -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.5.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
      <!-- this plugin allows us to run 
           project using simple command:
           $ mvn exec:java -->
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>1.2.1</version>
        <executions>
          <execution>
            <goals>
              <goal>java</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <mainClass>mc.hibernatetutorial.App</mainClass>
          <arguments></arguments>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <!-- Hibernate library -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-entitymanager</artifactId>
      <version>5.1.0.Final</version>
    </dependency>

    <!-- needed if you want to use new java.time API -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-java8</artifactId>
      <version>5.1.0.Final</version>
    </dependency>

    <!-- needed if you want to use javax.validation -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-validator</artifactId>
      <version>5.2.4.Final</version>
    </dependency>

    <!-- needed if you want to use javax.validation -->
    <dependency>
      <groupId>javax.el</groupId>
      <artifactId>javax.el-api</artifactId>
      <version>2.2.4</version>
    </dependency>

    <!-- PostgreSql driver, if you use another DB change
             this dependency -->
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>9.4.1208.jre7</version>
    </dependency>

    <!-- Log4j library -->
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
    </dependency>
  </dependencies>
</project>
{% endhighlight %}

Let's check again if everything works by issuing commands:
{% highlight no-highlight %}
$ cd hibernateTutorial/
$ mvn compile
$ mvn exec:java
{% endhighlight %}
You should see "Hello, World!" printed among pile of log messages (`-q` mvn option
can be used suppress log messages).

Next we need to add `log4j.xml` configuration file to `src/main/resources` directory:
{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration debug="false"
     xmlns:log4j='http://jakarta.apache.org/log4j/'>

    <appender name="file" 
                class="org.apache.log4j.RollingFileAppender">
        <!-- name of log file: -->
        <param name="file" value="hibernate_tutorial.log" />
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="[%d{HH:mm:ss}] %m%n" />
        </layout>
    </appender>

    <appender name="console" 
                class="org.apache.log4j.ConsoleAppender">
        <param name="Target" value="System.out"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" 
                   value="[%d{HH:mm:ss}] %m%n"/>
        </layout>
    </appender>

    <!-- change log level to DEBUG
         if you want more detailed
         logs from Hibernate -->
    <logger name="org.hibernate">
        <level value="ERROR"/>
    </logger>
    
    <!-- log SQL queries executed by
         Hibernate library -->
    <logger name="org.hibernate.SQL">
        <level value="DEBUG"/>
    </logger>

    <!-- log values of SQL queries parameters -->
    <logger name="org.hibernate.type.descriptor.sql.BasicBinder">
        <level value="TRACE" />
    </logger>

    <root>
        <level value="DEBUG" />
        <appender-ref ref="file" />
        <appender-ref ref="console" />
    </root>

</log4j:configuration>
{% endhighlight %}
Now we can use Log4j logger in our application:
{% highlight java %}
// src/main/java/mc/hibernatetutorial/App.java
package mc.hibernatetutorial;

import org.apache.log4j.Logger;

public class App 
{
    private static final Logger logger = 
                        Logger.getLogger(App.class);

    public static void main(String[] args)
    {
        logger.debug("Hello, World!");
    }
}
{% endhighlight %}
After `mvn compile` and `mvn exec:java -q` you should see message printed to
terminal and to `hibernate_tutorial.log` file in the project directory.

##### Prepare database

Before we start playing with Hibernate we should create separate
database user for our app. User account can be created from pgAdmin
by executing following SQL:
{% highlight sql %}
create user huser with password `hpass`;
{% endhighlight %}
We will also create database dedicated for our app, named `tutorialdb`:
{% highlight sql %}
create database tutorialdb;
{% endhighlight %}
And allow `huser` to create/modify/drop tables in `tutorialdb`:
{% highlight sql %}
grant all privileges on database tutorialdb to huser;
{% endhighlight %}

After executing these instructions you should be able to login as `huser`
and create table inside `tutorialdb` database.

INFO: When you try to connect to local PostgreSQL instance always specify
name of server as an IP address e.g. `127.0.0.1`, otherwise you may not be able
to login without tweaking PostgreSQL configuration 
(more details [here](http://stackoverflow.com/questions/18664074/getting-error-peer-authentication-failed-for-user-postgres-when-trying-to-ge)).

#### Hello, World! in vanilla Hibernate

Finally we may start playing with Hibernate ORM.
Let's begin by creating Hibernate configuration file `hibernate_cfg.xml`
inside `src/main/resources` directory:
{% highlight xml %}
<?xml version="1.0" encoding="utf-8"?>
<hibernate-configuration>
  <session-factory>
    <!-- Database connection settings -->
    <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQL82Dialect</property>
    <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
    <property name="hibernate.connection.username">huser</property>
    <property name="hibernate.connection.password">hpass</property>
    <property name="hibernate.connection.url">jdbc:postgresql://127.0.0.1:5432/tutorialdb</property>
    <!-- JDBC connection pool (use the built-in) -->
    <property name="connection.pool_size">1</property>
    <!-- Disable the second-level cache  -->
    <property name="cache.provider_class">org.hibernate.cache.internal.NoCacheProvider</property>
    <!-- Log SQL queries -->
    <property name="format_sql">true</property>
    <property name="use_sql_comments">true</property>
    <!-- Drop and re-create the database schema on startup -->
    <property name="hbm2ddl.auto">create</property>
    <!-- MAPPINGS -->
    <mapping class="mc.hibernatetutorial.model.TestEntity"/>
  </session-factory>
</hibernate-configuration>
{% endhighlight %}
This file can be quite complex, it contains various settings used by ORM.
The most important for us are:

* `hibernate.connection.username` and `hibernate.connection.password` - these
 properties contains credentials used to connect to database server
* `hibernate.connection.url` - address of database server.
 The last part of url contains database name (in our case `tutorialdb`)
* `format_sql` and `use_sql_comments` properties -  when set to `true` will force
 Hibernate to log SQL queries executed against database
* `hbm2ddl.auto` property - when set to `create` will drop and recreate all tables
 in database at application start. This is useful when you are learning Hibernate
 but can be frustrating because all changes made by you to database will be lost
 when you run your application again. To disable this feature use `validate` as property
 value, this will only check if database contains all required tables but will not drop them.
* `<mapping />` elements - allow you to list all entity classes that you want
 to use with Hibernate. For now we list only single class:
 `mc.hibernatetutorial.model.TestEntity`.

Next we must create our entity class `mc.hibernatetutorial.model.TestEntity`:
{% highlight java %}
// src/main/java/mc/hibernatetutorial/model/TestEntity.java
package mc.hibernatetutorial.model;

import javax.persistence.*;

@Entity
@Table(name = "test")
public class TestEntity {
    @Id
    @GeneratedValue
    private Long id;

    @Column(unique = true)
    private String name;

    public TestEntity() { }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return String.format("User id: %d, name: %s", getId(), getName());
    }
}
{% endhighlight %}
The are two ways in which you may map entities using Hibernate: via annotations and via xml
files (with `.hbm.xml` extension). Annotations are more popular these days and so 
we will use them. First we mark our class as entity using `@Entity` annotation.
Then we specify table name that will hold `TestEntity` data (by default table name
is equal to class name) using `@Table` annotation. Every entity class must have
a primary key, we use `@Id` to mark one of class fields as key. We also use `@GeneratedValue`
annotation this will hint hibernate that we want database server to generate entity keys.
The last annotation that we use is `@Column`, we can use it to change column name for given
field or as in our example to set unique constrain.

Finally we may write code to save our `TestEntity` to database:
{% highlight java %}
// src/main/java/mc/hibernatetutorial/App.java
package mc.hibernatetutorial;

import org.apache.log4j.Logger;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import mc.hibernatetutorial.model.*;

public class App 
{
    private static final Logger logger = Logger.getLogger(App.class);

    public static void main(String[] args)
    {
        // read configuration and build session factory
        final StandardServiceRegistry registry =
                new StandardServiceRegistryBuilder()
                        .configure("hibernate_cfg.xml")
                        .build();

        SessionFactory sessionFactory = null;

        try {
            sessionFactory = new MetadataSources(registry)
                    .buildMetadata()
                    .buildSessionFactory();
        }
        catch (Exception e) {
            StandardServiceRegistryBuilder.destroy(registry);
            logger.error("cannot create sessionFactory", e);
            System.exit(1);
        }

        // create session, open transaction and save test entity to db
        Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();

        try {
            TestEntity testEntity = new TestEntity();
            testEntity.setName("super foo");

            session.persist(testEntity);
            tx.commit();
        }
        catch (Exception e) {
            tx.rollback();
            logger.error("cannot commit transaction", e);
        }
        finally {
            session.close();
        }

        // clean up
        sessionFactory.close();
    }
}
{% endhighlight %}
We start by building `SessionFactory`, this is pretty boring stuff that needs to be done.
Notice how we are loading settings from our `hibernate_cfg.xml` file:
{% highlight java %}
final StandardServiceRegistry registry =
        new StandardServiceRegistryBuilder()
                .configure("hibernate_cfg.xml")
                .build();
{% endhighlight %}
Next we use `SessionFactory` to create new session (session may be treated as a implementation
of [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) pattern, generally you should create session per transaction).
We use `beginTransaction()` to start new database transaction. Then we create our `TestEntity`
object, we set some properties and we save it to database using `session.persist()` call.
Next we commit transaction using `tx.commit()` and finally we are freeing session resources
using `session.close()`.

After `mvn compile` and `mvn exec:java` Hibernate should generated single table `test` in
our `tutorialdb` database, and should insert single row representing our 
`TestEntity` to that table.
You may want to dig into log messages to see actual SQL statements used to create table
and insert row. Here for example is generated SQL that inserted our `TestEntity` row:
{% highlight SQL %}
/* insert mc.hibernatetutorial.model.TestEntity
    */ insert 
    into
        test
        (name, id) 
    values
        (?, ?)

binding parameter [1] as [VARCHAR] - [super foo]
binding parameter [2] as [BIGINT] - [1]
{% endhighlight %}

Now we can start exploring more advanced Hibernate topics like
[mapping](http://www.tutorialspoint.com/hibernate/hibernate_annotations.htm) or 
[querying](http://www.tutorialspoint.com/hibernate/hibernate_query_language.htm).

Code used in this tutorial: [https://github.com/marcin-chwedczuk/java-hibernate-helloworld/tree/vanilla](https://github.com/marcin-chwedczuk/java-hibernate-helloworld/tree/vanilla)

#### Hello, World! using JPA

Now we may explore Hibernate ORM via Java Persistence API.
Let's begin by creating JPA configuration file `persistence.xml`
inside `src/main/resources/META-INF` directory:
{% highlight xml %}
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence                             http://xmlns.jcp.org/xml/ns/persistence_2_1.xsd">
  <persistence-unit name="HelloWorldPU" transaction-type="RESOURCE_LOCAL">
    <!--
        MAPPINGS
    -->
    <class>mc.hibernatetutorial.model.TestEntity</class>
    <!-- Use only classes specified in MAPPINGS -->
    <exclude-unlisted-classes>true</exclude-unlisted-classes>
    <properties>
      <!-- Configuring JDBC properties -->
      <property name="javax.persistence.jdbc.url" value="jdbc:postgresql://127.0.0.1:5432/tutorialdb" />
      <property name="javax.persistence.jdbc.user" value="huser" />
      <property name="javax.persistence.jdbc.password" value="hpass" />
      <property name="javax.persistence.jdbc.driver" value="org.postgresql.Driver" />
      <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQL82Dialect" />

      <!-- Log SQL queries -->
      <property name="hibernate.format_sql" value="true" />
      <property name="hibernate.use_sql_comments" value="true" />

      <!-- Drop and re-create the database schema on startup -->
      <property name="javax.persistence.schema-generation.database.action" value="drop-and-create" />
       <!-- Use only classes specified in MAPPINGS -->
      <property name="hibernate.archive.autodetection" value="none" />
    </properties>
  </persistence-unit>
</persistence>
{% endhighlight %}
This file can be quite complex, it contains various settings used by ORM.
The most important for us are:

* `javax.persistence.jdbc.user` and `javax.persistence.jdbc.password` - these
 properties contains credentials used to connect to database server
* `javax.persistence.jdbc.url` - address of database server.
 The last part of url contains database name (in our case `tutorialdb`)
* `hibernate.format_sql` and `hibernate.use_sql_comments` properties -  
 when set to `true` will force
 Hibernate to log SQL queries executed against database
* `javax.persistence.schema-generation.database.action` property - 
 when set to `drop-and-create` will drop and recreate all tables
 in database at application start. This is useful when you are learning Hibernate
 but can be frustrating because all changes made by you to database will be lost
 when you run your application again. To disable this feature use `none` as property
 value.
* `<class />` elements - allow you to list all entity classes that you want
 to use with Hibernate. For now we list only single class:
 `mc.hibernatetutorial.model.TestEntity`.

Next we must create our entity class `mc.hibernatetutorial.model.TestEntity`:
{% highlight java %}
// src/main/java/mc/hibernatetutorial/model/TestEntity.java
package mc.hibernatetutorial.model;

import javax.persistence.*;

@Entity
@Table(name = "test")
public class TestEntity {
    @Id
    @GeneratedValue
    private Long id;

    @Column(unique = true)
    private String name;

    public TestEntity() { }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return String.format("User id: %d, name: %s", getId(), getName());
    }
}
{% endhighlight %}
JPA uses annotations to control how ORM maps classes to database tables and columns.
We mark `TestEntity` class as entity using `@Entity` annotation.
We specify table name that will hold `TestEntity` data (by default table name
is equal to class name) using `@Table` annotation. Every entity class must have
a primary key, we use `@Id` to mark one of class fields as key. We also use `@GeneratedValue`
annotation to hint ORM that we want database server to generate entity keys.
The last annotation that we use is `@Column`, we can use it to change column name for given
field or as in our example to set unique constrain.

Finally we may write code to save our `TestEntity` class to database:
{% highlight java %}
// src/main/java/mc/hibernatetutorial/App.java
package mc.hibernatetutorial;

import org.apache.log4j.Logger;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

import mc.hibernatetutorial.model.*;

public class App 
{
    private static final Logger logger = Logger.getLogger(App.class);

    public static void main(String[] args)
    {
        logger.debug("starting application....");

        final EntityManagerFactory emf = 
                Persistence.createEntityManagerFactory("HelloWorldPU");

        EntityManager entityManager = emf.createEntityManager();
        EntityTransaction tx = entityManager.getTransaction();
        tx.begin();

        try {
            TestEntity testEntity = new TestEntity();
            testEntity.setName("super foo");    

            entityManager.persist(testEntity);
            tx.commit();
        }
        catch (Exception e) {
            logger.error("cannot commit transaction", e);
            tx.rollback();
        }
        finally {
            entityManager.close();
        }
        
        emf.close();
    }
}
{% endhighlight %}
We start by building `EntityManagerFactory`, this will load our configuration
from `persistence.xml`: 
{% highlight java %}
final EntityManagerFactory emf = 
        Persistence.createEntityManagerFactory("HelloWorldPU");
{% endhighlight %}
Notice that we use name `HelloWorldPU`, the same as used in `<persistence-unit />` element
in `persistence.xml`.

Next we use `EntityManagerFactory` to create new `EntityManger`
(entity manager may be treated as a implementation
of [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) pattern, 
generally you should create one entity manager per transaction).
Next we use `entityManager.getTransaction()` and `tx.begin()` to start new database transaction. 
Then we create our `TestEntity`
object, we set some properties and we save it to database using `entityManager.persist()` call.
Next we commit transaction using `tx.commit()` and finally we are freeing resources
using `entityManager.close()`.

After `mvn compile` and `mvn exec:java` Hibernate should generated single table `test` in
our `tutorialdb` database, and should insert single row representing our 
`TestEntity` to that table.
You may want to dig into log messages to see actual SQL statements used to create table
and insert row. Here for example is generated SQL that inserted our `TestEntity` row:
{% highlight SQL %}
/* insert mc.hibernatetutorial.model.TestEntity
    */ insert 
    into
        test
        (name, id) 
    values
        (?, ?)

binding parameter [1] as [VARCHAR] - [super foo]
binding parameter [2] as [BIGINT] - [1]
{% endhighlight %}

Now we can start exploring more advanced Hibernate topics like
[mapping](http://www.tutorialspoint.com/hibernate/hibernate_annotations.htm) or 
[querying](http://www.tutorialspoint.com/hibernate/hibernate_query_language.htm).

Code used in this tutorial: [https://github.com/marcin-chwedczuk/java-hibernate-helloworld/tree/jpa](https://github.com/marcin-chwedczuk/java-hibernate-helloworld/tree/jpa)



	  ]]></description>
	</item>


</channel>
</rss>

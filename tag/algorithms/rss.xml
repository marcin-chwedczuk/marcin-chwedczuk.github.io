<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>https://marcin-chwedczuk.github.io/</link>
   <description>A place where I can share my thoughts about programming</description>
   <language>en-uk</language>
   <managingEditor> marcin-chwedczuk</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Ray tracing a torus</title>
	  <link>//ray-tracing-torus</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2018-05-06T02:00:00+02:00</pubDate>
	  <guid>//ray-tracing-torus</guid>
	  <description><![CDATA[
	     In this blog post I will show you how to ray trace a torus.
I will assume that you already know how to ray trace simple shapes
like spheres and cubes. I will also assume some basic familiarity
with shading and ray tracing in general.

### Obtaining torus equation

Before we start I must introduce some terminology.
I will use $$R$$ to denote torus major radius 
(the distance from the center of the tube to the center of the torus),
and $$r$$ to denote torus minor radius
(the radius of the tube). 
![Torus geometry](assets/images/2018-05-06/torusrR.png)

Let us consider torus $$T$$ centered at point 
$$(0,0,0)$$ with radiuses $$R$$ and $$r$$.
Torus $$T$$ can be defined as a set of points for which
certain function $$F$$ returns zero:

$$
	T = \{ p \in \mathbb{R}^3 \mid F(p) = 0 \}
$$

Our task will be to find a suitable definition of function $$F$$
that properly describes torus $$T$$.

We will start by looking at the intersection of torus $$T$$ with $$XY$$ plane:
![Torus-XY plane intersection](assets/images/2018-05-06/torus-def.svg)
Every point $$P=(x,y)$$ on the circumference of the 
right circle satisfies equation:

$$
(x - R)^2 + y^2 = r^2
$$

Now imagine that we are taking some point $$P$$ on the circumference
and we are rotating it around
$$Y$$ axis. 
![Rotating point around Y axis](assets/images/2018-05-06/torus-def2b.svg)
This way point $$P$$ becomes a set of points in 3D space:

$$
	P=(x,y,0) \Rightarrow \{(x',y,z') \in \mathbb{R}^3 | x'^2 + z'^2 = x^2 \}
$$

Torus can be obtained by rotating all points on the circumference
of the circle. In
other words points $$(x',y,z')$$ on the surface of a torus satisfy equations:

$$
\begin{cases}
(x - R)^2 + y^2 = r^2 \\
x'^2 + z'^2 = x^2 
\end{cases}
$$

This equations can be simplified by removal of $$x$$ variable into:

$$
(x'^2 + y^2 + z'^2)^2 - 2 (R^2 + r^2) (x'^2 + y^2 + z'^2) + 4 R^2 y^2 + (R^2 - r^2)^2 = 0
$$

And this is exactly what we were looking for, a suitable definition
for our function $$F$$. 
After a bit of renaming ($$x' \rightarrow x$$, $$z' \rightarrow z$$) 
we can write our final equation:

$$
F(x,y,z) = (x^2 + y^2 + z^2)^2 - 2 (R^2 + r^2) (x^2 + y^2 + z^2) + 4 R^2 y^2 + (R^2 - r^2)^2
$$

### Solving torus equation

Given ray definition:

$$
r(t) = o + \vec{d} * t
$$

$$
o = \begin{bmatrix}o_x\\o_y\\o_z\end{bmatrix}, \;
\vec{d} = \begin{bmatrix}d_x\\d_y\\d_z\end{bmatrix}
$$

where $$o$$ is the ray origin (starting point) 
and $$d$$ is a unit vector ($$ \left\lVert d \right\rVert = 1 $$) that
represents the ray direction,
we will try to find all positive ($$t > 0$$)
solutions to the equation:

$$
F(r(t)) = 0,\; t > 0
$$

Notice that for a particular ray this equation can have
0, 1, 2, 3 or 4 solutions:
![Visual illustration of number of the solutions](assets/images/2018-05-06/torus-sol4.svg)

We will start by substituting $$x, y, z$$ variables
by $$r(t)$$ point components 
in the formula of function $$F(x,y,z)$$:

$$
r(t) = \begin{bmatrix}r_x\\r_y\\r_z\end{bmatrix}
$$

$$
F(r_x,r_y,r_z) = (r_x^2 + r_y^2 + r_z^2)^2 - 2 (R^2 + r^2) (r_x^2 + r_y^2 + r_z^2) + 4 R^2 r_y^2 + (R^2 - r^2)^2
$$

And then we expand them to their full definition:

$$
r_x = o_x + d_x*t \\
r_y = o_y + d_y*t \\
r_z = o_z + d_z*t \\
$$

After long and tedious calculations and a lot of grouping and 
simplifications we finally get:

$$
F(r(t)) = c_4 t^4 + c_3 t^3 + c_2 t^2 + c_1 t + c_0 = 0
$$

where

$$
\begin{cases}
c_4 = (d_x^2 + d_y^2 + d_z^2)^2 \\
c_3 = 4 (d_x^2 + d_y^2 + d_z^2) (o_x d_x + o_y d_y + o_z d_z) \\
c_2 = 2 (d_x^2 + d_y^2 + d_z^2) (o_x^2 + o_y^2 + o_z^2 - (r^2 + R^2)) + 4 (o_x d_x + o_y d_y + o_z d_z)^2 + 4 R^2 d_y^2 \\
c_1 = 4 (o_x^2 + o_y^2 + o_z^2 - (r^2 + R^2)) (o_x d_x + o_y d_y + o_z d_z) + 8 R^2 o_y d_y \\
c_0 = (o_x^2 + o_y^2 + o_z^2 - (r^2 + R^2))^2 - 4 R^2 (r^2 - o_y^2)
\end{cases}
$$

Since our equation is just a polynomial of 4th degree, we may use 
one of the standard algorithms to solve it. 
In my demo application I used algorithm from 
[Graphic Gems](http://a.co/abkZKRO) book, freely available at
[GitHub](https://github.com/erich666/GraphicsGems/blob/master/gems/Roots3And4.c).
But you are free to use any other algorithm. In particular 
[Numerical Recipes in C](http://www.nrbook.com/a/bookcpdf.php) 
book is a good source of numerical algorithms.

TIP: Unfortunately `Roots3And4.c` file from Graphic Gems (called `solver.js` 
in my demo app) is sparsely 
documented. If you want to know how finding roots of 4th
degree polynomial actually works please
read section from Wikipedia about 
[Ferrari method](https://en.wikipedia.org/wiki/Quartic_function#Ferrari's_solution),
but use second definition of the _resolvent cubic_ described in [this Wikipedia article](https://en.wikipedia.org/wiki/Resolvent_cubic#Second_definition).
With a bit of effort you should be able to follow and understand source
code of the solver then.

### Practical considerations

1. Currently we can only render tori centered at point $$(0,0,0)$$ and laying
 on $$XZ$$ plane. To obtain tori located at arbitrary points and/or in arbitrary
 positions,
 we must apply matrix transformations to the _ray_
 just before computing intersections with the torus surface.
 For example from the viewer point of view
 the results of the following operations are the same:
 translating ray by vector $$(0,2,0)$$,
 translating torus by vector $$(0,-2,0)$$.
 In my demo app this transformation is done in `RayTracer.js#rotationEnd`
 method. For more details please see _Ray Tracing from the Ground Up_ book.

2. Due to limited accuracy of the floating point computations
 artifacts may be seen when we use huge numerical values for torus radiuses.
 For the best results we should keep $$R,r < 10$$.
 If you need huge tori in your scenes please use
 ray transformation technique described in point (1) to scale 
 small tori as needed.

3. From performance point of view rendering a torus by solving its equation
 is slow. Rendering may be speed up considerably if we manage to avoid
 solving the equation altogether e.g. by using 
 [triangle meshes](https://en.wikipedia.org/wiki/Triangle_mesh).

#### Source code

As a part of preparations to write this post I created a
simple demo app that ray traces a torus:
![Demo application](assets/images/2018-05-06/demo-app-thumbnail.png)

Source code can be downloaded from
[this GitHub repository](https://github.com/marcin-chwedczuk/ray_tracing_torus_js).

Application is written in JavaScript.
To run demo app execute:
{% highlight no-highlight %}
$ cd path/to/ray_tracing_torus_js/repo
$ npm install
$ bower install
$ gulp serve
{% endhighlight %}
`npm install` command may take a while to finish, so please be patient.
Also notice that you have to had both `bower` and `gulp` installed
on you local machine to make this work. 
You can install them by executing:
{% highlight no-highlight %}
$ sudo npm install --global gulp-cli
$ sudo npm install --global bower
{% endhighlight %}

#### References

* Ray Tracing from the Ground Up, Kevin Suffern, [Buy on Amazon](http://a.co/c5YAorf)
* Wikipedia, [Torus entry](https://en.wikipedia.org/wiki/Torus)
* [Roots3And4.c from Graphic Gems](https://github.com/erich666/GraphicsGems/blob/master/gems/Roots3And4.c)


	  ]]></description>
	</item>

	<item>
	  <title>How to check if a number is a power of two</title>
	  <link>//how-to-check-if-a-number-is-a-power-of-two</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2017-12-16T01:00:00+01:00</pubDate>
	  <guid>//how-to-check-if-a-number-is-a-power-of-two</guid>
	  <description><![CDATA[
	     In this blog post we will learn about two algorithms that
allow us to quickly check that a given integer is
a power of two. 
Both of these algorithms use only bit operators - they are
very efficient.

#### Algorithm I

We will start by looking at the algorithm implementation,
then I will explain how it works:
{% highlight java %}
/**
 * Checks if a {@code number} is a power of two.
 * <p>
 *     Zero and negative numbers are not considered powers of two.
 * </p>
 * @param number any integer.
 * @return {@code true} when {@code number} is a power of two,
 *  {@code} false otherwise.
 */
boolean isPowerOfTwo(int number) {
    return 
        ( (number & (-number)) == number ) && 
        (number > 0);
}
{% endhighlight %}

Before we move on it is a good time to remind ourselves that
along an algorithm implementation we 
should always specify the range of valid inputs 
and expected outputs.
In the code above I used Javadoc comments to state that our algorithm
accepts any number (positive, negative or zero) but it
considers only positive numbers to be powers of two.
For example `isPowerOfTwo(8)` should return `true` but 
`isPowerOfTwo(-16)` should return `false`.

Now let's explain how the algorithm works.
If we look at the binary representation of the powers of
two we can see the following bit pattern - there is
only a single bit set:
![powers of two](assets/images/2017-12-16/powers_of_two.svg)

Now comes the tricky part. Computers use 
[two's complement](https://en.wikipedia.org/wiki/Two%27s_complement)
encoding to efficiently store 
and perform operations on both positive and negative numbers.

To explain how two's complement works we must first 
realise that pure binary encoding can only be used 
to store positive numbers:
![binary representation of 17](assets/images/2017-12-16/b_17.svg)
One naive extension to pure binary encoding that supports
storing negative numbers is to
sacrifice MSB (the most significant bit) to represent number sign:
![Naive negative numbers](assets/images/2017-12-16/bsgn.svg)
But this solution comes with its own problems,
for example we will end up with two different
bit patterns that represent the value of zero (`+0` and `-0`).
This also unnecessary complicates CPU design 
(we will need two different circuits to perform unsigned and signed
arithmetic) and reduces the range of
possible values that can be represented within a single byte
(again because zero is now unnecessarily 
represented by two distinct values).

Two's complement encoding solves all these problem.
The main idea is to assign negative weight to the most significant
bit of the number, for example:
![binary representation of -17](assets/images/2017-12-16/u2_17.svg)
The positive numbers have the same representation as they have in
pure binary encoding. There is also a simple procedure to negate a number,
first negate all bits and then add one to the result:
![Twos complement negation](assets/images/2017-12-16/u2_neg.svg)

Above procedure works for all numbers except one - the maximum negative
value (`-128` for a single byte, `-2147483648` for a 4-byte `int`):
![Twos complement negation](assets/images/2017-12-16/u2_min.svg)
This is the consequence of the fact that 
range of numbers that can be represented using two's complement
is asymmetric around zero. For example in a single byte we can
represent values from `-128` up to `127`.

Since we are here it is also worth to mention that we may use
the same addition algorithm to add numbers encoded in pure
binary encoding and in two's complement encoding.
Subtraction is also very easy. Say you want to subtract 
numbers `a` and `b`, you just negate `b` 
(using `NOT` and `INC` instructions) 
and then add it to `a`.

Now let's go back to our algorithm.
Let's assume that we have a number that is a power of two,
such a number has only one bit set. So we may assume that
our number `n` has form:
{% highlight no-highlight %}
0...010...0
{% endhighlight %}
As discussed above arithmetic negation is performed by first negating all
bits and then adding one, in our case:
{% highlight no-highlight %}
0...010...0
1...101...1 (NOT)
1...110...0 (+1)
{% endhighlight %}
As we can see `n` and `-n` share a single common bit, `AND`ing both
values yields:
{% highlight no-highlight %}
0...010...0  n
1...110...0 -n
AND
0...010...0 = n
{% endhighlight %}
So we ended up with the same value as we started. 
In other words `(n & -n) == n` returns true.
This is illustrated for `n = 32` on the diagram below:
![How algorithm works for n=32](assets/images/2017-12-16/a1_w.svg)

Now consider a number that is not a power of two, such a number
will have at least two bits set (we will deal with zero later).
We will divide number into three parts, the bits before first set
bit on the left, the bits after the last set bit on the right and the
middle bits. 
Let's see what will happen when we use our algorithm on such a number:
{% highlight no-highlight %}
0..01?...?10..0 n
1..10?...?01..1 (NOT)
1..10?...?10..0 (+1) = -n
{% endhighlight %}
I used `?` to mark middle bits that can have any value.
The most important observation is that the leftmost set bit 
in `n` is cleared after negation.

Now let's see what will be returned by `AND`:
{% highlight no-highlight %}
0..01?...?10..0  n
1..10?...?10..0 -n
AND
0..00?...?10..0 != n
{% endhighlight %}
As we can see all bits before `?` are cleared after performing `AND`
operation. This guarantees that `(n & -n)` expression returns
different value than `n` which has one bit set before `?...?` bits.
And so `(n & -n) == n` returns `false` as expected.

Diagram below illustrates how algorithm works for `n = 36`:
![How algorithm works for n=36](assets/images/2017-12-16/a1_w2.svg)

There are two special values that need more attention.
One is of course zero which is handled explicitly by the condition
`(number > 0)`. The other value is `Integer.MIN_VALUE`.
The `Integer.MIN_VALUE` may be treated either as a power of two
(it has only single bit in the binary representation) or not. 
This depends on how we want to tread `int` value in Java 
(as a singed number or as an unsigned one).
At the beginning we decided that our algorithm accepts negative values
and so `number` is a signed value.
To be consistent we again use `(number > 0)` condition to return
`false` for `Integer.MIN_VALUE`.

#### Algorithm II

Again we will start with the implementation:
{% highlight java %}
/**
 * Checks if a {@code number} is a power of two.
 * <p>
 *     Zero and negative numbers are not considered powers of two.
 * </p>
 * @param number any integer.
 * @return {@code true} when {@code number} is a power of two,
 *  {@code} false otherwise.
 */
boolean isPowerOfTwo2(int number) {
    return 
        ( (number & (number-1)) == 0 ) && 
        (number > 0);
}
{% endhighlight %}

This algorithm is much more simpler than previous one.
So how does it work?
We already know that numbers that are powers of two
have only single bit set in their binary representation:
{% highlight no-highlight %}
0..010..0
{% endhighlight %}
When we substract one from such a number we get:
{% highlight no-highlight %}
0..010..0 n
0..001..1 n-1
{% endhighlight %}
As we can see the leftmost bit of `n` is cleared
after subtraction. When we `AND` `n` and `n-1` 
we get zero:
{% highlight no-highlight %}
0..010..0 n
0..001..1 n-1
0..000..0 (n AND n-1)
{% endhighlight %}

Numbers that are not powers of two (except zero)
have at least two bits set. Again we use our trick
with dividing number into three parts:
bits before first set bit, bits after last set bit and
the middle bits.
{% highlight no-highlight %}
0..01?...?10..0 n
0..01?...?01..1 n-1
0..01?...?00000 (n AND n-1)
{% endhighlight %}
This shows us that the leftmost bit of `n` is not cleared by the `AND`
operation and so the final value cannot be equal to zero.

Two special cases for zero and maximum negative value are
handled in exactly the same way as in Algorithm I by `(number > 0)`
condition.

Diagram below illustrates how Algorithm II works for `113`:
![How algorithm II works for 113](assets/images/2017-12-16/a2_w.svg)

#### Versions of algorithm I and II for unsigned numbers

Some programming languages e.g. C\# and C++ supports
unsigned numbers. Such numbers can only store zero and positive values.
We may use the fact that all values are non-negative to
simplify condition `(number > 0)` into `(number != 0)` which
may be better optimized by some compilers.

It may be surprising that unsigned numbers support 
arithmetic negation operator `(-)`.
For them negation just means combination of `NOT` and `INC (+1)`
instructions that we described previously.

Here are versions of both algorithms that operate on unsigned
numbers in C\#:
{% highlight csharp %}
/// <summary>
///     Checks if a <paramref="number" /> is a power of two.
/// </summary>
/// <remarks>
///     Zero is not considered power of two.
/// </remarks>
/// <param name="number">Any unsigned value</param>
/// <returns>
///     <c>true</c> when <c>number</c> is a power of two,
///     <c>false</c> otherwise.
/// </returns>
bool IsPowerOfTwo(uint number) {
    return
        ( (number & (-number)) == number ) &&
        (number != 0);
}

/// ... documentation ommited ...
bool IsPowerOfTwo2(uint number) {
    return 
        ( (number & (number-1)) == 0 ) && 
        (number != 0);
}
{% endhighlight %}

#### JavsScript peculiarities

JavaScript uses `double` type to represent all numbers.
`double`s are capable of accurately storing integers in range
`-2^53 .. +2^53`. Unfortunately when we perform bit operations
in JavaScript
both operands are first converted to 32 bit signed integers and
then operation proceeds.
This means that both presented algorithms will work in JS only 
for numbers in range `-2^30 .. +2^30-1`.
This is demonstrated by program:
{% highlight js %}
function isPowerOfTwo(number) {
  return( 
    (number & (-number)) == number &&
    (number > 0));
}

let two_power_30 = Math.pow(2, 30);
// true
console.log(isPowerOfTwo(two_power_30));

let two_power_31 = Math.pow(2, 31);
// false
console.log(isPowerOfTwo(two_power_31));
{% endhighlight %}



	  ]]></description>
	</item>

	<item>
	  <title>Find cycle start in singly linked list</title>
	  <link>//find-cycle-start-in-singly-linked-list</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-25T02:00:00+02:00</pubDate>
	  <guid>//find-cycle-start-in-singly-linked-list</guid>
	  <description><![CDATA[
	     In this post I will present solution to the following problem:

> We have a non empty singly linked list with a cycle in it.  
> We must find first
> element of a cycle in a linear time.

For example, given a singly linked list:
![List with cycle 1](assets/images/2016-06-25/llcycle1.svg)
Algorithm should return node `N3` as it is the first node counting
from head of a list that is part of cycle.

##### Boundary conditions

To better understand this problem let's think about boundary conditions for
our algorithm.

One of the boundary conditions is that entire list forms single cycle:
![Entire list forms cycle](assets/images/2016-06-25/llcycle2.svg)
In this case our algorithm should return first element of a list (`N1` node for a list
presented on picture above).

Another boundary condition is that only last element 
of the list forms a cycle:
![Only last element of the list forms a cycle](assets/images/2016-06-25/llcycle3.svg)
In this case algorithm should return last element of the list (`N4` node for
a list presented on picture above).

The last boundary condition is a list that consists of only one element:
![Single element list](assets/images/2016-06-25/llcycle4.svg)
In this case algorithm should return that single element.

For all except last described boundary conditions we should consider lists with odd and even number of elements.

##### Create test suite

Let's code these boundary conditions and a few of other generic cases as a set of unit tests.
To represent list nodes we will use following Java class:
{% highlight java %}
public class ListNode {
    public int value;
    public ListNode next;

    public ListNode(int value) { this(value, null); }

    public ListNode(int value, ListNode next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "ListNode{" +
                "value=" + value +
                '}';
    }
}
{% endhighlight %}
Our algorithm will be represented by `CycleStart.find` method:
{% highlight java %}
public final class CycleStart {
    private CycleStart() { }

    public static ListNode find(ListNode list) {
        // TODO: Implement algorithm
        return null;
    }
}
{% endhighlight %}
To avoid code duplication we will use JUnit 4 parameterized unit tests.
AssertJ will be used
as an assertion library:
{% highlight java %}
@RunWith(Parameterized.class)
public class CycleStartTest {

    @Parameterized.Parameters(name =
        "testcase {index}: CycleStart_find_works_with(listSize={0}, cycleSize={1})")
    public static Iterable<Object[]> data() {
        return Arrays.asList(new Object[][] {
        /* LIST_SIZE    CYCLE_SIZE */

        /* single element list */
        {  1,  1 },

        /* every element of list is part of cycle (odd and even list size cases) */
        { 10, 10 },
        {  9,  9 },

        /* only last element of list is part of cycle */
        { 10,  1 },
        {  9,  1 },

        /* random number of elements are part of cycle (with odd/even variants) */
        { 10,  5 },
        { 9,   5 },
        { 10,  6 },
        { 9,   6 },
        { 34, 11 }
        });
    }

    private final int listSize;
    private final int cycleSize;

    public CycleStartTest(int listSize, int cycleSize) {
        this.listSize = listSize;
        this.cycleSize = cycleSize;
    }

    @Test
    public void runTest() {
        ListWithCycle testData = ListWithCycle.having()
                .listSize(listSize)
                .cycleSize(cycleSize)
                .create();

        ListNode cycleStart = CycleStart.find(testData.list);

        assertThat(cycleStart)
                .isNotNull()
                .isEqualTo(testData.cycleStart);
    }
}
{% endhighlight %}
Each of arrays returned by static `data()` method contains
`CycleStartTest` constructor parameters. For each of these arrays JUnit will create
`CycleStartTest` instance with parameters passed to class constructor. Then
JUnit will call all methods annotated with `@Test` on that instance.
In our case we have two parameters `listSize` and `cycleSize`, I think these
are pretty self explanatory.

The last missing piece is `ListWithCycle` helper that creates list of given size
with cycle of given size:
{% highlight java %}
class ListWithCycle {
    public final ListNode list;
    public final ListNode cycleStart;

    private ListWithCycle(ListNode listHead, ListNode cycleStart) {
        this.list = listHead;
        this.cycleStart = cycleStart;
    }

    public static Builder having() {
        return new Builder();
    }

    public static class Builder {
        private int listSize;
        private int cycleSize;

        public Builder listSize(int listSize) {
            if (listSize < 0) throw new IllegalArgumentException("listSize must be >= 0");

            this.listSize = listSize;
            this.cycleSize = listSize;
            return this;
        }

        public Builder cycleSize(int cycleSize) {
            if (cycleSize <= 0) throw new IllegalArgumentException("cycleSize must be > 0");
            if (cycleSize > listSize) throw new IllegalArgumentException("cycleSize must be <= listSize");

            this.cycleSize = cycleSize;
            return this;
        }

        public ListWithCycle create() {
            List<ListNode> nodes = new ArrayList<>();
            ListNode prev = null;

            // create list
            for (int i = 0; i < listSize; i++) {
                ListNode curr = new ListNode(i);
                if (prev != null)
                    prev.next = curr;
                prev = curr;

                nodes.add(curr);
            }

            // create list cycle
            ListNode tail = prev;
            ListNode cycleStart = nodes.get(nodes.size() - cycleSize);
            tail.next = cycleStart;

            return new ListWithCycle(nodes.get(0), cycleStart);
        }
    }
}
{% endhighlight %}
Now with unit tests covering all normal and border cases we can
start implementing our algorithm.

##### Create simple implementation
Let's start with simple implementation that works in `O(N)` time but uses `O(N)`
additional memory. 
The idea behind this algorithm is simple. We will be tracking all
already visited nodes, when we visit some node N twice we will know that
node N must be start of a cycle.

This is implemented in Java as:
{% highlight java %}
public static ListNode find(ListNode list) {
    Map<ListNode, Object> visitedNodes =
                    new IdentityHashMap<ListNode, Object>();

    for (ListNode curr = list; curr != null; curr = curr.next) {
        if (visitedNodes.containsKey(curr)) {
            // curr was already visited so we visit it twice
            return curr;
        }
        else {
            // mark as visited
            visitedNodes.put(curr, null);
        }
    }

    return null;
}
{% endhighlight %}
We use `IdentityHashMap<K,V>` to track already visited nodes. 
`IdentityHashMap<K,V>` is special purpose `Map<K,V>` 
implementation that uses *references* to objects
as a keys. 
Internally it uses `==` instead of `Object.equals()` to compare keys for equality, and
`System.identityHashCode()` instead of `Object.hashCode()` to compute hashes.

This algorithm passes all unit tests but can't we do any better?  
In fact we can, there is a beautiful algorithm that runs in `O(N)` time and 
uses `O(1)` memory.

##### Create efficient implementation
Let's create a more efficient implementation.
To understand how it works we must first familiarize ourselves with fast and slow pointer
method. Main usage of fast and slow pointer method is cycle detection in singly
linked lists. The main idea is to have two pointers that traverse the same list. One pointer
"slow" moves only one element at time, other pointer "fast" moves two elements at time.
Singly linked list contains cycle if both pointers met. 
This can be implemented in Java as:
{% highlight java %}
boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
        
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        // fast caught up to slow, so there is a loop
        if(slow == fast)  
            return true;
    }
    
    // fast reached null, so the list terminates
    return false;  
}
{% endhighlight %}

In our algorithm we'll use simple fact from fast/slow pointer method: when
fast and slow pointers are inside cycle, fast pointer cannot "jump over" slow pointer.
In other words situation like:
![FAST pointer cannot jump over SLOW pointer](assets/images/2016-06-25/proof1.svg)
is not possible.

PROOF: First we assume that slow pointer always moves first and that
we stop algorithm when fast and slow pointer meet. (If entire list is one
cycle we would not count first step - when fast and slow pointers point to the list head).
Let's assume that fast pointer jumped over slow pointer as depicted on image above.
We know that slow pointer always moves first and it moves only one element at time,
so before slow pointer moved it was at `N2` node. But that was the node that
fast pointer was pointing to before it moved. In other words before slow and fast pointers
moved they pointed to the same node so our algorithm should have stopped, but it didn't.
Here we have contradiction that completes the proof.

Consequence of above proof is simple fact: let's say slow and fast pointers are pointing
at cycle first element and that cycle has C elements in total. After at most C slow pointer
moves, pointers must meed again. 

Now let's go back to our cycle start finding algorithm. 
To help us reason we will introduce some variables:

* N - number of nodes in list before cycle (`N = 3` in our example below)
* C - number of nodes in cycle (`C = 4` in our example below)
* K - position of slow pointer inside cycle 
 (first element of cycle has `k: 0`, second `k: 1` etc.)

Let's consider following situation, we ran fast/slow pointer algorithm on 7 element list
depicted below:
![SLOW pointer entering cycle](assets/images/2016-06-25/proof2.svg)
After N iterations of algorithm slow pointer enters
first element of the cycle and has position `K = 0`. Meanwhile fast
pointer that moves 2 times faster has position `Kfast = N % C`.
From this point every iteration of algorithm moves slow pointer from position `K` to `K+1`,
and fast pointer from position `Kfast` to `Kfast+2`. In other words after `S` iterations
of algorithm slow pointer has position `S % C` and fast pointer has position `(N+2*S) % C`.
We know that fast pointer cannot jump over slow pointer, both pointers must met 
in some `Smet` iteration (where `Smet <= C`). When this happens we have:

{% highlight no-highlight %}
Smet % C = (N + 2*Smet) % C
{% endhighlight %}
or in more mathematical notation:
{% highlight no-highlight %}
Smet = N + 2*Smet (mod C)
{% endhighlight %}
We can transform this equation using modulo arithmetic into:
{% highlight no-highlight %}
0 = N + Smet (mod C)
{% endhighlight %}
and finally into:
{% highlight no-highlight %}
-Smet = N (mod C)
{% endhighlight %}
This last equation is very important, it tells us that after another `N` iterations of the
algorithm slow pointer will point at cycle first element:
{% highlight no-highlight %}
slow_pointer_pos_after_another_N_iterations = 
        Smet + N = Smet + (-Smet) = 0 (mod C)
{% endhighlight %}

From this we can get main idea of our new algorithm. First run fast/slow pointer algorithm
until pointers met. Then we know that after another N iterations slow pointer will point
at cycle first element. But hey if we start moving from list head after N iterations we will
point at first cycle element too! We don't know N but if we start moving slow pointer
one element at time and simultaneously we start moving another pointer from list head
one element at time they must met at cycle first element:
![Final algorithm illustrated](assets/images/2016-06-25/proof3.svg)

Above description of algorithm will work only when `C > 1` and `N > 1`. Case when `C = 1`
is simple and I leave it as an exercise to reader.
Case when `N = 0`: entire list forms a single cycle is easy too, we solve it now.
Slow and fast pointers will met after `Smet` iterations, then:
{% highlight no-highlight %}
slow_pos = Smet % C
fast_pos = Smet*2 % C

Smet = Smet*2 (mod C)
0 = Smet (mod C)
{% endhighlight %}
In other words because `Smet <= C` and `Smet = 0 (mod C)` 
pointers can met only at the first element of the cycle (at position 0 or C).
First element of the cycle is a list head, so in this case our algorithm will work too!

Now let's move to implementation:
{% highlight java %}
private static ListNode find(ListNode list) {
    ListNode slow = list;
    ListNode fast = list;

    // find meeting point
    do {
        slow = slow.next;
        fast = fast.next.next;
    }
    while (slow != fast);

    // find cycle start
    ListNode k = slow;
    ListNode head = list;

    while (k != head) {
        k = k.next;
        head = head.next;
    }

    return head;
}
{% endhighlight %}
All tests are green so we are done, yay!

##### References

* [How to detect loop in linked list](http://stackoverflow.com/questions/2663115/how-to-detect-a-loop-in-a-linked-list)
* [Fun with modulo arithmetic](https://betterexplained.com/articles/fun-with-modular-arithmetic/)


	  ]]></description>
	</item>

	<item>
	  <title>Get day of week from date</title>
	  <link>//get-day-of-week-from-date</link>
	  <author>marcin-chwedczuk</author>
	  <pubDate>2016-06-15T02:00:00+02:00</pubDate>
	  <guid>//get-day-of-week-from-date</guid>
	  <description><![CDATA[
	     Today we will try to solve the following problem:

> Given year, month and day tell what day of week it is (Sunday, Monday etc.).
>
> INPUT: Three numbers `year`, `month` and `day` representing valid date.
> `year` must be `> 0`, months and days are numbered from 1.
> For example 3 January 2016 will be represented by `year = 2016`, `month = 1` and `day = 3`.
>
> OUTPUT: A single number that represents day of week, we assume that `0` will represent
> Sunday, `1` Monday, `2` Tuesday, ..., `6` Saturday.

We will start by solving simpler problem:

> Assume that you know what day of week is 31th December of previous year.
> Given day and month in current year tell what day of week it is.

Formula to solve this problem is simple:
{% highlight no-highlight %}
day_of_week = (
        day_of_week_31_dec_prev_year + 
        number_of_days_since_year_start(month, day)
        ) % 7
{% endhighlight %}
Only tricky part is that `number_of_days_since_year_start(month, day)` must take into
account leap years.

Testing for [leap years is easy](https://en.wikipedia.org/wiki/Leap_year#Algorithm):
{% highlight java %}
boolean isLeap(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
{% endhighlight %}

Now we can write `number_of_days_since_year_start` function:
{% highlight java %}
int numberOfDaysSinceYearStart(int year, int month, int day) {
    // (1) number of days in months: 
    // [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
    // days[month-1] - number of days in year 
    //                 before month first day.
    //
    // This can be computed using (1). 
    // We don't take into account leap years.
    int[] days = { 0, 31, 59, 90, 120, 151, 
                   181, 212, 243, 273, 304, 334 };
        
    int result = days[month-1] + day;

    if (month > 2) {
        // add February 29th for leap years
        result += isLeap(year) ? 1 : 0;
    }

    return result;
}
{% endhighlight %}
And finally we may implement `day_of_week` function:
{% highlight java %}
int dayOfWeek(
    int dayOfWeek31DecPrevYear, 
    int year, int month, int day)
{
    return (
        dayOfWeek31DecPrevYear +
        numberOfDaysSinceYearStart(year, month, day)
    ) % 7;
}
{% endhighlight %}
Let's test it:
{% highlight java %}
// 31 December 2015 is Thursday (= 4)
> dayOfWeek(4, 2016, 6, 15)
3 // Wednesday OK
> dayOfWeek(4, 2016, 9, 13) 
2 // Tuesday OK
{% endhighlight %}
Looks like it works, so now we may return to our original problem.

Let's start with 
[this Wikipedia article](https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week)
which tell us that 1 January 0001 is a Monday. But for us it will be more convenient to count days
not from 1 January of given year but from 31 December of the previous year. 
It is interesting that
there is no year 0000, year that precedes year 0001 or 1 AD is 1 BC (or in other words
years are intervals not points). To sum up we start counting days
from 31 December 1 BC.

We already have function that returns day of week if we know day of week of 31 December 
of the previous year. We can find out day of week of any date using formula:
{% highlight no-highlight %}
day_of_week_31_dec_1bc = 0; // Sunday

day_of_week_31_dec_prev_year = (
        day_of_week_31_dec_1bc +
        number_of_days_in_years(year-1)
) % 7;

day_of_week = dayOfWeek(
        day_of_week_31_dec_prev_year,
        year, month, day);
{% endhighlight %}

Let's start by implementing `number_of_days_in_years(year)` function that will return
number of days since 31 December 1 BC up to 31 December of given `year`:
{% highlight java %}
int numberOfDaysInYears(int year) {
    int normalDays = 365 * year;

    // number of leap years = number of leap days
    int leapDays = year/4 - year/100 + year/400;

    return normalDays+leapDays;
}
{% endhighlight %}
To count number of leap years I used [inclusion-exclusion principle](https://en.wikipedia.org/wiki/Inclusion–exclusion_principle).

And finally we may implement our `day_of_week` routine:
{% highlight java %}
int dayOfWeek(int year, int month, int day) {
    int dayOfWeek31Dec1BC = 0; // Sunday

    int dayOfWeek31DecPrevYear = (
            dayOfWeek31Dec1BC +
            numberOfDaysInYears(year-1)
    ) % 7;

    int result = dayOfWeek(
            dayOfWeek31DecPrevYear,
            year, month, day);

    return result;
}
{% endhighlight %}
Now we may test it but we must be careful here. Our routine returns day of week
using Gregorian calendar that was introduced in 1582 AD (or later depending on country). 
If we want to test it
in Java we should avoid using `GregorianCalendar` class since it will switch to
Julian calendar mode for years before 1582 AD. More informations on this
subject can be found in this [Stackoverflow question](http://stackoverflow.com/questions/23975205/why-does-converting-java-dates-before-1582-to-localdate-with-instant-give-a-diff).
To avoid problems we will use `LocalDate` class
that always uses Gregorian calendar:
{% highlight java %}
Random r = new Random();
int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

for (int i = 0; i < 1000; i++) {
    int year = 1 + r.nextInt(13000);

    for (int m = 1; m <= 12; m++) {
        for (int d = 1; d <= days[m-1]; d++) {
            int actual = dayOfWeek(year, m, d);
            int expected = LocalDate.of(year, m, d)
                        .getDayOfWeek()
                        .getValue() % 7;

            if (actual != expected)
                throw new RuntimeException(String.format(
                        "failed for yyyy-mm-dd: %d-%d-%d, " + 
                        "expected: %d, actual: %d.",
                        year, m, d, expected, actual));
        }
    }
}
{% endhighlight %}
Our curde testing function returns without throwing any exceptions, so we may
rest assured that our function works.

#### Tomohiko Sakamoto algorithm

Before we end this post let's challenge ourselves one more time.
Here is Tomohiko Sakamoto algorithm for computing day of week:
{% highlight java %}
int dayOfWeek2(int y, int m, int d)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
    y -= (m < 3) ? 1 : 0;
    return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}
{% endhighlight %}
With our newly gained knowledge about computing day of week let's find out
how it works!

The main idea behind the algorithm is to compute day of week from 31 December of the previous
year for January and February (just as we do in our algorithm) and to compute day of week
for all other months from 31 December of the **current** year. This greatly simplifies dealing
with leap years.
![Computing day of week from beginning or from ending of the year](assets/images/2016-06-15/compute_from.svg)

To compute day of week from year end we will do as follows: say we want to know day of week
for 7 April 2016. We know that 31 December 2016 is Saturday. Next we must get day of week
for last day of month that precedes April, in other words we must find out day of week for 31 March
(that's Thursday).
Then we just add days and take rest modulo seven and we are done: 7 April is Thursday too. 
This is illustrated on image below:
![Computing day of week backwards example](assets/images/2016-06-15/backwards.svg)

To compute day of week for last day of prev month we will use formula:
{% highlight no-highlight %}
// DOW = day of week
dow_last_day_of_prev_month = (
    dow_last_day_of_year - 
    number_of_days_from_prev_month_last_day_to_end_of_year
    ) % 7;
{% endhighlight %}
Notice that we are *subtracting* two values modulo seven to move backwards.
Unfortunately in Java modulo can return negative values when used with negative numbers e.g.
{% highlight Java %}
> -32 % 7
-4
{% endhighlight %}
To solve this problem we will use simple fact from
[modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic):
{% highlight no-highlight %}
(a - b) % 7 = (a + (7 - (b%7))) % 7
notice that (7 - (b%7)) cannot be negative 
because 0 <= (b%7) < 7
    
for example:
(5 - 3) % 7 = 2 % 7 = 2
(5 + (7 - (3%7)) % 7 = (5 + (7 - 3)) % 7 =
        = (5 + 4) % 7 = 9 % 7 = 2
{% endhighlight %}
Now we will be guaranteed to get a number that represents valid day of week.

Full algorithm looks like this:
{% highlight Java %}
int dayOfWeekBackwards(
        int dayOfWeek31DecCurrYear, int year, int month, int day) 
{
// number of days from last day of previous month to the year end
// int[] daysToEndOfTheYear = 
//    { 365, 334, 306, 275, 245, 214, 184, 153, 122, 92, 61, 31 };

    // notice: we use our modulo formula here
    // days[i] = 7-(daysToTheEndOfTheYear[i]%7)
    // thanks to this we may write later
    // (lastDay + days[i]) % 7 instead of
    // (lastDay - daysToEndOfTheYear[i]) % 7
    int[] days = { 6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };
    int delta = days[month-1];

    if (month <= 2) {
        // for leap years in Jan or Feb
        // there is one more day to year end

        // again we add to avoid subtraction
        // (x - 1) % 7 == (x + 6) % 7
        delta += isLeap(year) ? 6 : 0;
    }
    
    int dayOfWeekLastDayPrevMonth = 
        (dayOfWeek31DecCurrYear + delta) % 7;

    return (dayOfWeekLastDayPrevMonth + day) % 7;
}
{% endhighlight %}

Now we can combine our forward and backward approaches to create one simple algorithm:
{% highlight Java %}
int dayOfWeekComb(int y, int m, int d) {
    int dayOfWeekDec31 = (m <= 2)
            // count from prev year
            ? numberOfDaysInYears(y-1)
            // count from end of curr year
            : numberOfDaysInYears(y);

    // number of days -> day of week
    dayOfWeekDec31 = dayOfWeekDec31 % 7;

    // 0,31 - comes from our first algorithm
    // rest of values comes from backward algorithm
    int[] days = { 0, 31,  2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    int dayOfWeekPrevMonthLastDay = 
        (dayOfWeekDec31 + days[m-1]) % 7;

    return (dayOfWeekPrevMonthLastDay + d) % 7;
}
{% endhighlight %}
Before we end let's try to use refactoring to simplify code further.
Let's start with statement:
{% highlight java %}
int dayOfWeekDec31 = (m <= 2)
        // count from prev year
        ? numberOfDaysInYears(y-1)
        // count from end of curr year
        : numberOfDaysInYears(y);
{% endhighlight %}
Since this is the only place that use `y` we can refactor this code into:
{% highlight java %}
y -= (m <= 2) ? 1 : 0;
int dayOfWeekDec31 = numberOfDaysInYears(y);
{% endhighlight %}
Then we can inline `numberOfDaysInYears` function:
{% highlight java %}
y -= (m <= 2) ? 1 : 0;
int dayOfWeekDec31 = 365*y + y/4 - y/100 + y/400;

dayOfWeekDec31 = dayOfWeekDec31 % 7;
{% endhighlight %}
Next since `365*y % 7 == 1*y % 7` and `(a + b) % 7 == (a % 7 + b % 7) % 7` we can
simplify further:
{% highlight java %}
int dayOfWeekComb(int y, int m, int d) {
    y -= (m <= 2) ? 1 : 0;
    int dayOfWeekDec31 = (y + y/4 - y/100 + y/400) % 7;

    int[] days = { 0, 31,  2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    int dayOfWeekPrevMonthLastDay = 
        (dayOfWeekDec31 + days[m-1]) % 7;

    return (dayOfWeekPrevMonthLastDay + d) % 7;
}
{% endhighlight %}
Finally because `31 % 7 == 3`, and combining all additions into single expression we get:
{% highlight java %}
int dayOfWeekComb(int y, int m, int d) {
    int[] days = { 0, 3,  2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    y -= (m <= 2) ? 1 : 0;
    return (y + y/4 - y/100 + y/400 + days[m-1] + d) % 7;
}
{% endhighlight %}
which is exactly Tomohiko Sakamoto algorithm.

Wow! This post turned out to be rather lengthy, 
if you are still with me thank you for your effort and hard work!


	  ]]></description>
	</item>


</channel>
</rss>

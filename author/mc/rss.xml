<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Binary to Gray algorithm explained</title>
	  <link>//binary-to-gray-algorithm-explained</link>
	  <author></author>
	  <pubDate>2019-12-17T01:00:01+01:00</pubDate>
	  <guid>//binary-to-gray-algorithm-explained</guid>
	  <description><![CDATA[
	     <p>Binary to Gray code conversion algorithm is deceptively simple:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/* This function converts an unsigned binary
 * number to reflected binary Gray code.
 *
 * The operator &gt;&gt; is shift right. The operator ^ is exclusive or.
 *
 * Source: https://en.wikipedia.org/wiki/Gray_code
 */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">binaryToGray</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">num</span> <span class="o">^</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>in this article I will explain how it works.</p>

<h4 id="gray-code">Gray code</h4>

<p>Gray code is a binary code in which two consecutive
values differ only by a single bit.
Three-bit Gray code, along its binary counterpart,
looks like this:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">|         BINARY|           GRAY|
|            000|            000|
|            001|            001|
|            010|            011|
|            011|            010|
|            100|            110|
|            101|            111|
|            110|            101|
|            111|            100|</code></pre></figure>

<p><code class="highlighter-rouge">N+1</code>-bit Gray code can be easily constructed
from <code class="highlighter-rouge">N</code>-bit Gray code using the following process:</p>

<p><img src="assets/images/2019-12-17/gn1.svg" alt="Making N+1-bit Gray code from N-bit Gray code" /></p>

<p>This variant of Gray code is often called reflected binary Gray code.
The “Vertical Flip” step is nothing else than creating
a mirror image of the code in vertical direction.</p>

<p>The above process, with the fact that <code class="highlighter-rouge">1</code>-bit Gray code
consists just of values <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>,
allows us to write a recursive algorithm for converting 
between corresponding binary and Gray code values.</p>

<h4 id="recursive-algorithm">Recursive algorithm</h4>

<p>We will define a function <code class="highlighter-rouge">G(nbits, n)</code> that returns
<code class="highlighter-rouge">n</code>th <code class="highlighter-rouge">nbits</code>-bit Gray code value.
<code class="highlighter-rouge">n</code> must be in range <code class="highlighter-rouge">0</code> .. <code class="highlighter-rouge">2**nbits - 1</code>
(where <code class="highlighter-rouge">**</code> means power).</p>

<p>For <code class="highlighter-rouge">nbits</code> equal to 1 this is trivial:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">func G(nbits, n) {
   if (nbits &lt;= 1) return n;
   ???
}</code></pre></figure>

<p>we return <code class="highlighter-rouge">0</code> when <code class="highlighter-rouge">n</code> is zero, and one when
<code class="highlighter-rouge">n</code> is one.</p>

<p>Next we need to translate the process from the first picture
into code:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">var msbBit = msb(nbits, n)

if (msbBit == 0) {
   return msbBit | G(nbits-1, n); 
}
else {
   // clear MSB bit
   var nWithoutMsb = n &amp; ~msbBit;
   var nonReflectedPos = pow(2, nbits-1)-1 - nWithoutMsb;

   return msbBit | G(nbits-1, nonReflectedPos)
}</code></pre></figure>

<p>Where <code class="highlighter-rouge">msb</code> is a simple function that returns
the <em>most significant bit</em> (MSB for short) of
an <code class="highlighter-rouge">nbits</code>-bit number <code class="highlighter-rouge">n</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">func msb(nbits, n) {
   return n &amp; (1 &lt;&lt; (nbits-1));
}</code></pre></figure>

<p>Similarly we will use LSB term to refer to
the <em>least significant bit</em> of a number.</p>

<p>There are two key observations that we must make to
understand how the algorithm works.
First observation is that binary values
share the same value of MSB bit with the corresponding
Gray code values.
<img src="assets/images/2019-12-17/g2.svg" alt="MSB and LSB in our algorithm" />
This is the result of the construction process,
that adds leading zeros to the upper half (blue) of the Gray code,
and leading ones to the lower half (red) of the code.</p>

<p>When <code class="highlighter-rouge">MSB = 0</code> we are in the upper half (blue) of the <code class="highlighter-rouge">nbits</code>-bit
Gray code, which was constructed from the <code class="highlighter-rouge">nbits-1</code>-bit Gray
code by adding extra <code class="highlighter-rouge">0</code> as a prefix to its values.
In this case we just call recursively <code class="highlighter-rouge">G(nbits-1, n)</code>
(<code class="highlighter-rouge">n</code> is in this case <code class="highlighter-rouge">&lt; 2**nbits/2 = 2**(nbits-1)</code>),
and add a <code class="highlighter-rouge">0</code> as a prefix to the result to
finish the conversion to <code class="highlighter-rouge">nbits</code>-bit code.</p>

<p>When <code class="highlighter-rouge">MSB = 1</code> we are in the lower half (red) of the code, that
was constructed by vertically flipping <code class="highlighter-rouge">nbits-1</code>-bit Gray
code and adding <code class="highlighter-rouge">1</code> as a prefix to its values.
<img src="assets/images/2019-12-17/g3.svg" alt="Relation between simple and reflected code" />
The second key observation here, is the relationship between
reflected <code class="highlighter-rouge">nbits-1</code>-bit Gray code and its non-reflected counterpart.
<code class="highlighter-rouge">nbits-1</code>-bit Gray value that is located
at <code class="highlighter-rouge">x</code>th position in the red (reflected)
area is exactly the same as 
<code class="highlighter-rouge">2**(nbits-1)-1 - x</code>th value located in the blue area.
To convert <code class="highlighter-rouge">n</code> into <code class="highlighter-rouge">nbits-1</code> Gray code, first
we remove <code class="highlighter-rouge">1</code> MSB bit from it, converting
it basically into our <code class="highlighter-rouge">x</code>
(zero-based offset from the beginning of the red area; see the picture above).
Then we compute position of <code class="highlighter-rouge">x</code>s counterpart in
the non-reflected (blue) area of the code, by using expression:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">var nonReflectedPos = pow(2, nbits-1)-1 - nWithoutMsb;</code></pre></figure>

<p>Then we call <code class="highlighter-rouge">G(nbits-1, nonReflectedPos)</code> to
compute <code class="highlighter-rouge">nbits-1</code>-bit Gray code value
and finally we restore <code class="highlighter-rouge">1</code> bit prefix to it.</p>

<p>The above algorithm expressed in Java:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">msb</span><span class="o">(</span><span class="kt">int</span> <span class="n">nbits</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">G</span><span class="o">(</span><span class="kt">int</span> <span class="n">nbits</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">nbits</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>

   <span class="kt">int</span> <span class="n">msbBit</span> <span class="o">=</span> <span class="n">msb</span><span class="o">(</span><span class="n">nbits</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">msbBit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// We can skip 'msbBit |' part because</span>
      <span class="c1">// '(0 | x) == x'</span>
      <span class="k">return</span> <span class="n">msbBit</span> <span class="o">|</span> <span class="n">G</span><span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">else</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">nWithoutMsb</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">msbBit</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">nonReflectedPos</span> <span class="o">=</span> 
         <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">)-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nWithoutMsb</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">msbBit</span> <span class="o">|</span> <span class="n">G</span><span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nonReflectedPos</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="using-strings-to-represent-binary-values">Using Strings to represent binary values</h4>

<p>To further improve our algorithm we need to change
our representation of binary values from 32-bit integers
to strings. For example a string <code class="highlighter-rouge">"110"</code> will represent
a <code class="highlighter-rouge">3</code>-bit binary value. We will also use empty string
<code class="highlighter-rouge">""</code> to represent a sole zero-bit binary value
(after all <code class="highlighter-rouge">2**0 = 1</code>, so there is one such value).</p>

<p>To proceed further, we need two simple facts.
Fact 1: Numbers in form <code class="highlighter-rouge">2**k - 1</code> are represented in
binary by sequence of <code class="highlighter-rouge">k</code> ones.
For example <code class="highlighter-rouge">2**3-1 = 7</code> is <code class="highlighter-rouge">111</code> in binary.</p>

<p>Fact 2: Substracting <code class="highlighter-rouge">k</code>-bit value <code class="highlighter-rouge">p</code> from <code class="highlighter-rouge">1...1</code> (<code class="highlighter-rouge">k</code> ones)
is equal to negating <code class="highlighter-rouge">p</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">  11111111
- 01010011
----------
  10101100</code></pre></figure>

<p>These both facts will allow us to rewrite
the expression for computing <code class="highlighter-rouge">nonReflectedPos</code> value from:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// n is a nbits-bit number
// nWithoutMsb is a (nbits-1)-bit number
// 2**(nbits-1)-1 = 1...1 (nbits-1 ones in binary)
int nonReflectedPos = 
   (int)Math.pow(2, nbits-1)-1 - nWithoutMsb;</code></pre></figure>

<p>to</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// Simple binary negation
String nonReflectedPos = not(nWithoutMsb);</code></pre></figure>

<p>Our previous algorithm changed to use strings
and expressed in JavaScript:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">not</span><span class="p">(</span><span class="nx">bits</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">bits</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span>
    <span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">==</span> <span class="s1">'0'</span> <span class="p">?</span> <span class="s1">'1'</span> <span class="p">:</span> <span class="s1">'0'</span><span class="p">;</span> <span class="p">}).</span>
    <span class="nx">join</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">G</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="s1">''</span><span class="p">)</span> <span class="k">return</span> <span class="s1">''</span><span class="p">;</span> <span class="c1">// zero bit code</span>
  
  <span class="kd">var</span> <span class="nx">firstBit</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">firstBit</span> <span class="o">==</span> <span class="s1">'0'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'0'</span> <span class="o">+</span> <span class="nx">G</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'1'</span> <span class="o">+</span> <span class="nx">G</span><span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h4 id="the-single-line-algorithm">The single-line algorithm</h4>

<p>If we now look at the code of our algorithm, we
may see that all it does is to negate the unseen part of the
input every time we encounter <code class="highlighter-rouge">1</code> bit:
<img src="assets/images/2019-12-17/g4.svg" alt="Workings of the string based algorithm" /></p>

<p>Let us consider how our algorithm will transform
groups of ones followed by a single zero bit (<code class="highlighter-rouge">11...110</code>):
<img src="assets/images/2019-12-17/g5.svg" alt="How groups of 11...110 are transformed" />
As we can see group of <code class="highlighter-rouge">11...110</code> bits is transformed into <code class="highlighter-rouge">10...01</code>,
but what is more important: bits that are after this group remain unchanged.
Similarly groups of ones without trailing zero (<code class="highlighter-rouge">1...1</code>),
which may only occur at the end of the input are transformed into <code class="highlighter-rouge">10...0</code>.</p>

<p>Now is the time for another key observation: the above
transformations can be performed by XORing value with
itself shifted right by one:</p>

<p><img src="assets/images/2019-12-17/g6.svg" alt="Transforming groups of ones using XOR" /></p>

<p>This works because after the shift every group of ones must
be preceded by at least a single zero bit. 
Additionally every group of ones
(except when the ones occur at the end of the input)
must be followed by at least one zero bit.
In other words different groups of ones are not interfering with
each other while XORing.</p>

<p>Also notice that we must use right-shift operation that always
shifts-in a zero bit.
In Java this means using <code class="highlighter-rouge">&gt;&gt;&gt;</code> (unsigned right shift) 
instead of <code class="highlighter-rouge">&gt;&gt;</code> operator.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">binaryToGray</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">^</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Source code (GitHub Gist): <a href="https://gist.github.com/marcin-chwedczuk/efc4df9fbc1928afcb0466e34b3d94c3">grayBin.js</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>Converting .dsl files to Kindle dictionaries</title>
	  <link>//converting-dsl-files-to-kindle-dictionary</link>
	  <author></author>
	  <pubDate>2019-12-02T01:00:01+01:00</pubDate>
	  <guid>//converting-dsl-files-to-kindle-dictionary</guid>
	  <description><![CDATA[
	     <p>In this post, I will describe how to convert dictionaries
in <a href="http://lingvo.helpmax.net/en/troubleshooting/dsl-compiler/dsl-dictionary-structure/">ABBYY Lingvo’s format</a>
to <code class="highlighter-rouge">mobi</code> dictionaries that can work with Kindle.</p>

<p>I will assume that you already have appropriate <code class="highlighter-rouge">.dsl</code> files.
The first step is to make sure that <code class="highlighter-rouge">.dsl</code> files use UTF-8 encoding.
We may check a file encoding using <code class="highlighter-rouge">file</code> command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>file dict.dsl 
dict.dsl: Little-endian UTF-16 Unicode text, with CRLF line terminators</code></pre></figure>

<p>If you see something different than <code class="highlighter-rouge">UTF-8 Unicode (with BOM)</code>,
as in the above example, then you have to convert the files to UTF-8
first. We may use <code class="highlighter-rouge">iconv</code> for this purpose:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">iconv <span class="nt">-f</span> UTF-16LE <span class="nt">-t</span> UTF-8 dict.dsl <span class="nt">-o</span> dict-utf8.dsl</code></pre></figure>

<p>We need to make sure that <code class="highlighter-rouge">.dsl</code> files does not
contain metadata info (lines starting with <code class="highlighter-rouge">#</code> at the
beginning of the file):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">#NAME "Foo Dictionary"                                        
#INDEX_LANGUAGE "Russian"                                                
#CONTENTS_LANGUAGE  "Polish"                                             
а
...</code></pre></figure>

<p>If you see lines starting with <code class="highlighter-rouge">#</code> as in the above example, please
remove them.</p>

<p>Next we need to grab <code class="highlighter-rouge">dsl2mobi</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/Tvangeste/dsl2mobi.git

<span class="c"># Do I have ruby?</span>
ruby <span class="nt">-v</span>
<span class="nb">sudo </span>apt install ruby</code></pre></figure>

<p>You need to have <code class="highlighter-rouge">ruby</code> installed on your machine for the script
to work. Actually I don’t like running someone else’s code
on my machine, so I ran the script inside a virtual machine
(which, for security reasons, I also recommend you to do).</p>

<p>Now we can execute the script:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>dsl2mobi
chmod +x ./dsl2mobi.rb

./dsl2mobi.rb <span class="nt">-w</span> ./wordforms/forms-RU.txt <span class="se">\</span>
 <span class="nt">-i</span> ~/path-to/dict-utf8.dsl <span class="se">\</span>
 <span class="nt">-o</span> ~/output-dir</code></pre></figure>

<p>In a lot of languages, the same word can occur in 
different forms, for example 
in English the word “write” can occur in forms: wrote, written, writes.
We want our dictionary to recognize all these variations,
and for this reason we need the so called <em>wordforms</em>.
Fortunately for us <code class="highlighter-rouge">dsl2mobi</code> comes with a buildin
wordforms files for several languages.
If you want to create a dictionary from e.g. Russian to
Polish you need to use Russian wordforms (as in our example).
If you want to create a dictionary from English to Russian
you would need to use English wordforms, etc.</p>

<p><code class="highlighter-rouge">dsl2mobi</code> should create at least two files in the
<code class="highlighter-rouge">output-dir</code>, one with <code class="highlighter-rouge">.html</code> extension (containing
actual content) and one with <code class="highlighter-rouge">.opf</code>
extension (containing metadata).</p>

<p>Next we need to 
<a href="https://www.amazon.com/gp/feature.html?ie=UTF8&amp;docId=1000765211">grab KindleGen from Amazon</a>
to actually generate <code class="highlighter-rouge">mobi</code> files:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./kindlegen  ~/output-dir/dict.opf <span class="nt">-o</span> dict.mobi <span class="nt">-verbose</span> <span class="nt">-c2</span></code></pre></figure>

<p>We use <code class="highlighter-rouge">-c2</code> option to compress the dictionary.</p>

<p>Unfortunately, in my case <code class="highlighter-rouge">kindlegen</code> does not wanted to
convert <code class="highlighter-rouge">.opf</code> file generated by <code class="highlighter-rouge">dsl2mobi</code>.
To make it work, I needed to edit my <code class="highlighter-rouge">.opf</code> file to:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE package SYSTEM "oeb1.ent"&gt;</span>
<span class="nt">&lt;package</span> <span class="na">unique-identifier=</span><span class="s">"uid"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;metadata&gt;</span>
    <span class="nt">&lt;dc-metadata</span> <span class="na">xmlns:dc=</span><span class="s">"http://purl.org/metadata/dublin_core"</span> <span class="na">xmlns:oebpackage=</span><span class="s">"http://openebook.org/namespaces/oeb-package/1.0/"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dc:Identifier</span> <span class="na">id=</span><span class="s">"uid"</span><span class="nt">&gt;</span>dic<span class="nt">&lt;/dc:Identifier&gt;</span>
      <span class="c">&lt;!-- Title of the document --&gt;</span>
      <span class="nt">&lt;dc:Title&gt;</span>Ru-Pl Dictionary<span class="nt">&lt;/dc:Title&gt;</span>
      <span class="nt">&lt;dc:Language&gt;</span>ru<span class="nt">&lt;/dc:Language&gt;</span>
      <span class="nt">&lt;dc:Subject</span> <span class="na">BASICCode=</span><span class="s">"REF008000"</span><span class="nt">&gt;</span>Dictionaries<span class="nt">&lt;/dc:Subject&gt;</span>
      <span class="nt">&lt;dc:Creator&gt;</span>linuxboy<span class="nt">&lt;/dc:Creator&gt;</span>
      <span class="nt">&lt;dc:Publisher&gt;</span>pinguin<span class="nt">&lt;/dc:Publisher&gt;</span>
      <span class="nt">&lt;dc:Description&gt;</span>Generated by Dsl2Mobi-1.2-dev on 2019-11-28.<span class="nt">&lt;/dc:Description&gt;</span>
    <span class="nt">&lt;/dc-metadata&gt;</span>
    <span class="nt">&lt;x-metadata&gt;</span>
      <span class="nt">&lt;output</span> <span class="na">encoding=</span><span class="s">"utf-8"</span> <span class="na">content-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;DictionaryInLanguage&gt;</span>ru<span class="nt">&lt;/DictionaryInLanguage&gt;</span>
      <span class="nt">&lt;DictionaryOutLanguage&gt;</span>pl<span class="nt">&lt;/DictionaryOutLanguage&gt;</span>
    <span class="nt">&lt;/x-metadata&gt;</span>
  <span class="nt">&lt;/metadata&gt;</span>

  <span class="c">&lt;!-- list of all the files needed to produce the .mobi file --&gt;</span>
  <span class="nt">&lt;manifest&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item1"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
  <span class="nt">&lt;/manifest&gt;</span>

  <span class="c">&lt;!-- list of the html files in the correct order  --&gt;</span>
  <span class="nt">&lt;spine&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/spine&gt;</span>

  <span class="nt">&lt;tours/&gt;</span>
  <span class="nt">&lt;guide&gt;</span>
   <span class="nt">&lt;reference</span> <span class="na">type=</span><span class="s">"toc"</span> <span class="na">title=</span><span class="s">"Table of Contents"</span> <span class="na">href=</span><span class="s">"dict.html#toc"</span><span class="nt">&gt;&lt;/reference&gt;</span>
  <span class="nt">&lt;/guide&gt;</span>
<span class="nt">&lt;/package&gt;</span></code></pre></figure>

<p>Also make that <code class="highlighter-rouge">DictionaryInLanguage</code> and <code class="highlighter-rouge">DictionaryOutLanguage</code>
tags have proper values, otherwise your dict may not work
on Kindle.</p>

<p>I also had to change the beginning of the <code class="highlighter-rouge">dict.html</code> file to:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:idx=</span><span class="s">"www.mobipocket.com"</span> <span class="na">xmlns:mbp=</span><span class="s">"www.mobipocket.com"</span> <span class="na">xmlns:xlink=</span><span class="s">"http://www.w3.org/1999/xlink"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"dic.css"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Type"</span> <span class="na">content=</span><span class="s">"text/html;charset=UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;center&gt;</span>
      <span class="nt">&lt;h1&gt;</span>Generated by Dsl2Mobi-1.2-dev<span class="nt">&lt;/h1&gt;</span>
      <span class="nt">&lt;hr</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/center&gt;</span>
    <span class="nt">&lt;mbp:pagebreak</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">name=</span><span class="s">"toc"</span><span class="nt">&gt;&lt;/a&gt;</span>
    <span class="nt">&lt;mbp:pagebreak</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- DICTIONARY ENTRIES --&gt;</span>
<span class="nt">&lt;a</span> <span class="na">name=</span><span class="s">"#а"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;idx:entry</span> <span class="na">name=</span><span class="s">"word"</span> <span class="na">scriptable=</span><span class="s">"yes"</span><span class="nt">&gt;</span>
<span class="nt">&lt;font</span> <span class="na">size=</span><span class="s">"6"</span> <span class="na">color=</span><span class="s">"#002984"</span><span class="nt">&gt;&lt;b&gt;&lt;idx:orth&gt;</span>а
<span class="nt">&lt;/idx:orth&gt;&lt;/b&gt;&lt;/font&gt;</span>
<span class="nt">&lt;idx:orth</span> <span class="na">value=</span><span class="s">"a"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"dsl_m0"</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">"dsl_p"</span><span class="nt">&gt;&lt;i&gt;&lt;font</span> <span class="na">color=</span><span class="s">"green"</span><span class="nt">&gt;</span>Spójnik<span class="nt">&lt;/font&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;</span>
...</code></pre></figure>

<p>After these changes I was able to generate a <code class="highlighter-rouge">.mobi</code> file that
worked perfectly with my Kindle.</p>

<p>If your dictionary is really huge (the <code class="highlighter-rouge">.html</code> file bigger than 20MB),
KindleGen may either take a lot of time (a few hours) or
it may not finish at all.
In this case I advice you to split, the single <code class="highlighter-rouge">.html</code> files
into three or four smaller files (each should be less than 20MB),
and then to add them as “chapters” to the <code class="highlighter-rouge">.opf</code> file:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml">  <span class="c">&lt;!-- list of all the files needed to produce the .mobi file --&gt;</span>
  <span class="nt">&lt;manifest&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item1"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-1.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item2"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-2.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item3"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-3.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item4"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-4.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
  <span class="nt">&lt;/manifest&gt;</span>

  <span class="c">&lt;!-- list of the html files in the correct order  --&gt;</span>
  <span class="nt">&lt;spine&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item4"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/spine&gt;</span></code></pre></figure>

<p>You can use <code class="highlighter-rouge">wc</code>, <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> for the splitting:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cat </span>dict.html | wc <span class="nt">-l</span>
1792747
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">$((</span><span class="m">1792747</span> <span class="o">/</span> <span class="m">2</span><span class="k">))</span>
896373
<span class="nv">$ </span><span class="nb">cat </span>dict.html | head <span class="nt">-n</span> 896373 <span class="o">&gt;</span> dict-1-2.html
<span class="nv">$ </span><span class="nb">cat </span>dict.html | tail <span class="nt">-n</span> +896373 <span class="o">&gt;</span> dict-3-4.html
<span class="c"># Split files one more time to have four parts</span></code></pre></figure>

<p>Then you have to use <code class="highlighter-rouge">vim</code> or other editor to make sure that
all files have proper <code class="highlighter-rouge">&lt;head&gt;</code> sections, and
are properly ended with <code class="highlighter-rouge">&lt;/body&gt;&lt;/html&gt;</code>.
You will also have to make sure that dictionary
entries are not split across the files.
They are quite easy to recognize, as they
usually start with <code class="highlighter-rouge">&lt;a&gt;</code> tag followed by <code class="highlighter-rouge">&lt;idx:entry&gt;</code> tag.</p>

<p>KindleGen needed around 1h of time to convert 80MB
split into four parts, so be prepared to wait for a bit.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Fun with AT commands and an old modem</title>
	  <link>//fun-with-at-commands-and-old-modem</link>
	  <author></author>
	  <pubDate>2019-09-21T02:00:01+02:00</pubDate>
	  <guid>//fun-with-at-commands-and-old-modem</guid>
	  <description><![CDATA[
	     <p>Recently, while cleaning my flat, I found an old Huawei E3131
USB modem. I planed to throw it away, but then I reminded myself
that this simple device, as virtually all modems, supports a
primitive text based interface known as “AT commands”.
And so I started thinking about
spending a few hours of my time
sending AT commands and figuring out what is actually
possible.
This post is the result of this few hours of hacking. Enjoy!</p>

<p>When I connected the modem to my PC it was immediately
recognized as both an USB Drive and an GSM modem.
Grepping through <code class="highlighter-rouge">dmesg</code> revealed that three serial port
terminals where created at <code class="highlighter-rouge">/dev/ttyUSB0</code>,
<code class="highlighter-rouge">/dev/ttyUSB1</code> and <code class="highlighter-rouge">/dev/ttyUSB2</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ dmesg | grep tty
[29167.640728] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB0
[29167.640808] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB1
[29167.640861] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB2</code></pre></figure>

<p>To be honest I expected only a single <code class="highlighter-rouge">tty</code> file…</p>

<p>Running <code class="highlighter-rouge">stty</code> command on <code class="highlighter-rouge">ttyUSB0</code> returned
some useful information, including
<a href="https://en.wikipedia.org/wiki/Symbol_rate">baud rate</a>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ stty -F /dev/ttyUSB0
speed 9600 baud; line = 0;
eof = ^A; min = 1; time = 0;
-brkint -icrnl ixoff ixany -imaxbel
-opost -onlcr
-icanon -echo -echoe</code></pre></figure>

<p><code class="highlighter-rouge">-</code> before an option name means that this option is disabled.
Explanations for all options can be found in <code class="highlighter-rouge">man stty</code>.
For example <code class="highlighter-rouge">-echo</code> means that the characters that we
are writing, are not visible on the screen.
That is not very comfortable but can be changed easily
(you can try it yourself in bash by executing <code class="highlighter-rouge">stty -echo</code>
to disable
and <code class="highlighter-rouge">stty echo</code> to enable echo).</p>

<p>To connect to <code class="highlighter-rouge">ttyUSB0</code> I used <code class="highlighter-rouge">minicom</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt install minicom</code></pre></figure>

<p>We need to create a <code class="highlighter-rouge">minicom</code> configuration first.
For some reason <code class="highlighter-rouge">minicom</code> was not
able to save it’s config file in my home directory and
insisted on saving it into <code class="highlighter-rouge">/etc/minicom/</code> and so I
have to run it with <code class="highlighter-rouge">sudo</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>minicom <span class="nt">-s</span></code></pre></figure>

<p>Configuring <code class="highlighter-rouge">minicom</code> is like a journey to 80s,
entire UI is text based:
<img src="/assets/images/2019-09-23/mc-main-menu.png" alt="minicom main menu" />
First we need to go into “Serial port setup” section:
<img src="/assets/images/2019-09-23/mc-serial-port.png" alt="minicom serial port setting" />
and change “Serial Device” to <code class="highlighter-rouge">/dev/ttyUSB0</code> 
(to do this press A, change the field value and press either 
Enter to save or Escape to cancel).
Then we need to change baud rate (press E):
<img src="/assets/images/2019-09-23/mc-baud-rate.png" alt="minicom baud rate setting" />
On this screen press C and then Enter.
Next we need to go into “Screen and Keyboard” section and
enable echo (press Q) and then Enter:
<img src="/assets/images/2019-09-23/mc-scrn-kbd.png" alt="minicom screen and keyboard settings" />
We need to enable <em>local</em> echo (on the minicom side)
because, as <code class="highlighter-rouge">stty</code> indicated
the serial port itself does not support it.</p>

<p>Then we need to return to the main menu (press Enter)
and select “Save setup as…” option. I saved
my config under <code class="highlighter-rouge">huawei2</code> name. Then we should choose
“Exit from Minicom”. If you chose “Exit” use Ctrl+A
followed by X to exit.</p>

<p>Now we can start <code class="highlighter-rouge">minicom</code> without <code class="highlighter-rouge">sudo</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">minicom huawei2</code></pre></figure>

<p>and execute our first AT command which is just <code class="highlighter-rouge">AT</code>.
The modem should respons with <code class="highlighter-rouge">OK</code> if everything works:
<img src="/assets/images/2019-09-23/mc-w1.png" alt="minicom working" /></p>

<p>To find out what options are supported by my
modem, I googled for “huawei e3131 at command interface specification”
and found a PDF document describing supported AT commands.
By the way AT commands are 
<a href="https://en.wikipedia.org/wiki/De_facto_standard">de facto standard</a>
and could be used with any modem.</p>

<p>TIP: To exit <code class="highlighter-rouge">minicom</code> press Ctrl+A followed by X (must be upper case).</p>

<p>WARNING: In the following sections I assume that we
inserted a working SIM card into the modem.</p>

<h4 id="obtaining-information-from-the-modem">Obtaining information from the modem</h4>

<p>We can obtain a lot of information about our modem and
the SIM card just by running AT commands.
For example we may ask the modem for its phone number:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CNUM

+CNUM: "NUMER WLASNY","+48999123999",145

OK</code></pre></figure>

<p>(“NUMER WLASNY” is “MY OWN NUMBER” in Polish),
or for its IMEI number:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CGSN

865459999999999

OK</code></pre></figure>

<p>To read a modem flag or a setting we need to run a command
in <code class="highlighter-rouge">AT+CMD?</code> format.
For example to obtain the character set used by the modem
we send <code class="highlighter-rouge">AT+CSCS?</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS?

+CSCS: "IRA"

OK</code></pre></figure>

<p>To check what values are acceptable for this flag
we run a command in <code class="highlighter-rouge">AT+CMD=?</code> format:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS=?

+CSCS: ("IRA","UCS2","GSM")

OK</code></pre></figure>

<p>And to set flag/setting value we execute 
a command in <code class="highlighter-rouge">AT+CMD=value</code> format like <code class="highlighter-rouge">AT+CSCS="GSM"</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS="GSM"

OK
AT+CSCS?

+CSCS: "GSM"

OK</code></pre></figure>

<p>Network signal strength can be checked using <code class="highlighter-rouge">AT+CSQ</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSQ

+CSQ: 23,99

OK</code></pre></figure>

<p>The response has format <code class="highlighter-rouge">+CSQ: signal-strength, error-rate</code>.
Signal strength varies from 31 (very good)
to 0 (very poor / lack of signal).
In my case bit error rate is not supported (99) by the modem.</p>

<p><code class="highlighter-rouge">AT+COPS</code> command allows us to check the
current network and to get a list of
the present networks:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+COPS?

+COPS: 0,0,"Plus",0

OK
AT+COPS=?

+COPS: (2,"Plus","PLUS","26001",0),
 (1,"Plus","PLUS","26001",2),
 (3,"T-Mobile PL","T-Mobile PL","26002",2),
 (3,"Orange PL","Orange","26003",2),
 //... OUTPUT TRUNCATED

OK</code></pre></figure>

<h4 id="sending-ussd-codes">Sending USSD codes</h4>

<p>USSD codes (short codes) like “*100#” are quite useful,
we can use them to check money amount on our account or
to change the current tariff.
Let’s see how to send them using AT commands.
First hurdle to overcome is 
the encoding used while sending an USSD code.
By default the codes must be encoded using
GSM7Bit encoding, which is not
related to 7-bit ASCII in any way.
I couldn’t find any online encoder/decoder for this
encoding, but fortunatelly
I found a pice of code that does exactly what we want:
<a href="https://github.com/bsimic0001/AegisWallet/blob/master/mobile/src/main/java/com/aegiswallet/utils/MessagingUtils.java">MessagingUtils.java</a>
And so I added a <code class="highlighter-rouge">main</code> method and pasted the code to 
<a href="https://www.compilejava.net/">www.compilejava.net</a>
to obtain an online converter. 
You can see the final, “paste ready” code
<a href="https://gist.github.com/marcin-chwedczuk/96f7f2a310ca416bed88a6dc10b7abc6">here</a>.</p>

<p>Encoding <code class="highlighter-rouge">*100#</code> in GSM7Bit gives us <code class="highlighter-rouge">AA180C3602</code>.
Now we may issue our USSD request using <code class="highlighter-rouge">AT+CUSD</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">OK
AT+CUSD=1,"AA180C3602",15

OK

+CUSD: 0,"C135BD1E66BBF3A0393DEC06ADDF6E7A1844668741EE7ABB2CAF8368B85C2E97CBE572B91C48078AB160301094E97481966F37FD0DBA87F5EE3288FC0691DDE93048866BC1722D192C9603C5623A1A4D378301",15</code></pre></figure>

<p><code class="highlighter-rouge">1</code> (first value in the request) means that we want to see the response,
<code class="highlighter-rouge">15</code> (the last value) is the encoding type that we are using.</p>

<p>Next we need to use our GSM7Bit decoder to obtain plain
text from the network response (in Polish):</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Aktualny stan konta dla numeru 48999999999 : 1,00 PLN.
Konto wazne do dnia 28-09-2019 11:44:30</code></pre></figure>

<h4 id="sending-and-receiving-sms">Sending and receiving SMS</h4>

<p>Our next step will be to send and to receive an SMS:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGF=1

OK
AT+CMGS="+48333666999"

&gt; Hello, world!
+CMGS: 7

OK</code></pre></figure>

<p>Before we send a message we must switch to the text mode,
which can be done by issuing <code class="highlighter-rouge">AT+CMGF=1</code> command.
The default mode is the PDU mode, which requires
creating and parsing PDU binary frames.</p>

<p>To send an SMS <code class="highlighter-rouge">AT+CMGS="phone-number"</code> command is used.
After executing <code class="highlighter-rouge">AT+CMGS</code>, a command prompt (<code class="highlighter-rouge">&gt;</code>) will
appear allowing us to write our message.
When we are done we press Ctrl+Z,
few seconds later the message will be delivered.</p>

<p>To list received and sent messages we can use <code class="highlighter-rouge">AT+CMGL</code>
command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGL=?

+CMGL: ("REC UNREAD","REC READ","STO UNSENT","STO SENT","ALL")

OK
AT+CMGL="ALL"

+CMGL: 0,"REC READ","+48111222333",,"19/09/23,16:01:42+08"
 Pszczolka Maja

OK</code></pre></figure>

<p>Remember to run this command in the text mode (<code class="highlighter-rouge">AT+CMGF=1</code>),
otherwise you will see hex encoded binary PDU frames.</p>

<p>First value in the row is the message index (<code class="highlighter-rouge">0</code>).
We may use this index to either read the message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGR=0

+CMGR: "REC READ","+48111222333",,"19/09/23,16:13:03+08"
 Pszczolka Maja</code></pre></figure>

<p>or to remove it:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGD=0

OK
AT+CMGL="ALL"

OK</code></pre></figure>

<h4 id="playing-with-the-phone-book-entries">Playing with the phone book entries</h4>

<p><code class="highlighter-rouge">AT+CPBR</code> command can be used to read SIM card phone book entries:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBR=?

+CPBR: (1-250),40,20

OK
AT+CPBR=1,10

+CPBR: 1,"*110#",129,"Obsluga konta"
+CPBR: 2,"112",129,"Nr.alarmowy112"
+CPBR: 3,"999",129,"Pogotowie Rat."
+CPBR: 4,"997",129,"Policja"
+CPBR: 5,"998",129,"Straz pozarna"
+CPBR: 6,"+48601100100",145,"WOPR"
+CPBR: 7,"+48601100300",145,"GOPR/TOPR"
+CPBR: 8,"+48601102601",145,"Biuro obslugi"
+CPBR: 9,"5555",129,"Zasil konto"
+CPBR: 10,"*100#",129,"Stan konta"</code></pre></figure>

<p><code class="highlighter-rouge">AT+CPBR=?</code> returns supported range of indexes (<code class="highlighter-rouge">(1-250)</code>; some of them
may be empty), max. phone number length (<code class="highlighter-rouge">40</code>) and max.
entry name length (<code class="highlighter-rouge">20</code>).
Using this information we may read phone book entries using
<code class="highlighter-rouge">AT+CPBR=&lt;&lt;index-range&gt;&gt;</code> command.
When the phone number starts with <code class="highlighter-rouge">+</code> its type is <code class="highlighter-rouge">145</code>
otherwise its type is <code class="highlighter-rouge">129</code>.</p>

<p>Adding a phone book entry is very simple:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBW=25,"111222333",129,"foo"

OK
AT+CPBR=25

+CPBR: 25,"111222333",129,"foo"

OK</code></pre></figure>

<p>The same command can be used to remove a phone book entry:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBW=25

OK
AT+CPBR=25

+CME ERROR: 22</code></pre></figure>

<h4 id="ring-ring-ring">RING RING RING</h4>

<p>AT commands can also be used to make and receive phone calls.
Voice is send/received in WAVE format.
Unfortunately I cannot obtain even a simplest <code class="highlighter-rouge">RING</code> notification
from my modem.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Ultimate guide to Scala's match expression</title>
	  <link>//ultimate-guide-to-scalas-match-expression</link>
	  <author></author>
	  <pubDate>2019-09-19T02:00:01+02:00</pubDate>
	  <guid>//ultimate-guide-to-scalas-match-expression</guid>
	  <description><![CDATA[
	     <p>Scala <code class="highlighter-rouge">match</code> expression is a very powerful tool.
In hands of an experienced developer it can be used to
create concise and easy to understand code,
yet novice programmers are often intimidated by it.
In this blog post I will describe how <code class="highlighter-rouge">match</code> expression
work. We will start with the basics and finish with the extractors.
After reading this post you will know how <code class="highlighter-rouge">case List(a, b, c)</code>
works and you will be able to write your own extractors.</p>

<h4 id="pattern-matching-values">Pattern matching values</h4>

<p><code class="highlighter-rouge">match</code> expression can be used (just like Java’s <code class="highlighter-rouge">switch</code>)
as a more robust <code class="highlighter-rouge">if</code> statement replacement.
For example we can write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">command</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">fetchNextCommand</span><span class="o">()</span>

<span class="n">command</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"ls"</span> <span class="k">=&gt;</span> <span class="n">printDirectoryContents</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"ps"</span> <span class="k">=&gt;</span> <span class="n">printProcesses</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"exit"</span> <span class="k">=&gt;</span> <span class="n">exitShell</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> expression, in opposite to Java’s <code class="highlighter-rouge">switch</code> is not
limited to strings, Enums and numeric types, but can also match
booleans, floating point numbers (although this isn’t a good idea)
and <code class="highlighter-rouge">null</code> literal.
We can also mix multiple value types in a single <code class="highlighter-rouge">match</code>
expression:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mf">3.1415</span>

<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's true"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"integer 3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mf">3.1415</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pi approximation"</span><span class="o">)</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"null"</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">"foo"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"this 'foo' again!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="sc">'a'</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"character 'a'"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">pi</span> <span class="n">approximation</span></code></pre></figure>

<p>When we match an Enum value we are not required to
provide cases for all possible values of the Enum:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Color</span> <span class="o">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">White</span><span class="o">,</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Black</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">skyColor</span> <span class="k">=</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span>

<span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">weatherWildGuess</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">rain</span><span class="o">?</span></code></pre></figure>

<p>When a value cannot be pattern matched
a <code class="highlighter-rouge">scala.MatchError</code> runtime exception is thrown.
A special “catch all” case can be
provided to handle all previously unmatched values 
(Scala’s <code class="highlighter-rouge">case _</code> is a counterpart to Java’s <code class="highlighter-rouge">switch</code> <code class="highlighter-rouge">default</code> label):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"I don't know"</span>
<span class="o">}</span></code></pre></figure>

<p>“catch all” case should be the last one. 
Patterns are matched from top to bottom and the procedure
stops on the first matching <code class="highlighter-rouge">case</code> clause.</p>

<p>Sometimes we want to access the value matched by “catch all” case,
this can be done by replacing wildcard pattern (<code class="highlighter-rouge">_</code>)
with a variable name:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="n">unknownColor</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">"Cannot guess weather for sky color: $unknownColor"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Often it is required to execute the same code for multiple values.
With <code class="highlighter-rouge">match</code> this can be done using <code class="highlighter-rouge">|</code> (pipe) operator:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">answer</span><span class="o">.</span><span class="n">toLowerCase</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"y"</span> <span class="o">|</span> <span class="s">"yes"</span> <span class="o">|</span> <span class="s">"ok"</span> <span class="o">|</span> <span class="s">"proceed"</span> <span class="k">=&gt;</span>
    <span class="n">executeOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"n"</span> <span class="o">|</span> <span class="s">"no"</span> <span class="o">|</span> <span class="s">"abort"</span> <span class="k">=&gt;</span>
    <span class="n">abortOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">askAgain</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> can also be used to match against <code class="highlighter-rouge">null</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">nullableValue</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> 

<span class="k">val</span> <span class="n">option</span> <span class="k">=</span> <span class="n">nullableValue</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Matching against Double <code class="highlighter-rouge">NaN</code> value is more problematic, since
<code class="highlighter-rouge">NaN == NaN</code> must always return <code class="highlighter-rouge">false</code> according to IEEE 754
Standard. To match against <code class="highlighter-rouge">NaN</code> we need to use a pattern guard:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span> <span class="k">=&gt;</span> <span class="s">"+∞"</span>

  <span class="c1">// WRONG way to match NaN
</span>  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">=&gt;</span> <span class="s">"this does not work"</span>
  <span class="c1">// RIGHT way to match NaN
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isNaN</span> <span class="k">=&gt;</span> <span class="s">"NaN"</span>

  <span class="c1">// catch-all
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span></code></pre></figure>

<p>We will return to pattern guards later.</p>

<h4 id="pattern-matching-class-instances">Pattern matching class instances</h4>

<p>Besides pattern matching primitive types, <code class="highlighter-rouge">match</code> can also be used
to compare normal class instances.
For this to work, a matched class must provide a sensible
override for <code class="highlighter-rouge">equals</code> and <code class="highlighter-rouge">hashCode</code> methods.</p>

<p>Before we’ll see an example, we need to learn about
a certain pitfall of Scala, illustrated by the following code:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NotEqualToAnything</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>

<span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="c1">// false
</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">y</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
// false
</span><span class="o">//</span> <span class="nc">Whaaaaa</span><span class="o">!</span> <span class="nc">What</span> <span class="n">has</span> <span class="n">just</span> <span class="n">happened</span><span class="o">?</span></code></pre></figure>

<p>Why was <code class="highlighter-rouge">x</code> matched with <code class="highlighter-rouge">case y</code> despite <code class="highlighter-rouge">x.equals(y)</code> returning <code class="highlighter-rouge">false</code>?
Because the <code class="highlighter-rouge">y</code> in <code class="highlighter-rouge">case y</code> is a new variable introduced by “catch-all” clause 
to keep the matched value. It’s the same construct that we used
earlier to catch unknown colors (<code class="highlighter-rouge">case unknownColor</code>).
To tell Scala compiler that we want to use the value kept in
a variable instead of introducing a new one,
we just need to quote variable name using <code>&#96;</code> character:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`y`</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"no-match"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Returning to the instances matching, here is a working example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">JustInt</span><span class="o">(</span><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// hashCode() omitted for brevity
</span>  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">other</span><span class="k">:</span> <span class="kt">JustInt</span> <span class="o">=&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="n">n</span>
      <span class="k">case</span> <span class="k">_</span>              <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">j2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j4</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="k">val</span> <span class="n">just3</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">just3</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`j2`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 2!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j3`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 3!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j4`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 4!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">just</span> <span class="mi">3</span><span class="o">!</span></code></pre></figure>

<p>One more example before we move on. When we attempt to
match singleton objects we do not need to use <code>&#96;</code> escaping:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">X</span> <span class="o">{</span> <span class="o">}</span>
<span class="k">object</span> <span class="nc">Y</span> <span class="o">{</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">X</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">Y</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's Y!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">X</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's X!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">it</span><span class="ss">'s </span><span class="n">X</span><span class="o">!</span></code></pre></figure>

<p><code class="highlighter-rouge">case X</code> will work just fine!</p>

<h4 id="pattern-matching-types">Pattern matching types</h4>

<p>Besides matching values, <code class="highlighter-rouge">match</code> can also perform <code class="highlighter-rouge">instanceof</code> tests:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">something</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">()</span>

<span class="n">something</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"a string!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"an int!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.Random</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"A Random instance!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"type unknown!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>As usual on JVM <code class="highlighter-rouge">instanceof</code> tests will not work with
parametrized types 
(while <code class="highlighter-rouge">class List&lt;T&gt;</code> is a generic type, 
<code class="highlighter-rouge">List&lt;T&gt;</code> usage like <code class="highlighter-rouge">List&lt;String&gt;</code> is
called a parametrized type). 
<a href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">Type erasure</a>
is here to blame:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// DO NOT WORK
</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"string list"</span> <span class="c1">// unreachable code warning
</span>  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"int list"</span> <span class="c1">// unreachable code warning
</span><span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">string</span> <span class="n">list</span> <span class="o">(</span><span class="n">sic</span><span class="o">!)</span></code></pre></figure>

<p>But not all is lost, we can still preform type tests
on generic types using wildcards (Scala <code class="highlighter-rouge">_</code> is a conterpart of Java <code class="highlighter-rouge">?</code>,
consider Scala’s <code class="highlighter-rouge">List[_]</code> and Java’s <code class="highlighter-rouge">List&lt;?&gt;</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a map"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a list"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a java's list"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">a</span> <span class="n">list</span></code></pre></figure>

<p>So far we where not interested in the actual value of the variable,
but only in it’s type and so we just discarded the value using <code class="highlighter-rouge">case _: Type</code>
clause.
But nothing prevents us from assigning the already type checked
value to a variable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">map</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="n">jlist</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">jlist</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span></code></pre></figure>

<p>Every <code class="highlighter-rouge">case</code> clause creates it’s own lexical scope.
This means that we can reuse variable names across different <code class="highlighter-rouge">case</code>es:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">10</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>

  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>
<span class="o">}</span></code></pre></figure>

<p>Pipe operator can be used with type checks too, but the
resulting code isn’t very readable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"a number!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>If we want to use the value matched by this
pattern we need to use a pattern binder:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">num</span><span class="o">@(</span><span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">].</span><span class="n">doubleValue</span><span class="o">())</span>
<span class="o">}</span></code></pre></figure>

<p>Pattern binders allow us to assign a value
that matches a <em>subpattern</em> to a variable.
In the extreme case this <em>subpattern</em> can be the entire
pattern, as it is in our case. We will return to
the pattern binders later.</p>

<h4 id="pattern-matching-tuples">Pattern matching tuples</h4>

<p>Pattern matching on tuples is supported out of the box.
We can match on tuple elements using all previously
described matchers. We can ignore a tuple element
by using “match all” wildcard (<code class="highlighter-rouge">_</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// unpacking tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// ignoring certain elements
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// matching values of the tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$e"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// matching types of the tuple
</span><span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="mf">1.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="kc">true</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$s $n $b"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p>We can also match nested tuple structures:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">))</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// and with other constraints:
</span><span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<h4 id="pattern-guards">Pattern guards</h4>

<p>When pattern matching values, we often need to preform
some additional checks e.g. say we want to match all odd
or even integers. We can use pattern guards for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Since pattern guards use predicates (expressions that
return either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>) they are very flexible.
We can express both value and type checks using only
pattern guards:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">"foo"</span> <span class="k">=&gt;</span>
    <span class="s">"it's this 'foo' again!"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">=&gt;</span>
    <span class="s">"it's three!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="s">"foo"</span>
<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"it's a string: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The problem with pattern guards is that they are
imperative. We should try to avoid them
as much as possible. Later we will learn about
extractors, that roughly speaking do the same
job as guards but in a more declarative way.</p>

<h4 id="extractors">Extractors</h4>

<p>Extractors are pattern guards on steroids.
They allow us to build highly readable DSLs and provide
a functional way to match, extract and transform program data.</p>

<p>The simplest extractor return just a <code class="highlighter-rouge">Boolean</code> value and
can be used as a pattern guard replacement:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Odd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Even</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Odd</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Even</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Generally speaking extractor is just a value with <code class="highlighter-rouge">unapply</code> method.
In the last example we used <code class="highlighter-rouge">object</code>s but extractor can also be kept in variables:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">multipleOf2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">multipleOf5</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m5</span> <span class="k">@</span> <span class="n">multipleOf5</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m5 is multiple of 5"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">m2</span> <span class="k">@</span> <span class="n">multipleOf2</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m2 is multiple of 2"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Here we also used pattern binders to name the values that where matched
by <code class="highlighter-rouge">multipleOf</code> extractors.</p>

<p>Unfortunately in the current version of Scala we cannot create parametrized
extractors. In other words we cannot create a universal <code class="highlighter-rouge">multipleOf(n)</code> extractor.
This also means that pattern guards are not 100% replaceable by extractors.</p>

<p>As the name suggest, the extractors main purpose is to extract the
data from matched values.
Our next extractor will extract non-null values from nullable reference:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NonNull</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">arg</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">string</span> <span class="k">&lt;-</span> <span class="n">strings</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">string</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">NonNull</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"placeholder"</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">foo</span> <span class="n">placeholder</span> <span class="n">bar</span> <span class="n">placeholder</span></code></pre></figure>

<p><code class="highlighter-rouge">unapply</code> method can be generic, and should return <code class="highlighter-rouge">Some(value)</code> in
case of match and <code class="highlighter-rouge">None</code> when there is not match.</p>

<p>But extractors are not limited to returning only a single value.
In our next example we will learn how to extract <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> from
<code class="highlighter-rouge">java.util.List[E]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>

<span class="k">object</span> <span class="nc">JList</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">E</span>, <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">None</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">head</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">subList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="o">())</span>
      <span class="nc">Some</span><span class="o">((</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collections</span><span class="o">.</span><span class="n">emptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">](),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>To return multiple values from the extractor we just need to return a
tuple instead of a single value wrapped in <code class="highlighter-rouge">Option[A]</code>.</p>

<p>Extractors can be nested, this is a really powerful feature.
Given our previous <code class="highlighter-rouge">JList</code> extractor we can extract not only
the first element but any finite number of elements from the beginning of a list:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)))</span> <span class="k">=&gt;</span>
	 <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>To understand how this pattern works it’s helpful to look at the equivalent
for comprehension:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">tmp1</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="n">tmp2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp2</span><span class="o">)</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>When we extract multiple values, sometimes we want to
ignore some of them.
We can use <code class="highlighter-rouge">_</code> wildcard, that matches any value, for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>We can also use pattern binders to assign names to
subpatterns, for example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>Matching Java’s <code class="highlighter-rouge">List[E]</code> using nested patterns is not
very comfortable. 
In reality we prefer a syntax like <code class="highlighter-rouge">case JList(e1, e2, e3)</code>.
Fortunately this can be done in Scala using extractors that return <code class="highlighter-rouge">Option[Seq[E]]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">JList2</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">scala.jdk.CollectionConverters._</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSeq</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 3 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 2 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"4 elements: $a, $b, $c, $d"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that we used <code class="highlighter-rouge">unapplySeq</code> instead of <code class="highlighter-rouge">unapply</code>.</p>

<p>With <code class="highlighter-rouge">Seq</code> extractor we can match “tail” of
the list using <code class="highlighter-rouge">_*</code> pattern:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head $head, tail $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The last thing that may come handy is the ability to write
extractor expression using either call notation <code class="highlighter-rouge">JList2(head, tail)</code>
or using operator notation <code class="highlighter-rouge">head JList2 tail</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">head</span> <span class="nc">JList</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is mostly useful when we want to provide “operator like” experience
for the programmers. For example when we want to match
<code class="highlighter-rouge">List</code>s using <code class="highlighter-rouge">e1 :: e2 :: tail</code> expression.</p>

<h4 id="scala-buildin-extractors">Scala buildin extractors</h4>

<p>Let’s finish this post with a tour of Scala buildin extractors.</p>

<h5 id="case-classes">Case classes</h5>

<p>When you declare a case class in Scala:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
                 <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span></code></pre></figure>

<p>compiler, among other things, adds appropriate
<code class="highlighter-rouge">apply</code> and <code class="highlighter-rouge">unapply</code> methods to the case class companion object.
Thanks to this, pattern matching works with case classes out of the box:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">line</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Line</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">fy</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="n">tx</span><span class="o">,</span> <span class="n">ty</span><span class="o">),</span> <span class="n">color</span><span class="nd">@_</span><span class="o">)</span> <span class="k">=&gt;</span> 
    <span class="n">s</span><span class="s">"line(($fx,$fy) -&gt; ($tx,$ty))"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> 
    <span class="s">"fail"</span>
<span class="o">}</span></code></pre></figure>

<h5 id="list">List</h5>

<p>Scala <code class="highlighter-rouge">List</code> implements a singly linked list.
<code class="highlighter-rouge">case object Nil</code> is used to represent an empty list.
As a singleton object, <code class="highlighter-rouge">Nil</code> is matched by <code class="highlighter-rouge">case Nil</code> clause.
<code class="highlighter-rouge">case class ::</code> is used as a linked list node, it contains
two fields <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">next</code>. Both <code class="highlighter-rouge">Nil</code> and <code class="highlighter-rouge">::</code>
extend abstract class <code class="highlighter-rouge">List[E]</code>.
Because name of the <code class="highlighter-rouge">case class ::</code> ends in a <code class="highlighter-rouge">:</code> (colon),
<code class="highlighter-rouge">::</code> when used as an operator is right associative:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="o">==</span> <span class="o">::(</span><span class="mi">1</span><span class="o">,</span> <span class="o">::(</span><span class="mi">2</span><span class="o">,</span> <span class="o">::(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span></code></pre></figure>

<p>After this overly simplistic explanation on how <code class="highlighter-rouge">List[E]</code> works, we
should now understand how pattern matching
works with lists:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"single element list $head"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">e1</span> <span class="o">::</span> <span class="n">e2</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list $e1 $e2"</span><span class="o">)</span>
      
    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// single element list 1
// two element list 1 2
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>For programmers convenience <code class="highlighter-rouge">unapplySeq</code> is also
provided on <code class="highlighter-rouge">List</code> singleton object. It works very similar to 
our <code class="highlighter-rouge">JList</code> extractor:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list: [$first, $second]"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// head: 1, tail: List()
// two element list: [1, 2]
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>It is a good exercise to create our own <code class="highlighter-rouge">List[E]</code> implementation
with all pattern matching facilities that standard <code class="highlighter-rouge">List[E]</code> provides.</p>

<h5 id="regexes">Regexes</h5>

<p>Scala <code class="highlighter-rouge">Regex</code> class provides <code class="highlighter-rouge">unapplySeq</code> extractor.
When a regex matches an input, the extractor will return
values for all matching groups within the regex.
You can create a group within a regex by using parentheses,
for example regex <code class="highlighter-rouge">(\d{3})-(\d{5})</code> has two groups
<code class="highlighter-rouge">\d{3}</code> and <code class="highlighter-rouge">\d{5}</code>. If you want to use parentheses
but do not wish to create a group, you just need to put
<code class="highlighter-rouge">?:</code> after starting <code class="highlighter-rouge">(</code> like in <code class="highlighter-rouge">(?:\d{3})?</code>.
If you want to learn more about regular expressions
you should check out <em>Mastering Regular Expressions</em> book by Jeffrey Friedl.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">phoneNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="s">"+48 123-123-123"</span><span class="o">,</span>
  <span class="s">"123-123-123"</span><span class="o">,</span>
  <span class="s">"123123123"</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">plPhoneNumber</span> <span class="k">=</span> <span class="s">"^(?:\\+(\\d{2})\\s)?(\\d{3}-\\d{3}-\\d{3})$"</span><span class="o">.</span><span class="n">r</span>
<span class="k">for</span> <span class="o">(</span><span class="n">phoneNo</span> <span class="k">&lt;-</span> <span class="n">phoneNumbers</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">phoneNo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">plPhoneNumber</span><span class="o">(</span><span class="n">countryPrefix</span><span class="o">,</span> <span class="n">phoneNo</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"countryPrefix: $countryPrefix, phoneNo: $phoneNo"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"no match"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// countryPrefix: 48, phoneNo: 123-123-123
// countryPrefix: null, phoneNo: 123-123-123
</span><span class="o">//</span> <span class="n">no</span> <span class="k">match</span></code></pre></figure>

<p>In practice regex extractors are rarely used with <code class="highlighter-rouge">match</code> expression.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Floating point numbers and Unit Testing</title>
	  <link>//doubles-and-unit-testing</link>
	  <author></author>
	  <pubDate>2019-09-18T02:00:01+02:00</pubDate>
	  <guid>//doubles-and-unit-testing</guid>
	  <description><![CDATA[
	     <p>Floating point numbers are inherently imprecise.
This can be problematic when we try to unit test
numerical algorithms.
Let’s see this on an example
(JVM/Scala, ScalaTest used as a testing framework):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span><span class="o">*</span><span class="n">d</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>This test works just fine… until someone decides to
do a “harmless refactoring” and replaces <code class="highlighter-rouge">d*d</code> by <code class="highlighter-rouge">Math.pow(d, 2)</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Now the test fails with the following message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">0.38052927966064654 was not equal to 0.3805292796606466</code></pre></figure>

<p>The expected and the actual values differ by ~5.6E-17.
Doubles offer precision of about 15 significant digits in a result.
All the other digits after 15th digit are just noise that should be
ignored.</p>

<p>To make our unit-test more robust we have two strategies.
The first strategy is to know the precision that is guaranteed by the algorithm
that we are using, and to round the result to that
precision before returning it to the client:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d2</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
    <span class="c1">// Precision from org.apache.commons:commons-math3:3.6.1
</span>    <span class="k">return</span> <span class="nc">Precision</span><span class="o">.</span><span class="n">round</span><span class="o">(</span><span class="n">d2</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
<span class="o">}</span>

<span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.38052928</span><span class="o">)</span> <span class="c1">// rounded
</span><span class="o">}</span></code></pre></figure>

<p>The second strategy is to use assertions intended to work
with floating point numbers. Again to use them correctly we need to
be aware of the precision of our algorithm:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span><span class="o">*</span><span class="n">d</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span> <span class="o">+-</span> <span class="mf">0.000000005</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>In this case it is good to define the precision
as a global constant (or as a constant per algorithm).</p>

<p>Personally I prefer the first strategy, but with
either of them our tests will be more robust and
refactoring-friendly.</p>

<h4 id="troubles-with-nan">Troubles with NaN</h4>

<p>Totally different set of problems are connected to <code class="highlighter-rouge">NaN</code> values.
On JVM operator <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">equals</code> behave 
inconsistently when comparing <code class="highlighter-rouge">NaN</code>s:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"Jvm's Double"</span> <span class="n">should</span> <span class="o">{</span>
    <span class="s">"follow JVM spec"</span> <span class="n">in</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>

        <span class="c1">// Required by IEEE 754 Standard
</span>        <span class="o">(</span><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span><span class="o">)</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>

        <span class="c1">// Required by JVM Object#equals contract:
</span>        <span class="c1">// "for any non-null reference value x,
</span>        <span class="c1">//  x.equals(x) should return true"
</span>        <span class="n">nan</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">nan</span><span class="o">)</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Unit testing frameworks often do not help here much.
For example the following test:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"how to check that a value is NaN?"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>
    <span class="n">nan</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="n">nan</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>will fail with a rather unhelpful message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">NaN was not equal to NaN</code></pre></figure>

<p>According to ScalaTest guidelines we should use <code class="highlighter-rouge">Double#isNaN</code>
to check if a value is <code class="highlighter-rouge">NaN</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"how to check that a value is NaN?"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>
    <span class="n">nan</span><span class="o">.</span><span class="n">isNaN</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>We experience similar troubles when we try to
compare case classes containing double fields with <code class="highlighter-rouge">NaN</code> values:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">CaseClass</span><span class="o">(</span><span class="n">d1</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
                     <span class="n">d2</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>

<span class="c1">// In test code:
</span><span class="k">val</span> <span class="n">inf</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span>
<span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>
<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">+</span><span class="mf">0.0</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.0</span><span class="o">))</span>
<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">inf</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">inf</span><span class="o">))</span>

<span class="c1">// fails: CaseData(1.0,NaN) was not equal to CaseData(1.0,NaN)
</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">nan</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">nan</span><span class="o">))</span></code></pre></figure>

<p>I do not have a good solution for this problem.
We can either create a custom assertion for a given case class ourselves,
define a custom equality using 
<a href="http://www.scalactic.org/user_guide/CustomEquality">Scalactic</a>
or we can use <code class="highlighter-rouge">Option[Double]</code> and
somehow map <code class="highlighter-rouge">NaN</code>s to <code class="highlighter-rouge">Option</code>s <code class="highlighter-rouge">None</code>.
None of the solutions is great.</p>

<p>The last thing to remember is that we cannot <code class="highlighter-rouge">match</code> <code class="highlighter-rouge">NaN</code> values:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="c1">// will fail
</span><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">=&gt;</span> <span class="n">doStuff</span><span class="o">()</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fail</span><span class="o">(</span><span class="s">"NaN not matched!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// how to do it properly
</span><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">value</span><span class="nd">@_</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isNaN</span> <span class="k">=&gt;</span> <span class="n">doStuff</span><span class="o">()</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fail</span><span class="o">(</span><span class="s">"NaN not matched!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>


	  ]]></description>
	</item>

	<item>
	  <title>Odroid GO Review</title>
	  <link>//odroid-go-review</link>
	  <author></author>
	  <pubDate>2019-04-14T02:00:01+02:00</pubDate>
	  <guid>//odroid-go-review</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>A Master Programmer passed a novice programmer one day.</p>

  <p>The Master noted the novice’s preoccupation with a hand-held computer game.</p>

  <p>“Excuse me,” he said, “may I examine it?”</p>

  <p>The novice bolted to attention and handed the device to the Master. “I see that the device claims to have three levels of play: Easy, Medium, and Hard,” said the Master. “Yet every such device has another level of play, where the device seeks not to conquer the human, nor to be conquered by the human.”</p>

  <p>“Pray, Great Master,” implored the novice, “how does one find this mysterious setting?”</p>

  <p>The Master dropped the device to the ground and crushed it with his heel. Suddenly the novice was enlightened.</p>

  <p>Excerpt from <a href="http://www.mit.edu/~xela/tao.html">Tao of Programming</a></p>
</blockquote>

<p>Be warned, the device that I am going to present is both
addictive and may cause your programming skills to deteriorate.
Use with moderation!</p>

<p>So 3, 2, 1… Ladies and Gentlemen, here it is Odroid GO:
<img src="assets/images/2019-04-14/go1.jpg" alt="Odroid GO" />
Game console for geeks and nerds. Out of the box (I mean after
you assemble it) it supports all popular ROM’s. In practice I found
that GameBoy Color roms work the best. NES roms often caused
the emulator to hang and GameBoy roms are eh… without colors.
All in all I managed to run on Odroid GO all popular games 
from my childhood, like
Super Mario Bross Delux and Croc without any troubles.</p>

<p>One minor problem that this console has and I find annoying
is how game state saving works.
Usually game builtin SAVE option will not work with the emulator,
instead Odroid GO provides its own way of saving games.
Basically when you finished playing a game you must press
MENU button and only then turn off the device, otherwise
your game progress will be lost. This was a little bit annoying
in the beginning but I quickly get used to it.</p>

<p>One great aspect of this console is its price. I bought mine
for about 200PLN which for this kind of device (multi-color screen,
Arduino like CPU, battery included)
should be considered a very good deal.</p>

<p>Odroid GO stores roms and game states on a microSD card that
is not included in the kit. 
You can buy one e.g. Kingston micro SDHC 16GB
for about 15PLN so this should not be a problem.
Also remember that you will need an
<em>SD card reader</em> to upload firmware and roms to the microSD card.
Maybe your laptop already has one? If not you will need to buy or
borrow one.</p>

<p>By now it should be clear that Odroid GO comes as <a href="https://wiki.odroid.com/odroid_go/go_assembling">a DIY kit</a>.
In other to assemble it correctly you will need to go through the
<a href="https://wiki.odroid.com/odroid_go/go_assembling">official guide</a>.
Also watch <a href="https://www.youtube.com/watch?v=6wwHmgX5U3w">this video</a>
before you start assembling.</p>

<p>During the assembly you will need a few tools:</p>

<ul>
  <li>A small screwdriver for “cross” screws.
 If you own a precision screwdriver set you should be fine.</li>
  <li>An utility knife (box cutter) to remove buttons from the frame.</li>
  <li>[OPTIONAL] A latex gloves to avoid leaving greasy marks
 on the screen while putting it into the frame.</li>
</ul>

<p>The assembly takes about half an hour to complete.
Once you are done
you will have to format your SD card and copy firmware and roms
there.
All these steps are described with much detail in the
official guide.</p>

<p>For me the most difficult step was connecting the screen to the
main board. The socket is very delicate and you must be
extra careful not to damage it.
<img src="assets/images/2019-04-14/go2.jpg" alt="Screen mainboard connection" />
Also remember that after you close a lock on the socket it will
be very hard to open the lock again.
You should strive to connect the screen during the first try.
This may sound difficult but believe me it is not.
I am sure you will be fine!</p>

<p>After using Odroid GO for some time, I must admit that it
is quite comfortable to use. Is is not too heavy and
quite pleasant to handle. The battery suffice for at least
eight hours of playing Super Mario Bros.</p>

<p>Final verdict: If you are a fan of old school games
definitely buy this device. You will not be disappointed!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Kensington Orbit Trackball review</title>
	  <link>//kensington-orbit-trackball-review</link>
	  <author></author>
	  <pubDate>2019-04-14T02:00:00+02:00</pubDate>
	  <guid>//kensington-orbit-trackball-review</guid>
	  <description><![CDATA[
	     <p>Since about three months I use 
<a href="https://www.kensington.com/p/products/control/trackballs/orbit-trackball-with-scroll-ring/">Kensington Orbit Trackball</a>
as my only pointing device.
This is my very first trackball, I bought it for about 180PLN.</p>

<p><img src="assets/images/2019-04-14/t1.jpg" alt="Kensington Orbit Trackball" /></p>

<p>Kensington Orbit Trackball is a “stationary device”,
good for a PC or for a laptop with docking station, but not
very mobile.
The device by itself takes more space than a mouse, but since
it does not require any movements, you end up with a huge desk space savings.
In my case I ended up needing only about one third of
the space that I needed for my mouse.</p>

<p>It took me about two weeks to get used to it.
In the beginning all my movements were clumsy and
my fingers got tired really quickly just from clicking right and
left buttons.
Yet the biggest challenge for me was the middle-click.
On Kensington it is performed by pressing simultaneously left
and right buttons. After a few presses like this my fingers literally
hurt.
Fortunately for me the pain and discomfort lasted
only few days. After that my hands developed necessary muscles
and using my trackball become bearable.
Still I needed about two weeks more to get to the point when
using my trackball was actually comfortable.
When it comes to movement precision I still have troubles
with selecting text fragments and 
drawing is definitively out of the question right now.</p>

<p>I use Kensington trackball only
at home, at work I still use a mouse.
This may explain the long time it took me to get used to it.
On the other hand it may be too painful and uncomfortable
to start using trackball for 8+ hours a day.
So maybe starting small is not a bad strategy…</p>

<p>Instead of a scroll wheel Kensington offers a huge
scroll ring located around the ball, which
is very pleasant to use.
In case of my Kensington the ring did not rotate
smoothly during first few days of using it, but after that
I had no problems with it.</p>

<p>Kensington provides drivers for Windows and macOS,
but not for Linux (shame on you Kensington).
One of the downsides of this
is that the middle click that caused me so much discomfort
does not work out of the box with Linux.
Fortunately this is 
<a href="https://oliversmith.io/technology/2016/01/03/Enabling-middle-click-for-kensington-trackball-on-ubuntu-linux/">easy to fix</a>,
just add to your <code class="highlighter-rouge">~/.profile</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">xinput <span class="se">\</span>
  <span class="nt">--set-prop</span> <span class="se">\</span>
  <span class="nt">--type</span><span class="o">=</span>int <span class="se">\</span>
  <span class="nt">--format</span><span class="o">=</span>8 <span class="se">\</span>
  <span class="s2">"Primax Kensington Eagle Trackball"</span> <span class="se">\</span>
  <span class="s2">"Evdev Middle Button Emulation"</span> <span class="se">\</span>
  1</code></pre></figure>

<p>The downside of this solution is that you must reexecute this command
every time you unplug and plug your trackball again.</p>

<p>The other thing that surprised me is that this device
requires regular cleaning. In my case about once a week.
The cleaning is not too difficult, you just need to push the ball out 
using a pencil or your pinky finger and remove dust and dirt.
You can find a lot of tutorials how to do this properly on the internet.</p>

<p><img src="assets/images/2019-04-14/t2.jpg" alt="Cleaning" /></p>

<p>If you will ever want to open this trackball e.g. to do some
more serious cleaning, please remember that there is 
a hidden screw:
<img src="assets/images/2019-04-14/t3.jpg" alt="Cleaning" />
I removed a piece of rubber that hid the screw using
box cutter knife.
It is really a shame that nowadays manufacturers use
tricks like that to stop users from
repairing their products.</p>

<p>The last thing that I want to mention is price.
In my opinion this product is a bit overpriced.
This is really sad considering how few people are using trackballs.
I think that these devices would be much more popular if they
where cheaper.</p>

<p>Time to sum up.
All in all Kensington Orbit Trackball turned out to be a good
purchase. It took me some time to get use to it, but now I like it very much
and I do not plan to return to a mouse anytime soon.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Reduce cognitive load for readers of your code</title>
	  <link>//reduce-cognitive-load</link>
	  <author></author>
	  <pubDate>2019-03-05T01:00:00+01:00</pubDate>
	  <guid>//reduce-cognitive-load</guid>
	  <description><![CDATA[
	     <p>Recently I was reviewing a piece of code that was performing
some computation on file sizes. The author of that code
followed good programming practices and created a separate
type for representing file sizes:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">struct</span> <span class="nc">FileSize</span> <span class="p">{</span>
   <span class="k">public</span> <span class="k">static</span> <span class="n">FileSize</span> <span class="nf">FromBytes</span><span class="p">(</span><span class="kt">ulong</span> <span class="n">bytes</span><span class="p">)</span>
       <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">FileSize</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
   <span class="c1">// Other factory methods...</span>
   
   <span class="k">private</span> <span class="kt">ulong</span> <span class="n">_bytes</span><span class="p">;</span>
   <span class="k">public</span> <span class="kt">ulong</span> <span class="n">TotalBytes</span>
       <span class="p">=&gt;</span> <span class="n">_bytes</span><span class="p">;</span>
   
   <span class="k">public</span> <span class="nf">FileSize</span><span class="p">(</span><span class="kt">ulong</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">_bytes</span> <span class="p">=</span> <span class="n">bytes</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="c1">// Other stuff, equatable, comparable, blah...</span>
   
   <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
       <span class="p">=&gt;</span> <span class="s">$"</span><span class="p">{</span><span class="n">_bytes</span><span class="p">:</span><span class="err">##</span><span class="p">,</span><span class="err">#</span><span class="n">B</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
   
   <span class="k">public</span> <span class="k">static</span> <span class="n">FileSize</span> <span class="k">operator</span><span class="p">+(</span><span class="n">FileSize</span> <span class="n">left</span><span class="p">,</span> <span class="n">FileSize</span> <span class="n">right</span><span class="p">)</span>
       <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">FileSize</span><span class="p">(</span><span class="k">checked</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">_bytes</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">_bytes</span><span class="p">));</span>
   <span class="c1">// Other operators...</span>
<span class="p">}</span></code></pre></figure>

<p>Yet when it came to computing a total size of set of files I saw
code like this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">totalSize</span> <span class="p">=</span> <span class="n">fileSizes</span><span class="p">.</span><span class="nf">Aggregate</span><span class="p">((</span><span class="n">acc</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">curr</span><span class="p">);</span></code></pre></figure>

<p>What is wrong with this code?
It forces readers to concentrate on irrelevant details like how
to sum a list of <code class="highlighter-rouge">FileSize</code>s. As a programmer, reading a lot
of code I would prefer to see something like:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">totalSize</span> <span class="p">=</span> <span class="n">fileSizes</span><span class="p">.</span><span class="nf">Sum</span><span class="p">();</span></code></pre></figure>

<p>Which is shorter, easier to read and allows me to concentrate
on the actual business problem that I try to solve.</p>

<p>As an another example, imagine what would happen if people
started writing:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">listOfNumbers</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">Aggregate</span><span class="p">(</span><span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(),</span> <span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
		<span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">list</span><span class="p">;</span>
	<span class="p">});</span></code></pre></figure>

<p>instead of:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">listOfNumbers</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">ToList</span><span class="p">();</span></code></pre></figure>

<p>I hope that you agree with me that it would not be nice…</p>

<p>The general rule that is violated by both these examples
is called <em>Single level of abstraction principle</em>, you can read
more about it 
<a href="http://principles-wiki.net/principles:single_level_of_abstraction">here</a>.
In short it states that, all statements of a method should belong
to the same level of abstraction.
In other words we should not mix low and high level operations
in a single method. In our example <code class="highlighter-rouge">Aggregate</code> and details how
to use it are low level, computing a total size of set of files is
on the other hand a high level one.</p>

<p>Fortunately for us, we may quickly add appropriate <code class="highlighter-rouge">Sum</code> method
to our program:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">EnumerableOfFileSize</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">FileSize</span> <span class="nf">Sum</span><span class="p">(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">FileSize</span><span class="p">&gt;</span> <span class="n">sizes</span><span class="p">)</span>
      <span class="p">=&gt;</span> <span class="n">sizes</span><span class="p">.</span><span class="nf">Aggregate</span><span class="p">(</span><span class="n">FileSize</span><span class="p">.</span><span class="nf">FromBytes</span><span class="p">(</span><span class="m">0</span><span class="p">),</span> 
                         <span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">total</span> <span class="p">+</span> <span class="n">curr</span><span class="p">);</span>

    <span class="cm">/* Or in more imperative style:
    public static FileSize Sum(this IEnumerable&lt;FileSize&gt; sizes) {
        ulong total = 0;

        foreach (var size in sizes) {
            total = checked(total + size.TotalBytes);
        }

        return new FileSize(total);
    }
    */</span>
<span class="p">}</span></code></pre></figure>

<p>After this change we achieved code that is easy to read and
also hides irrelevant details. Yay!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Why using PESEL as a password is a very bad idea</title>
	  <link>//why-using-pesel-as-a-password-is-a-very-bad-idea</link>
	  <author></author>
	  <pubDate>2019-02-25T01:00:00+01:00</pubDate>
	  <guid>//why-using-pesel-as-a-password-is-a-very-bad-idea</guid>
	  <description><![CDATA[
	     <p>I am sure, none of you, my dear readers would use a PESEL number
as a password or an encryption key.
Still, as unbelievable as it may sounds, recently 
I was talking with my friend on a topic of computer security and
he told me a horror story about a certain company doing exactly that.
Such practice is highly insecure and in this post I going to
prove that. Namely we will create an encrypted 7zip archive with
a random PESEL as a password and then we will crack it using
<a href="https://github.com/magnumripper/JohnTheRipper">John the Ripper</a>.</p>

<p>DISCLAIMER: All information is provided for educational purposes only.
Accessing data that does not belong to you is in most
cases illegal. Always check your local laws and your company policy
before using tools presented in this blog post.</p>

<h3 id="wtf-is-pesel">WTF is PESEL?</h3>

<p>First, let me explain for non-Polish readers what is
a <a href="https://en.wikipedia.org/wiki/PESEL">PESEL number</a>.
Basically it is an identification number similar to 
US Social Security number (SSN).
Every Polish citizen is assigned one unique PESEL number at birth.</p>

<p>But more important to us here is, that 
PESEL numbers have a very well defined structure:
<img src="assets/images/2019-02-25/pesel.svg" alt="PESEL number structure" />
First six digits of a PESEL number represent a date of birth
in <code class="highlighter-rouge">YYMMDD</code> format. Of course such a simple format does not allow us
to represent birth dates after year 1999. 
So there is a small twist, by adding twenty to the month number
we signify that the year is <code class="highlighter-rouge">20YY</code> not <code class="highlighter-rouge">19YY</code>.
For example if a person was born on 25th March 2029 we encode it
in PESEL as <code class="highlighter-rouge">292325XXXXX</code>.</p>

<p>The other interesting property of a PESEL number is that one before last
digit is used to encode person gender. Males are assigned
only odd digits, females only even digits.</p>

<p>The last digit of a PESEL is a checksum that can be easily computed
using other digits.</p>

<h3 id="so-how-many-pesels-are-there">So how many PESELs are there?</h3>

<p>Let’s assume that we intercepted a message encrypted by a PESEL
number. We know that the recipient of the message is male,
with age between twenty and sixty five.
How much PESELs we must brute force in the worst case scenario?</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">(65 - 20 + 1) * 356 * 10^3 * 5 = 83_950_000</code></pre></figure>

<p>How many six character 
passwords are there consisting of small letters and numbers?</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">(10 + 26)^6 = 2_176_782_336</code></pre></figure>

<p>Do you consider a six character password safe? Of course not!
Yet the number of possible six character passwords dwarfs
the number of possible PESELs.</p>

<p>What is worse, is that it is usually not too difficult to find out person
<em>year</em> of birth, thus reducing number of possible PESELs even more.</p>

<h3 id="demo-time">Demo time</h3>

<p>To demonstrate how weak protection PESEL passwords provide,
we will first create an encrypted <code class="highlighter-rouge">7z</code> archive and then
we will try to crack it using John the Ripper.</p>

<p>All provided instructions are for Ubuntu, but there should
be no problems with running modified versions of
these commands on macOS or Windows.</p>

<p>First we need to install <a href="https://www.7-zip.org/download.html">7-zip</a>:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">sudo </span>apt-get install p7zip-full p7zip-rar</code></pre></figure>

<p>Then we can create an encrypted archive:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">7z a <span class="nt">-m0</span><span class="o">=</span>lzma2 <span class="nt">-mx</span><span class="o">=</span>9 <span class="nt">-p29032502498</span> secret.7z secret.txt </code></pre></figure>

<p>with <code class="highlighter-rouge">29032502498</code> PESEL as a password.</p>

<p>Just to make sure that the archive is indeed encrypted,
we execute:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>7z l <span class="nt">-slt</span> secret.7z

<span class="o">(</span>... skipped ...<span class="o">)</span>
Encrypted <span class="o">=</span> +
Method <span class="o">=</span> LZMA2:16 7zAES:19
Block <span class="o">=</span> 0</code></pre></figure>

<p><code class="highlighter-rouge">7zAES:19</code> visible in the command output means that the archive 
is encrypted with AES-256 algorithm.</p>

<h3 id="meet-john">Meet John</h3>

<p>To install John the Ripper we must follow instructions
<a href="https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/INSTALL-UBUNTU">from the official repository</a>.
I compiled John without OpenCL and REXGEN support, YMMV though.</p>

<p>To allow John to crack <code class="highlighter-rouge">7z</code> file, first we must extract a hash from
it:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">./john/run/7z2john.pl secret.7z <span class="o">&gt;</span> secret.7z.hash</code></pre></figure>

<p>To make this Perl script work, I had to install this library:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">sudo </span>apt-get install libcompress-raw-lzma-perl</code></pre></figure>

<p>Then I generated a suitable list of PESEL numbers
(people aged 20-65, males) using
<a href="https://github.com/marcin-chwedczuk/blog-pesel-password-bad-idea/blob/master/peselgen/Program.cs">this short program</a>
that I wrote.
The generated file <code class="highlighter-rouge">pesels.txt</code> is about 1GB big and
consist of 82 185 000 PESEL numbers.
We are going to use it as a John the Ripper wordlist.</p>

<p>Now we can start cracking:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">./john/run/john <span class="nt">--wordlist</span><span class="o">=</span>pesels.txt secret.7z.hash

<span class="c"># Found passwords are saved in john.pot file</span>
<span class="nb">cat</span> ./john/run/john.pot</code></pre></figure>

<p>I performed two test. First I tried to crack a small
340B archive that you can find <a href="https://github.com/marcin-chwedczuk/blog-pesel-password-bad-idea/blob/master/secret.7z">here</a>.
On it I achieved speed of about 100 checked PESELs per second,
this means that cracking it, could take in the worst case scenario:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">82 185 000 / 100 / 3600 / 24 ~ 10 days</code></pre></figure>

<p>And all this on my four years old i7-4771 CPU, using John without GPU support.
Imagine how fast it would work on a high end Amazon EC2 instance…</p>

<p>Then I performed a second test, trying to crack 3MB archive
containing a PDF file. There I achieved speed of about 50 PESELs per second.
Not bad either (20 days in the worst case scenario).</p>

<p>But you don’t have to believe me here. Grab the
<a href="https://github.com/marcin-chwedczuk/blog-pesel-password-bad-idea/blob/master/secret.7z">test archive</a> and try to crack it yourself!
I encrypted it with a random PESEL generated using <a href="https://bogus-z-polska.pl/generatory/all.html">Bogus</a> site. Good luck!</p>

<p>As we can see archives protected by PESEL numbers can be easily cracked.</p>

<h3 id="conclusion">Conclusion</h3>

<ul>
  <li>Do NOT use PESEL numbers neither as passwords nor as encryption keys.</li>
  <li>Do USE <a href="https://www.gnupg.org/">GPG</a> if you want to send other person
 some secret data using email.</li>
</ul>

<h3 id="references">References</h3>

<ul>
  <li><a href="https://askubuntu.com/a/928301">https://askubuntu.com/a/928301</a></li>
  <li><a href="https://sourceforge.net/p/p7zip/patches/25/#3da5">https://sourceforge.net/p/p7zip/patches/25/#3da5</a></li>
  <li><a href="https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/INSTALL-UBUNTU">https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/INSTALL-UBUNTU</a></li>
  <li><a href="https://www.openwall.com/john/doc/">https://www.openwall.com/john/doc/</a></li>
  <li><a href="https://github.com/koboi137/john/blob/master/7z2john.pl#L32">https://github.com/koboi137/john/blob/master/7z2john.pl#L32</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>FluentAssertions and code formatting</title>
	  <link>//fluent-assertions-and-code-formatting</link>
	  <author></author>
	  <pubDate>2019-02-10T01:00:00+01:00</pubDate>
	  <guid>//fluent-assertions-and-code-formatting</guid>
	  <description><![CDATA[
	     <p>Recently I was playing with
<a href="https://fluentassertions.com/">FluentAssertions</a>
library.
I was really amazed by the beautiful error messages generated by FluentAssertions.
For example, for this failing test:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_its_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange</span>
    <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>
    
    <span class="c1">// Assert</span>
    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">).</span><span class="nf">Should</span><span class="p">().</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>FluentAssertions generates a message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected service.Add(1, 2) to be 3, but found 42.</code></pre></figure>

<p>Unfortunatelly my joy did not last long.
When I added an explanation to an assertion and
broke the line because it got too long:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_its_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange</span>
    <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>

    <span class="c1">// Assert</span>
    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">Should</span><span class="p">().</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="n">because</span><span class="p">:</span> <span class="s">"three is sum of one and two"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>FluentAssertions reproted just:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected value to be 3 because three is sum of one and two,
    but found 42.</code></pre></figure>

<p>It turns out, in order to have these fancy error messages,
we must place <code class="highlighter-rouge">.Should()</code> on the same line as the
tested expression:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">add_returns_sum_of_arguments</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrange</span>
    <span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="p">();</span>

    <span class="c1">// Assert</span>
    <span class="n">service</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span><span class="cm">/*abra cadabra*/</span><span class="p">.</span><span class="nf">Should</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">Be</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="n">because</span><span class="p">:</span> <span class="s">"three is sum of one and two"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The above test generates a message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Outcome: Failed
Error Message:
Expected service.Add(1, 2)/*abra cadabra*/ to be 3 because three
   is sum of one and two, but found 42.</code></pre></figure>

<p>Notice that comment was also include in the message.</p>

<p>This behavior of FluentAssertions really suprised me.
Why the way we format our code have influence over
the readability of error messages?</p>

<p>Anyway this is how FluentAssertions works,
moreover this behaviour is described 
(with short explanation how it works) on the <em>first</em> page
of <a href="https://fluentassertions.com/documentation/#subject-identification">the official documentation</a>.
If only I have spend ten minutes reading the friendly docs instead of
skimming it…</p>

<p>From now on I will follow “Read The Friendly Manual” (RTFM) advice!!!</p>


	  ]]></description>
	</item>


</channel>
</rss>

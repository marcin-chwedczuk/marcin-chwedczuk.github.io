<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Scala WTF 1</title>
	  <link>//scala-wtf-1</link>
	  <author></author>
	  <pubDate>2020-07-06T02:00:01+02:00</pubDate>
	  <guid>//scala-wtf-1</guid>
	  <description><![CDATA[
	     <p>So here is a puzzle. What will be written by
this program:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Wtf1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">points</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
    <span class="o">)</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">points</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"result: $result"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// ANSWER BELOW
// ..............................................
</span><span class="o">//</span></code></pre></figure>

<p>The answer is <code class="highlighter-rouge">false</code>.
Why? Because the line with <code class="highlighter-rouge">points.contains(Point(3, _))</code>
instead of performing pattern matching, checks whether <code class="highlighter-rouge">points</code> 
contain a function:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">points</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
<span class="c1">// in reality is:
</span><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">names</span><span class="o">.</span><span class="n">contains</span><span class="o">((</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span></code></pre></figure>

<p>The strangest thing for me is that the compilation of 
this code does not generate any warnings.
From Scala compiler point of view the above code is
perfectly valid and this in turn is the result of
<code class="highlighter-rouge">List</code> type being covariant.
Or in the other words because we can assign <code class="highlighter-rouge">List[Point]</code> to
<code class="highlighter-rouge">List[Any]</code>, <code class="highlighter-rouge">contains</code> must accept
arguments of any type:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">points</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">anys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">points</span>

<span class="n">anys</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">())</span></code></pre></figure>

<p>The declaration of <code class="highlighter-rouge">contains</code> method in <code class="highlighter-rouge">List[A]</code> looks like this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">contains</span><span class="o">[</span><span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">elem</span><span class="k">:</span> <span class="kt">A1</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span></code></pre></figure>

<p>We may snoop the actual types assigned to the generic parameters
using a helper method:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">detectType</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">A1</span><span class="o">)</span>
                          <span class="o">(</span><span class="k">implicit</span> <span class="n">tagA</span><span class="k">:</span> <span class="kt">ClassTag</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tagA1</span><span class="k">:</span> <span class="kt">ClassTag</span><span class="o">[</span><span class="kt">A1</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"type of A : ${tagA.runtimeClass.getName}"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"type of A1: ${tagA1.runtimeClass.getName}"</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">detectType</span><span class="o">(</span><span class="n">names</span><span class="o">,</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>

<span class="c1">// This prints:
// type of A : Point
// type of A1: java.lang.Object
</span><span class="o">//</span></code></pre></figure>

<p>So during the compilation <code class="highlighter-rouge">A1</code> becomes <code class="highlighter-rouge">Object</code> and everything
type-checks.</p>

<p>Let’s finish by writing a code that actually does what
the programmer intended:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">names</span>
    <span class="o">.</span><span class="n">collectFirst</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span></code></pre></figure>


	  ]]></description>
	</item>

	<item>
	  <title>Matching regexes using backtracking</title>
	  <link>//matching-regexes-using-backtracking</link>
	  <author></author>
	  <pubDate>2020-06-28T02:00:01+02:00</pubDate>
	  <guid>//matching-regexes-using-backtracking</guid>
	  <description><![CDATA[
	     <p>In this post we will write a simple regex library.
The table below presents regex operators that we are going to support:</p>

<table>
    <colgroup>
        <col width="25%" />
        <col width="75%" />
    </colgroup>
    <thead>
        <tr class="header">
            <th>Operator</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>A single character e.g. <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">\n</code>, <code class="highlighter-rouge">\(</code></td>
            <td>
                A single character matches itself.<br />
                Special characters need to be escaped e.g. <code class="highlighter-rouge">\n</code>.
            </td>
        </tr>
        <tr>
            <td>Character groups e.g. <code class="highlighter-rouge">[a-z]</code>, <code class="highlighter-rouge">[^xyz]</code></td>
            <td>Character group matches any character
                that is part of the group.<br /><br />
                Negated character group (<code class="highlighter-rouge">[^xyz]</code>)
                matches any character that is <em>not</em> part of the group.<br /><br />
                Character ranges like <code class="highlighter-rouge">a-z</code> can be used inside groups.
                A character c belongs to <code class="highlighter-rouge">a-z</code> range when its
                numerical value falls between <code class="highlighter-rouge">(int)'a' &lt;= (int)c &lt;= (int)'z'</code>.
            </td>
        </tr>
        <tr>
            <td><code class="highlighter-rouge">.</code> wildcard</td>
            <td>
                <code class="highlighter-rouge">.</code> wildcard will match any single character. 
                <br /><br />
                For example
                <code class="highlighter-rouge">...</code> will match any string consisting of three characters.
            </td>
        </tr>
        <tr>
            <td>Concatenation e.g. <code class="highlighter-rouge">abc</code>,<br /><code class="highlighter-rouge">[0-9]-[0-9]</code></td>
            <td>Just as we can concatenate strings, 
                we may also concatenate regexes. 
                The resulting expression will match an input, only when the input can be split into two parts, so that
                the first part of the input matches the first concatenated regex and
                the second part of the input matches the second concatenated regex.
                <br /><br />
                For example input <code class="highlighter-rouge">9X</code> matches the regex <code class="highlighter-rouge">[0-9][XYZ]</code> because <code class="highlighter-rouge">9</code> matches <code class="highlighter-rouge">[0-9]</code> and <code class="highlighter-rouge">X</code> matches <code class="highlighter-rouge">[XYZ]</code>.
            </td>
        </tr>
        <tr>
            <td>Alternative e.g. <code class="highlighter-rouge">Z|X|[0-9]</code></td>
            <td>Input matches the alternative when it matches
                any branch of the alternative. <br /><br />
                For example inputs <code class="highlighter-rouge">Z</code>, <code class="highlighter-rouge">X</code>
                and <code class="highlighter-rouge">3</code> will all match <code class="highlighter-rouge">Z|X|[0-9]</code> alternative because they match
                respectively <code class="highlighter-rouge">Z</code>, <code class="highlighter-rouge">X</code> and <code class="highlighter-rouge">[0-9]</code> branches. 
                <br /><br />
                Alternative has lower priority than concatenation so
                <code class="highlighter-rouge">foo|bar</code> means <code class="highlighter-rouge">(foo)|(bar)</code>, not <code class="highlighter-rouge">fo(o|b)ar</code>.
            </td>
        </tr>
        <tr>
            <td>Repetition (quantification) 
                e.g. <code class="highlighter-rouge">a*</code>, <code class="highlighter-rouge">[0-9]?</code>, <code class="highlighter-rouge">X{1,5}</code></td>
            <td>
                Preceding regex must match input specified number of times.<br />
                Supported operators are: <br /><br />
                <ul>
                    <li><code>*</code> - matches zero or more times</li>
                    <li><code>+</code> - matches one or more times</li>
                    <li><code>?</code> - matches zero or one time</li>
                    <li><code>{n}</code> - matches exactly n times</li>
                    <li><code>{n,m}</code> - matches between n and m
                     times (inclusive) 
                    </li>
                </ul>
                <div>
                    For example <code class="highlighter-rouge">[0-9]*</code> will match any string consisting of digits, including empty string.<br />
                    On the other hand <code class="highlighter-rouge">[0-9]{2,3}</code> will match strings consisting of two or three decimal digits.<br /><br />
                    In our limited implementation we do not support spaces
                    (or any other whitespace characters) inside <code class="highlighter-rouge">{n,m}</code> expressions.<br /><br />
                    Repetition has higher priority than concatenation and 
                    alternative so <code class="highlighter-rouge">foo{5}</code> means <code class="highlighter-rouge">fo(o{5})</code>, not <code class="highlighter-rouge">(foo){5}</code>.<br /><br />
                    Repetition operators are greedy, this means they will try
                    to match as much input as possible.<br />
                    For example <code class="highlighter-rouge">(a*)(a*)</code> will match the <code class="highlighter-rouge">aaaaa</code> input in
                    the following way <code class="highlighter-rouge">(aaaaa)()</code> - the first <code class="highlighter-rouge">a*</code> will match
                    all the characters, leaving empty string for the second <code class="highlighter-rouge">a*</code> to match.
                </div>
            </td>
        </tr>
        <tr>
            <td><code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> anchors</td>
            <td>
                <code class="highlighter-rouge">^</code> matches the beginning of the input.<br />
                <code class="highlighter-rouge">$</code> matches the end of the input.<br /><br />
                For example <code class="highlighter-rouge">^foo</code> will match strings that start with
                <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar$</code> will match strings that end with <code class="highlighter-rouge">bar</code>.
            </td>
        </tr>
        <tr>
            <td>Grouping (parentheses)</td>
            <td>
                Parentheses are used to alter the precedence of the operators.<br /><br />
                For example compare <code class="highlighter-rouge">foo|bar</code> with <code class="highlighter-rouge">fo(o|b)ar</code>,
                the first one will match <code class="highlighter-rouge">foo</code>, the second one <code class="highlighter-rouge">fooar</code>.
            </td>
        </tr>
    </tbody>
</table>

<p>The library itself is quite small, it consists of two parts:
a parser and a matcher. 
The parser is a very simple <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>
and as most of manually written parsers
it probably contains some undiscovered bugs.
The parser itself is not the main focus of this article,
so we will tread it as a black box that consumes regular 
expressions in text form and produces equivalent ASTs or Abstract Syntax Trees.</p>

<p>ASTs are tree like data structures, 
that make order of operator evaluation and the internal structure of a regular
expression explicit.
Let’s see this on an example. The AST representation of 
 <code class="highlighter-rouge">^a(foo|bar|egg)*b$</code> regex is:
<img src="assets/images/2020-06-28/ast1.svg" alt="AST tree" /></p>

<p>The anchors <code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> are represented by their own
AST nodes <code class="highlighter-rouge">AT_BEGINNING</code> and <code class="highlighter-rouge">AT_END</code>.
To represent both character groups and single characters, we use
<code class="highlighter-rouge">GROUP</code> nodes. <code class="highlighter-rouge">GROUP</code> nodes are very simple, they contain a list
of characters that they match. A <code class="highlighter-rouge">GROUP</code> node for <code class="highlighter-rouge">[0-9]</code> regex
contains characters <code class="highlighter-rouge">0123456789</code> in the list.
For negated groups like <code class="highlighter-rouge">[^0-9]</code> we use <code class="highlighter-rouge">NEGATED_GROUP</code> node,
the representation is the same as for <code class="highlighter-rouge">GROUP</code> (we keep <code class="highlighter-rouge">0123456789</code> characters
in the list).
Next is the tricky one, we use <code class="highlighter-rouge">NEGATED_GROUP</code> without any characters
to represent wildcard (<code class="highlighter-rouge">.</code>). This makes sense because an empty group <code class="highlighter-rouge">[]</code> 
does not match anything, so its negation will match all characters.</p>

<p>To represent quantification operators like <code class="highlighter-rouge">?</code>, <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code> and <code class="highlighter-rouge">{n,m}</code>
we use <code class="highlighter-rouge">REPEAT</code> nodes. <code class="highlighter-rouge">REPEAT</code> nodes contain two additional attributes:
minimum and maximum number of allowed repetitions.
We use <code class="highlighter-rouge">Long.MAX_VALUE</code> to signify that maximum number of repetitions is unbound.
Finally we use <code class="highlighter-rouge">CONCAT</code> node to represent concatenation of two or more
regular expressions.</p>

<p>In the code all AST nodes are represented by a single class
called <code class="highlighter-rouge">RAst</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RAst</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">RAstType</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">chars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">exprs</span><span class="o">;</span>

    <span class="c1">// Repeat from to, both inclusive</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">repeatMin</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">repeatMax</span><span class="o">;</span>

    <span class="c1">// ...</span></code></pre></figure>

<p><code class="highlighter-rouge">type</code> field describes what kind of AST node this instance
represents e.g. <code class="highlighter-rouge">CONCAT</code>.
<code class="highlighter-rouge">GROUP</code> and <code class="highlighter-rouge">NEGATED_GROUP</code> nodes keep the set of matched/not-matched
characters in <code class="highlighter-rouge">chars</code> field.
<code class="highlighter-rouge">CONCAT</code> and <code class="highlighter-rouge">ALTERNATIVE</code> nodes keep their children in <code class="highlighter-rouge">exprs</code> field 
(the order of children is important, hence a <code class="highlighter-rouge">List</code>).
<code class="highlighter-rouge">REPEAT</code> node keeps its only child as a single element list in <code class="highlighter-rouge">exprs</code> field.</p>

<p>The matcher is represented in the code by <code class="highlighter-rouge">BacktrackingMatcher</code> class.
The interface of the matcher is very simple:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BacktrackingMatcher</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Match</span> <span class="nf">match</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">regex</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Match</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">hasMatch</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">input</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">matched</span><span class="o">()</span>  <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">hasMatch</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Our matcher will only find the first substring of the input that
matches the regex. Yet it would not be too difficult to extend 
the algorithm to find all matches (start matching again 
after the end of the previous match).</p>

<p>To implement our matcher we will use an algorithm design technique 
called backtracking. The general idea of backtracking is
very simple: we enumerate all the possible solution candidates
in a smart way and then we return the first candidate that is a valid solution.
The part “in a smart way” is very important, usually
enumerating all solution candidates will result in a very
slow algorithm (think <code class="highlighter-rouge">O(2^n)</code> or even <code class="highlighter-rouge">O(n!)</code>).
The key here is to quickly and early reject some subsets of
the solutions candidates.</p>

<p>Let’s see this on a very simple example,
say we want to solve a puzzle that is about placing various shapes in 3x3 grid. Some places in the grid are already taken. There is also a rule that describes a valid solution: in every row and column we cannot have two shapes of the same kind.
<img src="assets/images/2020-06-28/puzzle.svg" alt="Puzzle board" />
Simple enumeration of all possible assignments of the shapes to the free places
will generate <code class="highlighter-rouge">3^5</code> solution candidates, most of them wrong.
A smarter candidate generation strategy
would be to check immediately after we fill a free place,
if the solution conditions still holds for this place row and column.
This would save us a lot of work, because we could discard a lot of
solution candidates much more early in the process.
For example we could discard all the solution candidates that have
Cloud shape at 1B position in the first step of the algorithm.</p>

<p>The name of the technique itself comes from the specific way
in which the algorithm generates all the solution candidates.
The naive backtracking algorithm that solves our simple puzzle looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Board positions:</span>
<span class="c1">// [0 | 1 | 2]</span>
<span class="c1">// [3 | 4 | 5]</span>
<span class="c1">// [6 | 7 | 8]</span>
<span class="c1">// Notice that rowIndex = currentPosition / 3</span>
<span class="c1">// and         colIndex = currentPosition % 3</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">currentPosition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currentPosition</span> <span class="o">==</span> <span class="mi">9</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// All places are filled, check if this</span>
        <span class="c1">// candidate is a valid solution.</span>
        <span class="k">return</span> <span class="nf">isValidSolution</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">isPlaceTaken</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Move to checking the next place.</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Try putting all shapes in the free place</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">shape:</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]</span> <span class="o">{</span> <span class="sc">'C'</span><span class="o">,</span> <span class="sc">'H'</span><span class="o">,</span> <span class="sc">'R'</span> <span class="o">})</span> <span class="o">{</span>
        <span class="n">putShape</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">,</span> <span class="n">shape</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Clear position or BACKTRACK.</span>
        <span class="n">putShape</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">,</span> <span class="sc">'?'</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>The key part of the algorithm is the <code class="highlighter-rouge">for</code> loop,
where we put a shape on the free place and then remove it 
when don’t find a solution. This removal
or taking a move back is what gave the algorithm its name.
Alternatively we may say that when <code class="highlighter-rouge">solve</code> returns <code class="highlighter-rouge">false</code>,
then the <code class="highlighter-rouge">board</code> is exactly in the same state as it was
before we called <code class="highlighter-rouge">solve</code>.</p>

<p>Matching regular expression is somehow similar to solving our previous puzzle.
At each step we have several possibilities, like should we match <code class="highlighter-rouge">foo</code>
or <code class="highlighter-rouge">fo</code> from the alternative <code class="highlighter-rouge">(foo|fo)</code>. How much characters should
<code class="highlighter-rouge">f+</code> expression match? Should <code class="highlighter-rouge">(bar)?</code> match <code class="highlighter-rouge">bar</code> or nothing?
On the other hand the most complexity in matching regular expressions
comes from the fact that we are matching a recurrent structure (tree).
It’s like matching our puzzle, but where each empty place can contain
another smaller version of the same puzzle that also must be solved.</p>

<p>The main entry point to our regex matching algorithm is</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Cont</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">ast</span><span class="o">,</span> <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span></code></pre></figure>

<p>method. It takes three parameters, <code class="highlighter-rouge">input</code> which is just
the input <code class="highlighter-rouge">String</code> plus a pointer called <code class="highlighter-rouge">pos</code> that tracks next, not yet
matched character. <code class="highlighter-rouge">Input</code> also provides helpful methods that can
be used to save and restore <code class="highlighter-rouge">pos</code> value (we will need that
for backtracking). Next parameter, <code class="highlighter-rouge">ast</code>, is an AST subtree that the algorithm
should match. The last parameter <code class="highlighter-rouge">cont</code> is the most interesting one.
In my previous blog post I wrote about 
<a href="/continuations-in-java">continuations</a>, please read that post before
going further. <code class="highlighter-rouge">cont</code> is lambda expression (but we may thread it also as
a kind of continuation), that when called will
try to match remaining part of the regex AST (e.g. it will match parents
and the remaining siblings nodes of <code class="highlighter-rouge">ast</code> node).</p>

<p>The contract of <code class="highlighter-rouge">match</code> method is as follows.
If the method is not able to match <code class="highlighter-rouge">ast</code> subtree it will
return <code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">cont</code> will not be called and the <code class="highlighter-rouge">input</code>
will not be modified (or it may be restored to the original state).
On the other hand if <code class="highlighter-rouge">ast</code> subtree could be matched then
<code class="highlighter-rouge">cont</code> will be called with the modified <code class="highlighter-rouge">input</code> and
<code class="highlighter-rouge">match</code> will return whatever <code class="highlighter-rouge">cont</code> returns.
Before returning value to the client <code class="highlighter-rouge">input</code> will be restored
to the original state (this is not strictly necessary if we
are looking for the first match but somehow makes algorithm more elegant).</p>

<p>At the top level we will call <code class="highlighter-rouge">match</code> somehow like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">currentPos</span><span class="o">();</span>
<span class="n">AtomicInteger</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="kt">boolean</span> <span class="n">hasMatch</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">regex</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">endIndex</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">currentPos</span><span class="o">());</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">});</span></code></pre></figure>

<p>This call means that we are looking for the matches
starting at index <code class="highlighter-rouge">startIndex</code> and if we find one
we save the
end of the match in the <code class="highlighter-rouge">endIndex</code> variable and return <code class="highlighter-rouge">true</code>
to signify that matching process should stop.
This is the only place in the algorithm where we use
<code class="highlighter-rouge">return true</code>. Matched substring could be easily
retrieved as <code class="highlighter-rouge">input.substring(startIndex, endIndex)</code>.</p>

<p>The body of <code class="highlighter-rouge">match</code> method is a giant switch statement that
delegates matching of different AST types to different methods (not counting simple
operators):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">ast</span><span class="o">,</span> <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">RAstType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="na">type</span><span class="o">;</span>
    <span class="n">InputPositionMarker</span> <span class="n">m</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">switch</span> <span class="o">(</span><span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* some cases skipped */</span>

        <span class="k">case</span> <span class="nl">GROUP:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">atEnd</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ast</span><span class="o">.</span><span class="na">chars</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">current</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">markPosition</span><span class="o">();</span>
                <span class="n">input</span><span class="o">.</span><span class="na">advance</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">input</span><span class="o">.</span><span class="na">restorePosition</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">case</span> <span class="nl">CONCAT:</span>
            <span class="k">return</span> <span class="nf">concatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">.</span><span class="na">exprs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">case</span> <span class="nl">ALTERNATIVE:</span>
            <span class="k">return</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">.</span><span class="na">exprs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">case</span> <span class="nl">REPEAT:</span>
            <span class="k">return</span> <span class="nf">repeatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">default</span><span class="o">:</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">AssertionError</span><span class="o">(</span><span class="s">"Unknown AST type: "</span> <span class="o">+</span> <span class="n">type</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Let’s take a look how matching a <code class="highlighter-rouge">GROUP</code> is performed.
If the group matches next input character, we save the current
input pointer in <code class="highlighter-rouge">m</code> variable, then we advance the input pointer 
and finally we call <code class="highlighter-rouge">cont</code> to match the
rest of the regex. After <code class="highlighter-rouge">cont</code> returns we restore the input position
using <code class="highlighter-rouge">finally</code> block. This is a bit hacky but it works.</p>

<p>Matching <code class="highlighter-rouge">CONCAT</code> node is also simple. We use recursion to match
subsequent children expressions:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">concatRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                 <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">exprs</span><span class="o">,</span>
                                 <span class="kt">int</span> <span class="n">currExpr</span><span class="o">,</span>
                                 <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currExpr</span> <span class="o">==</span> <span class="n">exprs</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// We matched all the children</span>
        <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Match exprs.get(currExpr) child</span>
    <span class="k">return</span> <span class="nf">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">exprs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currExpr</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span>
        <span class="c1">// If it succeeded then match next child expression </span>
        <span class="n">concatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">exprs</span><span class="o">,</span> <span class="n">currExpr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)</span>
    <span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that because we are not consuming any input here we have
nothing to restore.</p>

<p>Similarly <code class="highlighter-rouge">ALTERNATIVE</code> is easy to match:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                      <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">expr</span><span class="o">,</span>
                                      <span class="kt">int</span> <span class="n">currExpr</span><span class="o">,</span>
                                      <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currExpr</span> <span class="o">==</span> <span class="n">expr</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// We tried all branches but found no match.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Try matching expr.get(currExpr) branch of the alternative</span>
    <span class="kt">boolean</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currExpr</span><span class="o">),</span> <span class="n">cont</span><span class="o">);</span>
    <span class="c1">// We found a match</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">matched</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="c1">// No match found - Let's try next alternative "branch"</span>
    <span class="k">return</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">expr</span><span class="o">,</span> <span class="n">currExpr</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Here <code class="highlighter-rouge">currExpr</code> points to the current alternative branch that we are matching.
Instead of using recursion we may implement <code class="highlighter-rouge">alternativeRec</code> 
using a simple <code class="highlighter-rouge">for</code> loop, which I left as an exercise for the reader.</p>

<p>Matching <code class="highlighter-rouge">REPEAT</code> node causes the most troubles, because all
quantification operators are greedy by default. This means that
e.g. <code class="highlighter-rouge">a+</code> will try to match as much characters as possible.
To implement this behavior we first attempt to match <code class="highlighter-rouge">REPEAT</code>s child subtree 
as many times as possible, then we move “backwards” calling <code class="highlighter-rouge">cont</code>
each time to check if we have a match.
The diagram below illustrates this process:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">We match a+ expression:
a
a a
a a a         // We matched a three times.
a a a noMatch // Forth time we have noMatch.
a a a cont()  // We move backwards, calling cont()
a a cont()    // each time until it returns true.
a cont() match // cont() returned true.
               // We stop moving backwards and return true from a+.</code></pre></figure>

<p>The code of <code class="highlighter-rouge">repeatRec</code> is:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">repeatRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                 <span class="n">RAst</span> <span class="n">repeatAst</span><span class="o">,</span>
                                 <span class="kt">long</span> <span class="n">matchCount</span><span class="o">,</span>
                                 <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// For expressions like R{n,m} do we have</span>
    <span class="c1">// more matches than necessary?</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">matchCount</span> <span class="o">&gt;</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">repeatMax</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Greedy matching as much as possible.</span>
    <span class="kt">boolean</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">headExpr</span><span class="o">(),</span> <span class="o">()</span> <span class="o">-&gt;</span>
        <span class="n">repeatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">repeatAst</span><span class="o">,</span> <span class="n">matchCount</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)</span>
    <span class="o">);</span>

    <span class="c1">// We are moving backwards, calling `cont` each time.</span>
    <span class="c1">// We also make sure that we have min number of matches</span>
    <span class="c1">// for expressions like R{n,m}.</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">matched</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">matchCount</span> <span class="o">&gt;=</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">repeatMin</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">matched</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>And generally that’s it. Our simple regex engine.
There are some details left (like handling <code class="highlighter-rouge">^</code> or <code class="highlighter-rouge">$</code> or
moving <code class="highlighter-rouge">startIndex</code>) but the idea behind the backtracking
matcher should now be familiar to us.</p>

<p>You can find source code for the engine (including tests)
on GitHub: <a href="https://github.com/marcin-chwedczuk/reng">https://github.com/marcin-chwedczuk/reng</a>. But before you jump to see the
code I really recommend you to write a similar engine (in your
favorite language) yourself. This will give you a much more
deeper understanding of the algorithm.</p>

<p>Last but not least, our algorithm has a decent performance,
given that we use reasonable regexes and inputs.
A regex like <code class="highlighter-rouge">(a+)*c</code> matched on the input <code class="highlighter-rouge">aaaaaaaaaaaaaaaaaaaaaaaaaaaab</code>
will have a very bad performance. This is a common problem
not only in our matcher but in most regex libraries
that use backtracking algorithms. You can 
read more about this problem on <a href="https://en.wikipedia.org/wiki/ReDoS">Wikipedia</a>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Continuations in Java</title>
	  <link>//continuations-in-java</link>
	  <author></author>
	  <pubDate>2020-06-27T02:00:01+02:00</pubDate>
	  <guid>//continuations-in-java</guid>
	  <description><![CDATA[
	     <p>CSP or Continuation-Passing Style is a style of programming in which
functions return results via callbacks.
For example <code class="highlighter-rouge">+</code> operator is a function that takes two numbers and
returns their sum. In CSP <code class="highlighter-rouge">+</code> operator becomes a function that takes
three arguments, two terms and a callback, usually called a continuation in
the context of CSP.
In Java we can express this as:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Cont</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">R</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Because functions’ results are always returned via callback calls,
CSP is forcing us to name the returned values by naming callback parameters.
In addition CSP makes the order of evaluation of an expression explicit.
For example, a simple Java program in imperative style:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></code></pre></figure>

<p>Can be expressed in CSP as follows:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">partialSum</span> <span class="o">-&gt;</span>
  <span class="n">add</span><span class="o">(</span><span class="n">partialSum</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span>
    <span class="n">print</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">unit</span> <span class="o">-&gt;</span>
      <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">))));</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
  <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>While transforming imperative programs into CSP form we may encounter
problems with handling procedures (methods returning <code class="highlighter-rouge">void</code> in Java).
A lot of functional programming languages do not support procedures,
instead they define a special type called <code class="highlighter-rouge">Unit</code>, that has only
a single value and use that type to signify that function does
not return any meaningful data.
So defined <code class="highlighter-rouge">Unit</code> type is often identified with the empty tuple <code class="highlighter-rouge">()</code>.
In Java we do not have <code class="highlighter-rouge">Unit</code>, but we may use <code class="highlighter-rouge">Void</code> type with its only
allowed value <code class="highlighter-rouge">null</code> to simulate it.</p>

<p>While looking at our last example we may notice that in CSP form,
function arguments can be in one of three forms:
a constant, a variable or a lambda expression.
There is no rule preventing us from passing two or more
callbacks to a single function. 
Indeed this is necessary to translate <code class="highlighter-rouge">if</code> statement to CSP counterpart:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">iff</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expr</span><span class="o">,</span>
         <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">trueBranch</span><span class="o">,</span>
         <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">falseBranch</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">expr</span><span class="o">)</span> <span class="n">trueBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="k">else</span> <span class="n">falseBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Instead of <code class="highlighter-rouge">Cont&lt;Boolean&gt;</code> we could use here <code class="highlighter-rouge">Cont&lt;Void&gt;</code> as well.</p>

<p>To get a better feel for CSP we will look at three more examples.
We will start with a simple (naive) program for computing sum
of all numbers between given two numbers:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>The transformation to CSP will become easier
if we first replace <code class="highlighter-rouge">for</code> loop with recursion:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum_rec</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="o">)</span>
    <span class="o">?</span> <span class="mi">0</span>
    <span class="o">:</span> <span class="n">from</span> <span class="o">+</span> <span class="n">sum_rec</span><span class="o">(</span><span class="n">from</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>This version can be easily translated into CSP:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">sumCC</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">gt</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">fromGreaterThanTo</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">fromGreaterThanTo</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">0L</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">from1</span> <span class="o">-&gt;</span>
        <span class="n">sumCC</span><span class="o">(</span><span class="n">from1</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">sumCC1</span> <span class="o">-&gt;</span>
          <span class="n">addLong</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">sumCC1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>Where <code class="highlighter-rouge">gt</code> is the CSP counterpart of <code class="highlighter-rouge">&gt;</code> operator.</p>

<p>Next we will transform factorial computing function.
This time we will start with a recursive definition that is 
easier to translate:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">return</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">n</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>CSP version of factorial looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">eq</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">isNZero</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">isNZero</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">factorial</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">fnm1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>As the last example we will transform a function
that computes Fibonacci sequence:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">int</span> <span class="nf">fib1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">fib1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>In CSP it looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">lt</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nlt2</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">nlt2</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">fib</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">nm2</span> <span class="o">-&gt;</span>
            <span class="n">fib</span><span class="o">(</span><span class="n">nm2</span><span class="o">,</span> <span class="n">fnm2</span> <span class="o">-&gt;</span>
              <span class="n">add</span><span class="o">(</span><span class="n">fnm1</span><span class="o">,</span> <span class="n">fnm2</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))))));</span>
<span class="o">}</span></code></pre></figure>

<p>Now we should have, at least intuitive feel, how the
transformation to CSP works. In fact any program can be
transformed to CSP. The last point is quite interesting,
especially if we pass <code class="highlighter-rouge">() -&gt; exit(0)</code> or some other not-returning function
as the last continuation. Why? Because in that case we will
never return from any of the called functions.
Let’s see how this works on a simple example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">factorial</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="n">fac6</span> <span class="o">-&gt;</span>
      <span class="n">print</span><span class="o">(</span><span class="n">fac6</span><span class="o">,</span> <span class="n">x</span> <span class="o">-&gt;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Will never be printed"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>The entire idea of having a call stack is about providing a way for
the called functions to return the control to the callers.
But if we are never returning, then we don’t need a call stack, right?
Not so fast, some of you may say - what about passing arguments to 
the called functions,
call stack is used for that too. Yes, the arguments are also stored on
the call stack but with CSP we capture 
the values of arguments using closures.
Of course JVM does not know that our programs are in CSP form or that they 
would do fine without having a call stack at all.
Instead we get a new call stack frame every time we call something,
this results in <code class="highlighter-rouge">StackOverflowError</code> quickly when we call
e.g. <code class="highlighter-rouge">factorial(3000, r -&gt; ...)</code>.</p>

<p>Too avoid <code class="highlighter-rouge">StackOverflowError</code>s we may use a technique called trampolining. 
Trampolining in connection with CSP
could reduce the required call stack space to a constant number
of slots.
The idea of trampolining is very simple, we split computation into
parts and then we compute only the first part and <em>return</em> a 
continuation (called thunk) that is responsible for computing the rest. 
The returned continuation captures the result of the first computation in
its closure so we don’t have to recompute it.
Let’s see how a trampolined <code class="highlighter-rouge">+</code> operator would looks like:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">add3</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span>
            <span class="n">add</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">cont</span><span class="o">));</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Cont</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Thunk</span> <span class="nf">apply</span><span class="o">(</span><span class="n">R</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Thunk</span> <span class="o">{</span>
    <span class="n">Thunk</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that trampolined <code class="highlighter-rouge">+</code> operator splits its computation
into two parts: computing the sum and calling the continuation.
The called continuation will again split it’s work and so on and on.</p>

<p><code class="highlighter-rouge">add3</code> function illustrates two key points. 
One is that the logical flow of the program stays the same, we just
call the passed continuations like in a pure CSP program.
The other is, that to introduce trampolining we only need to modify
primitives provided by our programming language (operators and statements).
The program code stays the same.
Of course because Java is a statically-typed language we need to change 
functions return type from <code class="highlighter-rouge">void</code> into <code class="highlighter-rouge">Thunk</code>, but this is
a simple mechanical change that would not be necessary in 
a dynamically-typed language.</p>

<p>Next example illustrates how trampolined <code class="highlighter-rouge">if</code> statement and
<code class="highlighter-rouge">factorial</code> looks like. Notice that factorial code did not change,
not counting the return type:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">iff</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expr</span><span class="o">,</span>
                 <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">trueBranch</span><span class="o">,</span>
                 <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">falseBranch</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">expr</span><span class="o">)</span>
    <span class="o">?</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">trueBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">falseBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">eq</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">isNZero</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">isNZero</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">factorial</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">fnm1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>Because we are now performing computation “in parts”, we need 
a procedure that will be continually invoking returned thunks,
thus ensuring that out computation is making progress.
A procedure like this is called a trampoline:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">trampoline</span><span class="o">(</span><span class="n">Thunk</span> <span class="n">thunk</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">thunk</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">thunk</span> <span class="o">=</span> <span class="n">thunk</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">endCall</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">call</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="n">call</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">};</span>
<span class="o">}</span></code></pre></figure>

<p>We are also providing a new primitive operator <code class="highlighter-rouge">endCall</code> that
can be used to mark the last part of the computation.
Using <code class="highlighter-rouge">trampoline</code> we may now compute <code class="highlighter-rouge">factorial(3000)</code>
without any troubles:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">AtomicInteger</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
<span class="n">trampoline</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="mi">400000</span><span class="o">,</span> <span class="n">endCall</span><span class="o">(</span><span class="nl">res:</span><span class="o">:</span><span class="n">set</span><span class="o">)));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">())</span></code></pre></figure>

<p>As a side effect, we may now use trampoline to mix
CSP and imperative code in the same program.</p>

<p>CSP and trampolining are not mere theoretical concepts,
there where and are still used to implement e.g. LISP interpreters.
Continuations can also be used to simplify backtracking algorithms.
Source code for this blog post can be found
<a href="https://github.com/marcin-chwedczuk/reng/tree/master/test/pl/marcinchwedczuk/continuations">here</a>.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Jak zacząć przygodę z elektroniką</title>
	  <link>//jak-zaczac-przygode-z-elektronika</link>
	  <author></author>
	  <pubDate>2019-12-30T01:00:01+01:00</pubDate>
	  <guid>//jak-zaczac-przygode-z-elektronika</guid>
	  <description><![CDATA[
	     <p>Parę miesięcy temu postanowiłem powrócić do mojego
hobby z czasów dzieciństwa: elektroniki.
Powrót, po ponad dziesięciu latach przerwy, okazał
się być trudniejszy niż przypuszczałem,
a droga do pierwszego działającego układu 
pełna frustracji i porażek.</p>

<p>Pomimo tego radość z wykonania najprostszego generatora,
który naprzemiennie migał diodami LED dostarczyła
mi tak dużo radości i frajdy, że przez kilka następnych
wieczorów oddałem się w całości budowie kolejnych układów.</p>

<p>Niestety elektronika jako hobby, nie jest
już w Polsce tak popularna jak 
miało to miejsce w końcówce lat dziewięćdziesiątych.
A szkoda, bo na zachodzie mamy obecnie do czynienia
z prawdziwym boomem na elektronikę.
Dobrze ilustrują to platformy takie jak
<a href="https://www.arduino.cc/">Arduino</a> czy
<a href="https://www.raspberrypi.org/">Raspberry PI</a>.
Nie wspominając już o modzie na retro-computing
(a więc na budowę prostych, często 8-bitowych komputerów wprost
z układów scalonych) uosabianej przez takie postaci
jak <a href="https://www.youtube.com/channel/UCS0N5baNlQWJCUrhCEo8WlA">Ben Eater</a>
i projekty jak <a href="https://monster6502.com/">The MOnSter 6502</a> i
<a href="https://gigatron.io/">Gigatron</a></p>

<p>Niestety nauka nowej umiejętności czy jest nią jazda samochodem,
czy język obcy czy też elektronika, nie jest prosta.
Na początkujących czyha wiele pułapek, które zniechęcają ich 
do dalszej nauki. Dlatego, aby ułatwić początkującym wejście w
świat elektronik, postawiłem podzielić się moimi doświadczeniami
(czytaj wpadkami)
i opisać problemy na jakie się natknąłem.
To jest pierwszy wpis z tej serii, w którym opisuję
pułapki które czekają nas przy zakupie pierwszych płytek
stykowych, przewodów i elementów elektronicznych. Zapraszam!</p>

<h4 id="płytka-stykowa">Płytka stykowa</h4>

<p>Według mnie najlepszym sposobem montażu układów, na początku
przygody z elektroniką są płytki stykowe.
Na rysunku poniżej przedstawiam przykład dwóch takich płytek:
<img src="assets/images/2019-12-30/plytki-stykowe-1.jpg" alt="Przykładowe płytki stykowe" /></p>

<p>Płytka oznaczona numerem 1, to przykład płytki droższej
która mimo to posiada kilka poważnych mankamentów.
Po pierwsze brakuje oznaczenia polaryzacji szyn zasilania,
co rodzi pole do przykrych w konsekwencjach pomyłek
(np. nieprawidłowe doprowadzenie zasilania do układu scalonego).
Po drugie szyny zasilania są “przecięte” w połowie płytki
(patrz strzałki). Tego typu “przecięcie” przydaje 
się gdy budujemy układy w których występują dwa poziomy
zasilania np. 3.3V i 5V. Większość początkujących
elektroników korzysta jednak z pojedynczego napięcia zasilania.
W praktyce okazywało się to tak denerwujące że musiałem dodać specjalne
oznaczenia markerem, żeby już więcej się nie zastanawiać dlaczego
połowa układu nie ma napięcia zasilania.</p>

<p>Płytka oznaczona numerem 2 to tania płytka (7 PLN za sztukę),
produkcji chińskiej. Mimo to producent
nie oszczędzał na pomocnych oznaczeniach. 
Każda z czterech linii zasilania
ma swój kolor, każde gniazdo jest adresowane 
za pomocą kombinacji litery (a-j) i liczby (1-65).
Może, na pierwszy rzut oka nie wydaje się to
przydatne, ale w internecie można znaleźć mnóstwo
projektów pomyślanych specjalnie do wykonania
na płytkach stykowych, które zawierają instrukcje
typu: “umieść rezystor 1k w gniazdach 5f i 5c”.</p>

<p>Niestety niska cena płytki nr. 2 znalazła negatywne
odbicie w jakości styków. Korzystanie z tej płytki
rodziło sporo kłopotów: często miałem problemy żeby
włożyć końcówkę przewodu lub nóżkę elementu do danego
gniazda. Czasami pomagało wetknięcie szpilki, czasami
włożenie przewodów najpierw do sąsiadujących gniazd
a dopiero potem przeniesienie ich do tego właściwego.
Czasami pomagało “wiercenie” w gnieździe nóżką diody LED.
Innymi słowy, spora część radości wynikającej z budowania układu 
ustępowała miejsca frustracji związanej z niskiej jakości płytką.</p>

<p>Przed zakupem płytek polecam przeczytać
recenzje, zarówno na polski forach jak i na zagranicznych (oraz
na Amazonie). Osobiście, nie znalazłem jak do tej pory
płytki stykowej godnej polecenia, jeżeli taką znacie to
proszę dodajcie komentarz z linkiem.</p>

<p>Wróćmy jeszcze na chwilę do zdjęcia płytek. 
Część oznaczona numerem cztery to pojedyncza szyna zasilania,
odseparowana od płytki stykowej typu dwa. 
Jak się okazuje od każdej płytki możemy oderwać jedną lub
obie szyny zasilania. Przy wykonywaniu tej operacji
przydaje się nożyk do kartonu, który pozwoli nam
rozciąć izolacyjny materiał znajdujący się na spodzie płytki.</p>

<p>Każda płytka stykowa posiada wypustki, które pozwalają
zbudować “megapłytkę” z dwóch lub większej liczby 
pojedynczych płytek (z obecnymi lub oderwanymi szynami zasilania).
Niestety płytki wyprodukowane przez różne firmy rzadko
są ze sobą kompatybilne. 
Poniżej zamiejszczam zdjęcie takiej “megapłytki”:
<img src="assets/images/2019-12-30/megaplytka.jpg" alt="Megapłytka" /></p>

<p>Oprócz pełonowymiarowych płytek, na ryku dostępne są też
mniejsze modele:
<img src="assets/images/2019-12-30/mini.jpg" alt="Mini płytki" />
Osobiście nie polecam ich początkującym, gdyż są
po prostu za małe.</p>

<p>Wydawało by się że orientacja płytki nie ma żadnego znaczenia.
Warto jednak przy budowie układów podążać za sprawdzoną regułą,
która mówi że prądy powinny płynąć z góry na dół, a sygnały
od lewej do prawej. W praktyce oznacza to że górna wewnętrzna
szyna zasilająca powinna być podłączona do plusa zasilania,
a dolna wewnętrzna do minusa. Przestrzeganie tej
zasady znacznie ułatwi nam doprowadzanie zasilania do układów scalonych.</p>

<p>A skoro już jesteśmy przy układach scalonych, większość
z nich nie posiada prostopadłych nóżek. Zamiast tego
nóżki rozchodzą się nieco na boki, co uniemożliwia umieszczenie
takiego układu w płytce stykowej. Rozwiązaniem tego
problemu jest przygięcie nóżek scalaka przed włożeniem go
do płytki:
<img src="assets/images/2019-12-30/nogi.jpg" alt="Ach te nóżki" /></p>

<p>Zanim opuścimy temat płytek warto jeszcze dodać, że
na opakowaniu płytki znajduje się jeden z najważniejszych
jej parametrów, mianowicie zakres grubości drutów/końcówek/wyprowadzeń
z jakimi płytka współpracuje. Ten parametr okaże się istotny
gdy będziemy planować zakup przewodów kompatybilnych
z płytką (czytaj nie każdy przewód pasuje do danej płytki).</p>

<h4 id="przewody--połączenia--zworki">Przewody / połączenia / zworki</h4>

<p>Oprócz płytki stykowej, przy budowie układów będziemy
też potrzebowali całej masy przewodów.
Osobiście polecam zakup zestawu przewodów
takich jak <a href="https://www.adafruit.com/product/3174">Adafruit Hook-up Wire</a>,
wraz ze szczypcami do ściągania izolacji takimi
jak <a href="https://www.adafruit.com/product/147">Adafruit Wire Stripper</a>:
<img src="assets/images/2019-12-30/druty.jpg" alt="Przewody" />
Przy zakupie warto zwracać uwagę czy na pewno kupujemy
<em>jednożyłowy</em>, <em>cynowany</em> przewód miedziany, a nie na przykład
wielożyłowy (czysta miedź pokrywa się
nieprzewodzącą warstwą tlenków, cynowany drut zapewni
nam znacznie lepszą jakość połączeń).</p>

<p>Przedstawiony powyżej zestaw przewodów ma grubość
drutu AWG 22 (miara amerykańska), co przelicza się
na polskie 0.6438 milimetra średnicy.
Płytki stykowe z pierwszej sekcji, pracują poprawnie z przewodami
o grubościach 0.3-0.8 milimetra, a więc są kompatybilne z tym
zestawem przewodów.</p>

<p>Ze względu na rosnące ceny miedzi zakup zestawów takich
jak te przedstawione powyżej, może wiązać się ze sporym wydatkiem.
Należy jednak pamiętać że
jeden zestaw przewodów powinien zaspokoić nasze potrzeby na mniej więcej rok,
a szczypce to wydatek jednorazowy.
Obecna cena powyższego zestawu przewodów w sklepie <a href="https://pl.mouser.com/">Mouser</a>
wynosi około 120PLN. Oczywiście zawsze warto sprawdzić czy
nie znajdziemy lepszej oferty w polskich sklepach, na ceneo czy
w końcu na AliExpressie.</p>

<p>Oprócz zestawu przewodów, w sklepach można znaleźć również zestawy zworek
(numer jeden na zdjęciu):
<img src="assets/images/2019-12-30/zwory.jpg" alt="Przewody ciąg dalszy" />
Zestawy takie są, w stosunku do ich ceny, kompletnie bezużyteczne.
Zwory prawie nigdy nie miały potrzebnej długości gdy chciałem
ich użyć. Krótkie zworki kończyły się bardzo szybko, podczas
gdy długich zostawał nadmiar. Jednym słowem: nie polecam.</p>

<p>Polecam za to zakup elastycznych przewodów połączeniowych
(numer dwa i trzy na zdjęciu).
Przewody typu trzy dostępne są w zestawach o dość przystępnej
cenie. Przewody typu dwa występują we wstęgach, które można
rozrywać (nawet na pojedyncze przewody) wedle upodobań.</p>

<p>Do zabawy z płytkami stykowymi i Arduino potrzebne nam będą przede
wszystkim przewody z wtykami męskimi (patrz numer trzy).
Do zabawy z Rasbperry PI,
a także z modułami do Arduino (np. czujniki ruchu) przydadzą się
przewody męsko-żeńskie (patrz numer dwa).</p>

<p>Czasami zdarza się, że przewody będące częścią zestawów mają
końcówki wtyków pokryte ochronną warstwą plastiku którą łatwo
przeoczyć. Jeżeli przewód “źle łączy” należy sprawdzić czy
końcówki nie posiadają takiej ochronnej izolacji i ewentualnie
ją usunąć.</p>

<p>Warto zarezerwować sobie dwa kolory (np. czarny i czerwony)
na oznaczenie przewodów które mają potencjał masy i plusa zasilania.
Warto też pomyśleć o konwencji użycia kolorów, na przykład: przewód biały to
zawsze sygnał zegara.
Poza tym im więcej kolorów mamy do dyspozycji tym lepiej.</p>

<h4 id="pozostałe-narzędzia">Pozostałe narzędzia</h4>

<p>Pozostałe przydatne narzędzia to:</p>

<ol>
  <li>Mały płaski śrubokręt</li>
  <li><em>Szczypce tnące boczne</em>
 do ucinania zbyt długich wyprowadzeń elementów
 (<a href="https://botland.com.pl/pl/szczypce/5851-szczypce-tnace-boczne-yato-yt-2081-115mm-5906083920813.html">model ze zdjęcia</a>)</li>
  <li>Oraz najbardziej przydatna z całej tej
 trójki, bo pozwalająca wygodnie wyjmować i wkładać przewody
 połączeniowe - pęseta
 (<a href="https://sklep.avt.pl/peseta-antystatyczna-122mm-prosta-ostra-esd-10.html">model ze zdjęcia</a>)</li>
</ol>

<p><img src="assets/images/2019-12-30/szczypce.jpg" alt="Przydatne narzędzia" /></p>

<p>Przycinanie wyprowadzeń elementów za pomocą
szczypiec może być odrobinę niebezpieczne.
Nóżki, na przykład dużych diod LED, podczas przycinania mają tendencje to
“wystrzeliwania” w znanym tylko sobie kierunku, dlatego
warto też pomyśleć o zakupie 
<a href="https://botland.com.pl/en/goggles/5626-okulary-yt-7367-5906083973611.html">okularów ochronnych</a>.</p>

<p>Ostatnim, naprawdę niezbędnym narzędziem, w jaki
powinniśmy się zaopatrzyć jest multimetr.
Ja używam następującego modelu, mało znanej chińskiej
marki i jestem z niego całkowicie zadowolony:
<img src="assets/images/2019-12-30/multi.jpg" alt="Multimetr" /></p>

<h4 id="elementy-elektroniczne">Elementy elektroniczne</h4>

<p>Można by pomyśleć, że po całym tym zamieszaniu z płytkami,
narzędziami i multimetrem zakup elementów elektronicznych 
będzie czystą przyjemnością.
Nic bardziej mylnego!
Pierwszym zaskoczeniem jakie mnie spotkało, była niewielka
średnica wyprowadzeń resystorów zakupionych w zestawie
“dla początkujących”. Średnica była tak mała, że czasami
trudno było uzyskać dobre połączenie z płytką stykową.
Ostatecznie skończyłem z <a href="https://botland.com.pl/pl/rezystory-przewlekane/13895-zestaw-rezystorow-cf-tht-14w-velleman-kres-e3-480szt-5410329241803.html">tym zestawem rezystorów</a></p>

<p><img src="assets/images/2019-12-30/vkit.jpg" alt="Zestaw velleman-kit" /></p>

<p>Dobrze ilustruje to powyższe zdjęcie, rezystor oznaczony
numerem jeden pochodzi z taniego zestawu “dla początkujących”.
Posiada długie i cienkie wyprowadzenia słabo współpracujące z
płytkami stykowymi. Rezystor oznaczony numerem dwa pochodzi
z zestawu velleman’a - wyraźnie widać krótsze, ale za to
grubsze i bardziej masywne wyprowadzenia.</p>

<p>Osobiście odradzam również zakup rezystorów o mocy większej
niż 0,25W. Rezystory 1W w porównaniu do 0,25W to prawdziwe olbrzymy.</p>

<p>W przeciwieństwie do rezystorów, zakup diod LED
(polecam “duże” 5mm) czy kondensatorów nie sprawiał
większych problemów, elementy po prostu działały.</p>

<p>Z kolei zakup przycisków (“switchy”) i potencjometrów
sprawił mi trochę kłopotów. Okazuje się że wiele elementów
występuje w dwóch wersjach: do wlutowania i do płytek stykowych.
Popatrzmy na zdjęcie:
<img src="assets/images/2019-12-30/proste.jpg" alt="Elementy do wlutowania i do płytek stykowych" />
Elementy z grupy pierwszej są przeznaczone do wlutowania.
Elementy z grupy drugiej, charakteryzującej się prostymi
wyprowadzeniami, są przewidziane do umieszczenia na płytkach
stykowych. Zawsze należy dokładnie sprawdzić czy na pewno
kupujemy takie elementy, jakich naprawdę potrzebujemy.</p>

<p>Na koniec, żeby nie tracić czasu na mozolne odnajdywanie potrzebnych
elementów, warto zaopatrzyć się w dobry organizer:
<img src="assets/images/2019-12-30/organizer.jpg" alt="Organizer" /></p>

<h4 id="zasilanie">Zasilanie</h4>

<p>Początkowo zasilałem moje układy z baterii 9V.
Wykorzystywałem do tego celu kijankę (numer jeden),
gniazdo które można włożyć w szynę zasilania płytki stykowej (numer trzy) oraz
konwerter (numer dwa):
<img src="assets/images/2019-12-30/zas1.jpg" alt="Zasilanie z bateri 9V" />
Konwerter okazał się konieczny, ponieważ zakupu
gniazda dokonałem “na oko”, nie będąc świadom że
istnieje wiele różnych rozmiarów wtyków zasilania.</p>

<p>Osobiście nie polecam tego sposobu zasilania.
Po pierwsze jesteśmy zdani na napięcie baterii, a wiele
układów wymaga niestandardowych napięć 3,3V lub 5V.
Po drugie zaśmiecamy środowisko zużytymi bateriami,
przy jednoczesnym zubożaniu naszego portfela.</p>

<p>Najlepszym rozwiązaniem, dla osób dysponujących zapasem
gotówki jest kupno zasilacza laboratoryjnego,
nazywanego również zasilaczem warsztatowym.
Dla wszystkich pozostałych, przynajmniej na początku,
dobrym kompromisem jest zakup 
<a href="https://sklep.avt.pl/avt3072.html">zasilacza płytek stykowych</a>:
<img src="assets/images/2019-12-30/zas2.jpg" alt="Zasilacz do płytek stykowych" />
Należy pamiętać że sam zasilacz to tylko prosta płytka PCB
(ang. printed circuit board, pl. płytka drukowana), do
pracy potrzebny jej jest <a href="https://sklep.avt.pl/zasilacz-impulsowy-12v-1-5a-18w-dc2-5-5-5.html">zasilacz impulsowy</a> - oznaczony na zdjęciu numerem dwa.</p>

<p>Przedstawiony powyżej zasilacz, który służy mi już kilka miesięcy,
niestety nie jest pozbawiony wad.
Najpoważniejsza z nich jest taka, że nie jesteśmy ostrzegani
o zwarciu przewodów zasilania.
Istnieją na rynku zasilacze które np. piszczą
gdy dojdzie do zwarcia.
W powyższym zasilaczu, zwarcie można rozpoznać jedynie po
silnie rozgrzanym radiatorze.
Dlatego, pomimo że podałem linki do sklepu, zachęcam was do
poszukania lepszego modelu lub jeżeli już taki
posiadacie do pozostawienia komentarza z linkiem.</p>

<h4 id="sklepy">Sklepy</h4>

<p>Na koniec lista sklepów z których jestem
względnie zadowolony:</p>

<ul>
  <li>
    <p><a href="https://sklep.avt.pl/">Sklep AVT</a> związany od wielu lat
 z czasopismem “Elektronika dla wszystkich”</p>
  </li>
  <li>
    <p><a href="https://botland.com.pl/pl/">Botland</a></p>
  </li>
</ul>

<p>Z zagranicznych warto wspomnieć:</p>

<ul>
  <li><a href="https://pl.mouser.com/">Mouser</a> - ten sklep
 śmiało można nazwać profesjonalnym.
 Można łatwo i szybko (czas dostawy nie przekracza tygodnia)
 dostać układy praktycznie niedostępne na polskim rynku.
 Ale uwaga, ceny produktów podane są na modłę amerykańską, 
 a więc nie zawierają
 23% podatku VAT. Najeży o tym pamiętać porównując oferty.</li>
</ul>

<p>Oczywiście zawsze warto korzystać z porównywarek cen
i sprawdzać opinie sklepów na forach internetowych.
Bardziej odważni i cierpliwi mogą spróbować szczęścia na AliExpressie.</p>

<p>Na zakończenie, “starożytne” i niestety niedziałające, układy
scalone polskiej produkcji (sic!), które otrzymałem od jednego
z polskich sklepów:
<img src="assets/images/2019-12-30/cemi.jpg" alt="Polskie scalaki" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>Pitfalls of using Mockito with Scala</title>
	  <link>//pitfalls-of-using-Mockito-with-Scala</link>
	  <author></author>
	  <pubDate>2019-12-22T01:00:01+01:00</pubDate>
	  <guid>//pitfalls-of-using-Mockito-with-Scala</guid>
	  <description><![CDATA[
	     <p>I need to test my new, shiny Scala code.
Usually I write tests in <a href="http://www.scalatest.org/">ScalaTest</a>,
but for generating stubs I still use good, old
<a href="https://site.mockito.org/">Mockito</a>.
What can possibly go wrong?
I open a new tab in my editor and start hacking test code.</p>

<p>For the first surprise I don’t have to wait too long.
In my code I use <a href="https://docs.scala-lang.org/overviews/core/value-classes.html">value classes</a> 
to represent entity IDs.
For example I use <code class="highlighter-rouge">CustomerId</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span></code></pre></figure>

<p>When I tried to mock <code class="highlighter-rouge">customerId</code> method (property?):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">RequestContext</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">customerId</span><span class="k">:</span> <span class="kt">CustomerId</span>
  <span class="c1">// ...
</span><span class="o">}</span></code></pre></figure>

<p>in my test, Mockito started complaining about wrong return types
and refused to cooperate:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// inside test
</span><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="cm">/* Fails with WrongTypeOfReturnValue exception:
*
* CustomerId cannot be returned by customerId()
* customerId() should return long
*/</span>
<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>Of course my <code class="highlighter-rouge">CustomerId</code> <a href="https://docs.scala-lang.org/overviews/core/value-classes.html">value class</a> is here to blame…</p>

<p>In Scala, value classes offer type safety of normal classes with
performance of the primitives.
Scala compiler achieves this, simply by replacing the value
class type by the primitive type, wherever possible.
So I grabbed <code class="highlighter-rouge">javap</code> and took a look at the generated bytecode,
and indeed there is a <code class="highlighter-rouge">long</code> there:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">target/scala-2.13/classes$ javap RequestContext.class 
Compiled from "RequestContext.scala"
public interface RequestContext {
  public abstract long customerId();
  // ...
}</code></pre></figure>

<p>Mockito uses reflection to figure out which type
a given method returns.
This gives us little hope for a nice solution.
We can only try to hack around the problem, for example
this monstrosity works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Object</span><span class="o">])</span>
  <span class="o">.</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="n">box</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="n">assert</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span> <span class="o">==</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>We use <code class="highlighter-rouge">asInstanceOf[Object]</code> to fool Scala’s type system
and then return a <code class="highlighter-rouge">java.lang.Long</code> instance.</p>

<p>Yeah it works but it is not nice… But hey, first get the job done, then
get it done well. Let’s move on to the next test…</p>

<p>I have to verify that a given method was called.
This time I should have more luck, right?
So I wrote another test and I ran it:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// works perfectly 
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// does NOT WORK 
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">any</span><span class="o">())</span></code></pre></figure>

<p>But I saw the results I was completly perplexed.
Verification with <code class="highlighter-rouge">RequestId(123L)</code> worked but the one with
<code class="highlighter-rouge">any()</code> did not. But what is worse the second verification
thrown <code class="highlighter-rouge">NullPointerException</code>. NPE? Really?</p>

<p>My brain was racing, and after a few seconds a thought strike me:
it’s these pesky value classes again!</p>

<p>And I was right! Value classes in Scala cannot be <code class="highlighter-rouge">null</code>!
For example, in Scala REPL:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">FooId</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">FooId</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">FooId</span> <span class="o">=</span> <span class="kc">null</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FooId</span><span class="o">]</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">FooId</span> <span class="o">=</span> <span class="nc">FooId</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">id</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// And more...
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">o</span><span class="k">:</span> <span class="kt">Object</span> <span class="o">=</span> <span class="kc">null</span>
<span class="n">o</span><span class="k">:</span> <span class="kt">Object</span> <span class="o">=</span> <span class="kc">null</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FooId</span><span class="o">]</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">NullPointerException</span>
  <span class="o">...</span> <span class="mi">33</span> <span class="n">elided</span></code></pre></figure>

<p><code class="highlighter-rouge">any()</code> matcher that comes with Mockito has a very simple
implementation:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">any</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">anyObject</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Deprecated</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">anyObject</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">reportMatcher</span><span class="o">(</span><span class="n">Any</span><span class="o">.</span><span class="na">ANY</span><span class="o">);</span>
  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>that always returns <code class="highlighter-rouge">null</code>.</p>

<p>The method that I tried to check, has a signature:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">RequestContext</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">setRequestId</span><span class="o">(</span><span class="n">requestId</span><span class="k">:</span> <span class="kt">RequestId</span><span class="o">)</span>
  <span class="c1">// ...
</span><span class="o">}</span></code></pre></figure>

<p>and since <code class="highlighter-rouge">RequestId</code> is a value class, the “real” JVM signature is:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">public abstract void setRequestId(long);</code></pre></figure>

<p>When I write <code class="highlighter-rouge">verify(...).setRequestId(any())</code> 
Scala compiler adds instructions that convert the <em>object</em> returned
by <code class="highlighter-rouge">any()</code> (remember generics does not exist on JVM level, so all
these <code class="highlighter-rouge">T</code>s and <code class="highlighter-rouge">V</code>s are just <code class="highlighter-rouge">Object</code>s at runtime) to <code class="highlighter-rouge">long</code>.
And this is the reason why I got <code class="highlighter-rouge">NullPointerException</code> earlier.</p>

<p>In bytecode it looks like this:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">19: invokestatic  #33 // Method org/mockito/Mockito.verify:(Ljava/lang/Object;)Ljava/lang/Object;
22: checkcast     #17 // class RequestContext
25: invokestatic  #39 // Method org/mockito/ArgumentMatchers.any:()Ljava/lang/Object;
28: checkcast     #41 // class RequestId
31: invokevirtual #45 // Method RequestId.id:()J
34: invokeinterface #29, 3 // InterfaceMethod RequestContext.setRequestId:(J)V</code></pre></figure>

<p>and the NPE is thrown by the instruction at the offset <code class="highlighter-rouge">31</code>.</p>

<p>Now I understand the problem, but I still want to use <code class="highlighter-rouge">any()</code> matcher.
There must be a trick to make it return a valid <code class="highlighter-rouge">RequestId</code>.
But then I realized that even if I found such a way, I would be
bitten again by <code class="highlighter-rouge">WrongTypeOfReturnValue</code> exception or
something similar, since
the method takes <code class="highlighter-rouge">long</code> not <code class="highlighter-rouge">RequestId</code>. What I really need is
a way to use <code class="highlighter-rouge">anyLong()</code> with <code class="highlighter-rouge">setRequestId</code>. It was a good
enough challenge to
start my evil alter-ego working on some frankensteinian solution.
And I found it, I FOUND IT!, I FOUND IT!!! Ehmm… and here it is:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// works again
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="n">anyLong</span><span class="o">()))</span>
<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span>
  <span class="nc">RequestId</span><span class="o">(</span><span class="nc">ArgumentMatchers</span><span class="o">.</span><span class="n">eq</span><span class="o">(</span><span class="mi">123L</span><span class="o">)))</span></code></pre></figure>

<p>A perfect combination of beauty and evil…</p>

<p>The trick that I used here is that Mockito does not care,
where the matcher is located, it only cares about the time when it
is called. As long as I call <code class="highlighter-rouge">anyLong()</code> after the call to
<code class="highlighter-rouge">verify(...)</code> and before the call to <code class="highlighter-rouge">.setRequestId(...)</code>,
Mockito will work. Actually we may wrap <em>any</em> matcher in
as many dummy calls as we want, as in <code class="highlighter-rouge">a(b(c(d(any()))))</code>,
only the fact that it was called counts.</p>

<p>It can’t be worse right? Two tests, two hacks…</p>

<p>But only I wrote my third test, I was slapped by the next problem,
this time caused by default parameters:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">SomeTrait</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">method</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="n">test</span><span class="o">(</span><span class="s">"..."</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">])</span>

 <span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

 <span class="cm">/* This call fails with:
 * Argument(s) are different! Wanted:
 *  someTrait.method(3, 100);
 * Actual invocations have different arguments:
 *  someTrait.method(3, 0);
 */</span>
 <span class="c1">// verify(someTrait).method(3, 100)
</span>
 <span class="c1">// works
</span> <span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>WTF? Not again… Another strange problem that forces me
to look under the bonnet.</p>

<p>Let’s look at the bytecode using <code class="highlighter-rouge">javap -c</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// bytecode of `someTrait.method(3)`
// (some code skipped here)
// 3 - load first arg onto the stack
10: iconst_3

// Scala Magic(TM), call a method to get the second
// argument's default value and push it onto the stack:
// someTrait.method$default$2()
11: aload_0
12: invokeinterface #27,  1

// finally call the `method` method
17: invokeinterface #31,  3
// (some code skipped here)</code></pre></figure>

<p>So the Scala compiler calls a hidden method, with a name
<code class="highlighter-rouge">methodName$default$parameterIndex</code> on the trait,
to figure out what value should be used as a value
of the default parameter. Wow! I didn’t expect something
like that!</p>

<p>If only I could stub this <code class="highlighter-rouge">method$default$2</code> or something :thinking:
:thinking: :thinking:
…oh wait I could:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">])</span>
<span class="n">when</span><span class="o">(</span><span class="n">someTrait</span><span class="o">.</span><span class="n">method$default$2</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>

<span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="c1">// it works!
</span><span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span></code></pre></figure>

<p>Excellent. It is working perfectly but now I have three tests
and three hacks. Surely I am doing something wrong here.</p>

<p>And so I harnessed the power of Google (after spending
some time looking at the pictures of stoats;
hey they are really cute) and found this gem:</p>

<p><a href="https://github.com/mockito/mockito-scala">Mockito-Scala</a></p>

<p>I plug it into my project (it even has a special version
for ScalaTest) and suddenly everything started to working
as it should be.</p>

<p>Stubbing works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.mockito.ArgumentMatchersSugar._</span> <span class="c1">// from Mockito-Scala
</span><span class="k">import</span> <span class="nn">org.mockito.MockitoSugar._</span>
<span class="c1">// Don't import Mockito or ArgumentMatchers
</span>
<span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">]</span>
<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span> <span class="o">==</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>…and verification works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">]</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">eqTo</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">)))</span>
<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">any</span><span class="o">[</span><span class="kt">RequestId</span><span class="o">])</span>
<span class="o">//</span> <span class="n">but</span> <span class="k">this</span> <span class="n">will</span> <span class="n">not</span> <span class="n">work</span><span class="k">:</span> <span class="kt">verify</span><span class="o">(</span><span class="kt">requestContext</span><span class="o">)</span><span class="kt">.setRequestId</span><span class="o">(</span><span class="kt">any</span><span class="o">)</span></code></pre></figure>

<p>even default parameters work:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">]</span>
<span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span></code></pre></figure>

<p>Yay!</p>

<p>Wanna see some real code? <a href="https://github.com/marcin-chwedczuk/blog-problems-when-using-mockito-from-scala/">Click here.</a></p>

<p>References:</p>
<ul>
  <li><a href="https://medium.com/@bruno.bonanno/introduction-to-mockito-scala-ede30769cbda?">Intro to Mockito-Scala (Medium)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Binary to Gray algorithm explained</title>
	  <link>//binary-to-gray-algorithm-explained</link>
	  <author></author>
	  <pubDate>2019-12-17T01:00:01+01:00</pubDate>
	  <guid>//binary-to-gray-algorithm-explained</guid>
	  <description><![CDATA[
	     <p>Binary to Gray code conversion algorithm is deceptively simple:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/* This function converts an unsigned binary
 * number to reflected binary Gray code.
 *
 * The operator &gt;&gt; is shift right. The operator ^ is exclusive or.
 *
 * Source: https://en.wikipedia.org/wiki/Gray_code
 */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">binaryToGray</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">num</span> <span class="o">^</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>in this article I will explain how it works.</p>

<h4 id="gray-code">Gray code</h4>

<p>Gray code is a binary code in which two consecutive
values differ only by a single bit.
Three-bit Gray code, along its binary counterpart,
looks like this:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">|         BINARY|           GRAY|
|            000|            000|
|            001|            001|
|            010|            011|
|            011|            010|
|            100|            110|
|            101|            111|
|            110|            101|
|            111|            100|</code></pre></figure>

<p><code class="highlighter-rouge">N+1</code>-bit Gray code can be easily constructed
from <code class="highlighter-rouge">N</code>-bit Gray code using the following process:</p>

<p><img src="assets/images/2019-12-17/gn1.svg" alt="Making N+1-bit Gray code from N-bit Gray code" /></p>

<p>This variant of Gray code is often called reflected binary Gray code.
The “Vertical Flip” step is nothing else than creating
a mirror image of the code in vertical direction.</p>

<p>The above process, with the fact that <code class="highlighter-rouge">1</code>-bit Gray code
consists just of values <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>,
allows us to write a recursive algorithm for converting 
between corresponding binary and Gray code values.</p>

<h4 id="recursive-algorithm">Recursive algorithm</h4>

<p>We will define a function <code class="highlighter-rouge">G(nbits, n)</code> that returns
<code class="highlighter-rouge">n</code>th <code class="highlighter-rouge">nbits</code>-bit Gray code value.
<code class="highlighter-rouge">n</code> must be in range <code class="highlighter-rouge">0</code> .. <code class="highlighter-rouge">2**nbits - 1</code>
(where <code class="highlighter-rouge">**</code> means power).</p>

<p>For <code class="highlighter-rouge">nbits</code> equal to 1 this is trivial:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">func G(nbits, n) {
   if (nbits &lt;= 1) return n;
   ???
}</code></pre></figure>

<p>we return <code class="highlighter-rouge">0</code> when <code class="highlighter-rouge">n</code> is zero, and one when
<code class="highlighter-rouge">n</code> is one.</p>

<p>Next we need to translate the process from the first picture
into code:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">var msbBit = msb(nbits, n)

if (msbBit == 0) {
   return msbBit | G(nbits-1, n); 
}
else {
   // clear MSB bit
   var nWithoutMsb = n &amp; ~msbBit;
   var nonReflectedPos = pow(2, nbits-1)-1 - nWithoutMsb;

   return msbBit | G(nbits-1, nonReflectedPos)
}</code></pre></figure>

<p>Where <code class="highlighter-rouge">msb</code> is a simple function that returns
the <em>most significant bit</em> (MSB for short) of
an <code class="highlighter-rouge">nbits</code>-bit number <code class="highlighter-rouge">n</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">func msb(nbits, n) {
   return n &amp; (1 &lt;&lt; (nbits-1));
}</code></pre></figure>

<p>Similarly we will use LSB term to refer to
the <em>least significant bit</em> of a number.</p>

<p>There are two key observations that we must make to
understand how the algorithm works.
First observation is that binary values
share the same value of MSB bit with the corresponding
Gray code values.
<img src="assets/images/2019-12-17/g2.svg" alt="MSB and LSB in our algorithm" />
This is the result of the construction process,
that adds leading zeros to the upper half (blue) of the Gray code,
and leading ones to the lower half (red) of the code.</p>

<p>When <code class="highlighter-rouge">MSB = 0</code> we are in the upper half (blue) of the <code class="highlighter-rouge">nbits</code>-bit
Gray code, which was constructed from the <code class="highlighter-rouge">nbits-1</code>-bit Gray
code by adding extra <code class="highlighter-rouge">0</code> as a prefix to its values.
In this case we just call recursively <code class="highlighter-rouge">G(nbits-1, n)</code>
(<code class="highlighter-rouge">n</code> is in this case <code class="highlighter-rouge">&lt; 2**nbits/2 = 2**(nbits-1)</code>),
and add a <code class="highlighter-rouge">0</code> as a prefix to the result to
finish the conversion to <code class="highlighter-rouge">nbits</code>-bit code.</p>

<p>When <code class="highlighter-rouge">MSB = 1</code> we are in the lower half (red) of the code, that
was constructed by vertically flipping <code class="highlighter-rouge">nbits-1</code>-bit Gray
code and adding <code class="highlighter-rouge">1</code> as a prefix to its values.
<img src="assets/images/2019-12-17/g3.svg" alt="Relation between simple and reflected code" />
The second key observation here, is the relationship between
reflected <code class="highlighter-rouge">nbits-1</code>-bit Gray code and its non-reflected counterpart.
<code class="highlighter-rouge">nbits-1</code>-bit Gray value that is located
at <code class="highlighter-rouge">x</code>th position in the red (reflected)
area is exactly the same as 
<code class="highlighter-rouge">2**(nbits-1)-1 - x</code>th value located in the blue area.
To convert <code class="highlighter-rouge">n</code> into <code class="highlighter-rouge">nbits-1</code> Gray code, first
we remove <code class="highlighter-rouge">1</code> MSB bit from it, converting
it basically into our <code class="highlighter-rouge">x</code>
(zero-based offset from the beginning of the red area; see the picture above).
Then we compute position of <code class="highlighter-rouge">x</code>s counterpart in
the non-reflected (blue) area of the code, by using expression:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">var nonReflectedPos = pow(2, nbits-1)-1 - nWithoutMsb;</code></pre></figure>

<p>Then we call <code class="highlighter-rouge">G(nbits-1, nonReflectedPos)</code> to
compute <code class="highlighter-rouge">nbits-1</code>-bit Gray code value
and finally we restore <code class="highlighter-rouge">1</code> bit prefix to it.</p>

<p>The above algorithm expressed in Java:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">msb</span><span class="o">(</span><span class="kt">int</span> <span class="n">nbits</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">G</span><span class="o">(</span><span class="kt">int</span> <span class="n">nbits</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">nbits</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>

   <span class="kt">int</span> <span class="n">msbBit</span> <span class="o">=</span> <span class="n">msb</span><span class="o">(</span><span class="n">nbits</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">msbBit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// We can skip 'msbBit |' part because</span>
      <span class="c1">// '(0 | x) == x'</span>
      <span class="k">return</span> <span class="n">msbBit</span> <span class="o">|</span> <span class="n">G</span><span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">else</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">nWithoutMsb</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">msbBit</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">nonReflectedPos</span> <span class="o">=</span> 
         <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">)-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nWithoutMsb</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">msbBit</span> <span class="o">|</span> <span class="n">G</span><span class="o">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nonReflectedPos</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="using-strings-to-represent-binary-values">Using Strings to represent binary values</h4>

<p>To further improve our algorithm we need to change
our representation of binary values from 32-bit integers
to strings. For example a string <code class="highlighter-rouge">"110"</code> will represent
a <code class="highlighter-rouge">3</code>-bit binary value. We will also use empty string
<code class="highlighter-rouge">""</code> to represent a sole zero-bit binary value
(after all <code class="highlighter-rouge">2**0 = 1</code>, so there is one such value).</p>

<p>To proceed further, we need two simple facts.
Fact 1: Numbers in form <code class="highlighter-rouge">2**k - 1</code> are represented in
binary by sequence of <code class="highlighter-rouge">k</code> ones.
For example <code class="highlighter-rouge">2**3-1 = 7</code> is <code class="highlighter-rouge">111</code> in binary.</p>

<p>Fact 2: Substracting <code class="highlighter-rouge">k</code>-bit value <code class="highlighter-rouge">p</code> from <code class="highlighter-rouge">1...1</code> (<code class="highlighter-rouge">k</code> ones)
is equal to negating <code class="highlighter-rouge">p</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">  11111111
- 01010011
----------
  10101100</code></pre></figure>

<p>These both facts will allow us to rewrite
the expression for computing <code class="highlighter-rouge">nonReflectedPos</code> value from:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// n is a nbits-bit number
// nWithoutMsb is a (nbits-1)-bit number
// 2**(nbits-1)-1 = 1...1 (nbits-1 ones in binary)
int nonReflectedPos = 
   (int)Math.pow(2, nbits-1)-1 - nWithoutMsb;</code></pre></figure>

<p>to</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// Simple binary negation
String nonReflectedPos = not(nWithoutMsb);</code></pre></figure>

<p>Our previous algorithm changed to use strings
and expressed in JavaScript:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">not</span><span class="p">(</span><span class="nx">bits</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">bits</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span>
    <span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">==</span> <span class="s1">'0'</span> <span class="p">?</span> <span class="s1">'1'</span> <span class="p">:</span> <span class="s1">'0'</span><span class="p">;</span> <span class="p">}).</span>
    <span class="nx">join</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">G</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="s1">''</span><span class="p">)</span> <span class="k">return</span> <span class="s1">''</span><span class="p">;</span> <span class="c1">// zero bit code</span>
  
  <span class="kd">var</span> <span class="nx">firstBit</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">firstBit</span> <span class="o">==</span> <span class="s1">'0'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'0'</span> <span class="o">+</span> <span class="nx">G</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'1'</span> <span class="o">+</span> <span class="nx">G</span><span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h4 id="the-single-line-algorithm">The single-line algorithm</h4>

<p>If we now look at the code of our algorithm, we
may see that all it does is to negate the unseen part of the
input every time we encounter <code class="highlighter-rouge">1</code> bit:
<img src="assets/images/2019-12-17/g4.svg" alt="Workings of the string based algorithm" /></p>

<p>Let us consider how our algorithm will transform
groups of ones followed by a single zero bit (<code class="highlighter-rouge">11...110</code>):
<img src="assets/images/2019-12-17/g5.svg" alt="How groups of 11...110 are transformed" />
As we can see group of <code class="highlighter-rouge">11...110</code> bits is transformed into <code class="highlighter-rouge">10...01</code>,
but what is more important: bits that are after this group remain unchanged.
Similarly groups of ones without trailing zero (<code class="highlighter-rouge">1...1</code>),
which may only occur at the end of the input are transformed into <code class="highlighter-rouge">10...0</code>.</p>

<p>Now is the time for another key observation: the above
transformations can be performed by XORing value with
itself shifted right by one:</p>

<p><img src="assets/images/2019-12-17/g6.svg" alt="Transforming groups of ones using XOR" /></p>

<p>This works because after the shift every group of ones must
be preceded by at least a single zero bit. 
Additionally every group of ones
(except when the ones occur at the end of the input)
must be followed by at least one zero bit.
In other words different groups of ones are not interfering with
each other while XORing.</p>

<p>Also notice that we must use right-shift operation that always
shifts-in a zero bit.
In Java this means using <code class="highlighter-rouge">&gt;&gt;&gt;</code> (unsigned right shift) 
instead of <code class="highlighter-rouge">&gt;&gt;</code> operator.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">binaryToGray</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">^</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Source code (GitHub Gist): <a href="https://gist.github.com/marcin-chwedczuk/efc4df9fbc1928afcb0466e34b3d94c3">grayBin.js</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>Converting .dsl files to Kindle dictionaries</title>
	  <link>//converting-dsl-files-to-kindle-dictionary</link>
	  <author></author>
	  <pubDate>2019-12-02T01:00:01+01:00</pubDate>
	  <guid>//converting-dsl-files-to-kindle-dictionary</guid>
	  <description><![CDATA[
	     <p>In this post, I will describe how to convert dictionaries
in <a href="http://lingvo.helpmax.net/en/troubleshooting/dsl-compiler/dsl-dictionary-structure/">ABBYY Lingvo’s format</a>
to <code class="highlighter-rouge">mobi</code> dictionaries that can work with Kindle.</p>

<p>I will assume that you already have appropriate <code class="highlighter-rouge">.dsl</code> files.
The first step is to make sure that <code class="highlighter-rouge">.dsl</code> files use UTF-8 encoding.
We may check a file encoding using <code class="highlighter-rouge">file</code> command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>file dict.dsl 
dict.dsl: Little-endian UTF-16 Unicode text, with CRLF line terminators</code></pre></figure>

<p>If you see something different than <code class="highlighter-rouge">UTF-8 Unicode (with BOM)</code>,
as in the above example, then you have to convert the files to UTF-8
first. We may use <code class="highlighter-rouge">iconv</code> for this purpose:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">iconv <span class="nt">-f</span> UTF-16LE <span class="nt">-t</span> UTF-8 dict.dsl <span class="nt">-o</span> dict-utf8.dsl</code></pre></figure>

<p>We need to make sure that <code class="highlighter-rouge">.dsl</code> files does not
contain metadata info (lines starting with <code class="highlighter-rouge">#</code> at the
beginning of the file):</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">#NAME "Foo Dictionary"                                        
#INDEX_LANGUAGE "Russian"                                                
#CONTENTS_LANGUAGE  "Polish"                                             
а
...</code></pre></figure>

<p>If you see lines starting with <code class="highlighter-rouge">#</code> as in the above example, please
remove them.</p>

<p>Next we need to grab <code class="highlighter-rouge">dsl2mobi</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/Tvangeste/dsl2mobi.git

<span class="c"># Do I have ruby?</span>
ruby <span class="nt">-v</span>
<span class="nb">sudo </span>apt install ruby</code></pre></figure>

<p>You need to have <code class="highlighter-rouge">ruby</code> installed on your machine for the script
to work. Actually I don’t like running someone else’s code
on my machine, so I ran the script inside a virtual machine
(which, for security reasons, I also recommend you to do).</p>

<p>Now we can execute the script:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>dsl2mobi
chmod +x ./dsl2mobi.rb

./dsl2mobi.rb <span class="nt">-w</span> ./wordforms/forms-RU.txt <span class="se">\</span>
 <span class="nt">-i</span> ~/path-to/dict-utf8.dsl <span class="se">\</span>
 <span class="nt">-o</span> ~/output-dir</code></pre></figure>

<p>In a lot of languages, the same word can occur in 
different forms, for example 
in English the word “write” can occur in forms: wrote, written, writes.
We want our dictionary to recognize all these variations,
and for this reason we need the so called <em>wordforms</em>.
Fortunately for us <code class="highlighter-rouge">dsl2mobi</code> comes with a buildin
wordforms files for several languages.
If you want to create a dictionary from e.g. Russian to
Polish you need to use Russian wordforms (as in our example).
If you want to create a dictionary from English to Russian
you would need to use English wordforms, etc.</p>

<p><code class="highlighter-rouge">dsl2mobi</code> should create at least two files in the
<code class="highlighter-rouge">output-dir</code>, one with <code class="highlighter-rouge">.html</code> extension (containing
actual content) and one with <code class="highlighter-rouge">.opf</code>
extension (containing metadata).</p>

<p>Next we need to 
<a href="https://www.amazon.com/gp/feature.html?ie=UTF8&amp;docId=1000765211">grab KindleGen from Amazon</a>
to actually generate <code class="highlighter-rouge">mobi</code> files:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./kindlegen  ~/output-dir/dict.opf <span class="nt">-o</span> dict.mobi <span class="nt">-verbose</span> <span class="nt">-c2</span></code></pre></figure>

<p>We use <code class="highlighter-rouge">-c2</code> option to compress the dictionary.</p>

<p>Unfortunately, in my case <code class="highlighter-rouge">kindlegen</code> does not wanted to
convert <code class="highlighter-rouge">.opf</code> file generated by <code class="highlighter-rouge">dsl2mobi</code>.
To make it work, I needed to edit my <code class="highlighter-rouge">.opf</code> file to:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE package SYSTEM "oeb1.ent"&gt;</span>
<span class="nt">&lt;package</span> <span class="na">unique-identifier=</span><span class="s">"uid"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;metadata&gt;</span>
    <span class="nt">&lt;dc-metadata</span> <span class="na">xmlns:dc=</span><span class="s">"http://purl.org/metadata/dublin_core"</span> <span class="na">xmlns:oebpackage=</span><span class="s">"http://openebook.org/namespaces/oeb-package/1.0/"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;dc:Identifier</span> <span class="na">id=</span><span class="s">"uid"</span><span class="nt">&gt;</span>dic<span class="nt">&lt;/dc:Identifier&gt;</span>
      <span class="c">&lt;!-- Title of the document --&gt;</span>
      <span class="nt">&lt;dc:Title&gt;</span>Ru-Pl Dictionary<span class="nt">&lt;/dc:Title&gt;</span>
      <span class="nt">&lt;dc:Language&gt;</span>ru<span class="nt">&lt;/dc:Language&gt;</span>
      <span class="nt">&lt;dc:Subject</span> <span class="na">BASICCode=</span><span class="s">"REF008000"</span><span class="nt">&gt;</span>Dictionaries<span class="nt">&lt;/dc:Subject&gt;</span>
      <span class="nt">&lt;dc:Creator&gt;</span>linuxboy<span class="nt">&lt;/dc:Creator&gt;</span>
      <span class="nt">&lt;dc:Publisher&gt;</span>pinguin<span class="nt">&lt;/dc:Publisher&gt;</span>
      <span class="nt">&lt;dc:Description&gt;</span>Generated by Dsl2Mobi-1.2-dev on 2019-11-28.<span class="nt">&lt;/dc:Description&gt;</span>
    <span class="nt">&lt;/dc-metadata&gt;</span>
    <span class="nt">&lt;x-metadata&gt;</span>
      <span class="nt">&lt;output</span> <span class="na">encoding=</span><span class="s">"utf-8"</span> <span class="na">content-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;DictionaryInLanguage&gt;</span>ru<span class="nt">&lt;/DictionaryInLanguage&gt;</span>
      <span class="nt">&lt;DictionaryOutLanguage&gt;</span>pl<span class="nt">&lt;/DictionaryOutLanguage&gt;</span>
    <span class="nt">&lt;/x-metadata&gt;</span>
  <span class="nt">&lt;/metadata&gt;</span>

  <span class="c">&lt;!-- list of all the files needed to produce the .mobi file --&gt;</span>
  <span class="nt">&lt;manifest&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item1"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
  <span class="nt">&lt;/manifest&gt;</span>

  <span class="c">&lt;!-- list of the html files in the correct order  --&gt;</span>
  <span class="nt">&lt;spine&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/spine&gt;</span>

  <span class="nt">&lt;tours/&gt;</span>
  <span class="nt">&lt;guide&gt;</span>
   <span class="nt">&lt;reference</span> <span class="na">type=</span><span class="s">"toc"</span> <span class="na">title=</span><span class="s">"Table of Contents"</span> <span class="na">href=</span><span class="s">"dict.html#toc"</span><span class="nt">&gt;&lt;/reference&gt;</span>
  <span class="nt">&lt;/guide&gt;</span>
<span class="nt">&lt;/package&gt;</span></code></pre></figure>

<p>Also make that <code class="highlighter-rouge">DictionaryInLanguage</code> and <code class="highlighter-rouge">DictionaryOutLanguage</code>
tags have proper values, otherwise your dict may not work
on Kindle.</p>

<p>I also had to change the beginning of the <code class="highlighter-rouge">dict.html</code> file to:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:idx=</span><span class="s">"www.mobipocket.com"</span> <span class="na">xmlns:mbp=</span><span class="s">"www.mobipocket.com"</span> <span class="na">xmlns:xlink=</span><span class="s">"http://www.w3.org/1999/xlink"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"dic.css"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Type"</span> <span class="na">content=</span><span class="s">"text/html;charset=UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;center&gt;</span>
      <span class="nt">&lt;h1&gt;</span>Generated by Dsl2Mobi-1.2-dev<span class="nt">&lt;/h1&gt;</span>
      <span class="nt">&lt;hr</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/center&gt;</span>
    <span class="nt">&lt;mbp:pagebreak</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">name=</span><span class="s">"toc"</span><span class="nt">&gt;&lt;/a&gt;</span>
    <span class="nt">&lt;mbp:pagebreak</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- DICTIONARY ENTRIES --&gt;</span>
<span class="nt">&lt;a</span> <span class="na">name=</span><span class="s">"#а"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;idx:entry</span> <span class="na">name=</span><span class="s">"word"</span> <span class="na">scriptable=</span><span class="s">"yes"</span><span class="nt">&gt;</span>
<span class="nt">&lt;font</span> <span class="na">size=</span><span class="s">"6"</span> <span class="na">color=</span><span class="s">"#002984"</span><span class="nt">&gt;&lt;b&gt;&lt;idx:orth&gt;</span>а
<span class="nt">&lt;/idx:orth&gt;&lt;/b&gt;&lt;/font&gt;</span>
<span class="nt">&lt;idx:orth</span> <span class="na">value=</span><span class="s">"a"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"dsl_m0"</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">"dsl_p"</span><span class="nt">&gt;&lt;i&gt;&lt;font</span> <span class="na">color=</span><span class="s">"green"</span><span class="nt">&gt;</span>Spójnik<span class="nt">&lt;/font&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;</span>
...</code></pre></figure>

<p>After these changes I was able to generate a <code class="highlighter-rouge">.mobi</code> file that
worked perfectly with my Kindle.</p>

<p>If your dictionary is really huge (the <code class="highlighter-rouge">.html</code> file bigger than 20MB),
KindleGen may either take a lot of time (a few hours) or
it may not finish at all.
In this case I advice you to split, the single <code class="highlighter-rouge">.html</code> files
into three or four smaller files (each should be less than 20MB),
and then to add them as “chapters” to the <code class="highlighter-rouge">.opf</code> file:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml">  <span class="c">&lt;!-- list of all the files needed to produce the .mobi file --&gt;</span>
  <span class="nt">&lt;manifest&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item1"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-1.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item2"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-2.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item3"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-3.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">id=</span><span class="s">"item4"</span> <span class="na">media-type=</span><span class="s">"text/x-oeb1-document"</span> <span class="na">href=</span><span class="s">"dict-4.html"</span><span class="nt">&gt;&lt;/item&gt;</span>
  <span class="nt">&lt;/manifest&gt;</span>

  <span class="c">&lt;!-- list of the html files in the correct order  --&gt;</span>
  <span class="nt">&lt;spine&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;itemref</span> <span class="na">idref=</span><span class="s">"item4"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/spine&gt;</span></code></pre></figure>

<p>You can use <code class="highlighter-rouge">wc</code>, <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> for the splitting:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cat </span>dict.html | wc <span class="nt">-l</span>
1792747
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">$((</span><span class="m">1792747</span> <span class="o">/</span> <span class="m">2</span><span class="k">))</span>
896373
<span class="nv">$ </span><span class="nb">cat </span>dict.html | head <span class="nt">-n</span> 896373 <span class="o">&gt;</span> dict-1-2.html
<span class="nv">$ </span><span class="nb">cat </span>dict.html | tail <span class="nt">-n</span> +896373 <span class="o">&gt;</span> dict-3-4.html
<span class="c"># Split files one more time to have four parts</span></code></pre></figure>

<p>Then you have to use <code class="highlighter-rouge">vim</code> or other editor to make sure that
all files have proper <code class="highlighter-rouge">&lt;head&gt;</code> sections, and
are properly ended with <code class="highlighter-rouge">&lt;/body&gt;&lt;/html&gt;</code>.
You will also have to make sure that dictionary
entries are not split across the files.
They are quite easy to recognize, as they
usually start with <code class="highlighter-rouge">&lt;a&gt;</code> tag followed by <code class="highlighter-rouge">&lt;idx:entry&gt;</code> tag.</p>

<p>KindleGen needed around 1h of time to convert 80MB
split into four parts, so be prepared to wait for a bit.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Fun with AT commands and an old modem</title>
	  <link>//fun-with-at-commands-and-old-modem</link>
	  <author></author>
	  <pubDate>2019-09-21T02:00:01+02:00</pubDate>
	  <guid>//fun-with-at-commands-and-old-modem</guid>
	  <description><![CDATA[
	     <p>Recently, while cleaning my flat, I found an old Huawei E3131
USB modem. I planed to throw it away, but then I reminded myself
that this simple device, as virtually all modems, supports a
primitive text based interface known as “AT commands”.
And so I started thinking about
spending a few hours of my time
sending AT commands and figuring out what is actually
possible.
This post is the result of this few hours of hacking. Enjoy!</p>

<p>When I connected the modem to my PC it was immediately
recognized as both an USB Drive and an GSM modem.
Grepping through <code class="highlighter-rouge">dmesg</code> revealed that three serial port
terminals where created at <code class="highlighter-rouge">/dev/ttyUSB0</code>,
<code class="highlighter-rouge">/dev/ttyUSB1</code> and <code class="highlighter-rouge">/dev/ttyUSB2</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ dmesg | grep tty
[29167.640728] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB0
[29167.640808] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB1
[29167.640861] usb 3-9: GSM modem (1-port) converter now attached to ttyUSB2</code></pre></figure>

<p>To be honest I expected only a single <code class="highlighter-rouge">tty</code> file…</p>

<p>Running <code class="highlighter-rouge">stty</code> command on <code class="highlighter-rouge">ttyUSB0</code> returned
some useful information, including
<a href="https://en.wikipedia.org/wiki/Symbol_rate">baud rate</a>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">$ stty -F /dev/ttyUSB0
speed 9600 baud; line = 0;
eof = ^A; min = 1; time = 0;
-brkint -icrnl ixoff ixany -imaxbel
-opost -onlcr
-icanon -echo -echoe</code></pre></figure>

<p><code class="highlighter-rouge">-</code> before an option name means that this option is disabled.
Explanations for all options can be found in <code class="highlighter-rouge">man stty</code>.
For example <code class="highlighter-rouge">-echo</code> means that the characters that we
are writing, are not visible on the screen.
That is not very comfortable but can be changed easily
(you can try it yourself in bash by executing <code class="highlighter-rouge">stty -echo</code>
to disable
and <code class="highlighter-rouge">stty echo</code> to enable echo).</p>

<p>To connect to <code class="highlighter-rouge">ttyUSB0</code> I used <code class="highlighter-rouge">minicom</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt install minicom</code></pre></figure>

<p>We need to create a <code class="highlighter-rouge">minicom</code> configuration first.
For some reason <code class="highlighter-rouge">minicom</code> was not
able to save it’s config file in my home directory and
insisted on saving it into <code class="highlighter-rouge">/etc/minicom/</code> and so I
have to run it with <code class="highlighter-rouge">sudo</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>minicom <span class="nt">-s</span></code></pre></figure>

<p>Configuring <code class="highlighter-rouge">minicom</code> is like a journey to 80s,
entire UI is text based:
<img src="/assets/images/2019-09-23/mc-main-menu.png" alt="minicom main menu" />
First we need to go into “Serial port setup” section:
<img src="/assets/images/2019-09-23/mc-serial-port.png" alt="minicom serial port setting" />
and change “Serial Device” to <code class="highlighter-rouge">/dev/ttyUSB0</code> 
(to do this press A, change the field value and press either 
Enter to save or Escape to cancel).
Then we need to change baud rate (press E):
<img src="/assets/images/2019-09-23/mc-baud-rate.png" alt="minicom baud rate setting" />
On this screen press C and then Enter.
Next we need to go into “Screen and Keyboard” section and
enable echo (press Q) and then Enter:
<img src="/assets/images/2019-09-23/mc-scrn-kbd.png" alt="minicom screen and keyboard settings" />
We need to enable <em>local</em> echo (on the minicom side)
because, as <code class="highlighter-rouge">stty</code> indicated
the serial port itself does not support it.</p>

<p>Then we need to return to the main menu (press Enter)
and select “Save setup as…” option. I saved
my config under <code class="highlighter-rouge">huawei2</code> name. Then we should choose
“Exit from Minicom”. If you chose “Exit” use Ctrl+A
followed by X to exit.</p>

<p>Now we can start <code class="highlighter-rouge">minicom</code> without <code class="highlighter-rouge">sudo</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">minicom huawei2</code></pre></figure>

<p>and execute our first AT command which is just <code class="highlighter-rouge">AT</code>.
The modem should respons with <code class="highlighter-rouge">OK</code> if everything works:
<img src="/assets/images/2019-09-23/mc-w1.png" alt="minicom working" /></p>

<p>To find out what options are supported by my
modem, I googled for “huawei e3131 at command interface specification”
and found a PDF document describing supported AT commands.
By the way AT commands are 
<a href="https://en.wikipedia.org/wiki/De_facto_standard">de facto standard</a>
and could be used with any modem.</p>

<p>TIP: To exit <code class="highlighter-rouge">minicom</code> press Ctrl+A followed by X (must be upper case).</p>

<p>WARNING: In the following sections I assume that we
inserted a working SIM card into the modem.</p>

<h4 id="obtaining-information-from-the-modem">Obtaining information from the modem</h4>

<p>We can obtain a lot of information about our modem and
the SIM card just by running AT commands.
For example we may ask the modem for its phone number:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CNUM

+CNUM: "NUMER WLASNY","+48999123999",145

OK</code></pre></figure>

<p>(“NUMER WLASNY” is “MY OWN NUMBER” in Polish),
or for its IMEI number:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CGSN

865459999999999

OK</code></pre></figure>

<p>To read a modem flag or a setting we need to run a command
in <code class="highlighter-rouge">AT+CMD?</code> format.
For example to obtain the character set used by the modem
we send <code class="highlighter-rouge">AT+CSCS?</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS?

+CSCS: "IRA"

OK</code></pre></figure>

<p>To check what values are acceptable for this flag
we run a command in <code class="highlighter-rouge">AT+CMD=?</code> format:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS=?

+CSCS: ("IRA","UCS2","GSM")

OK</code></pre></figure>

<p>And to set flag/setting value we execute 
a command in <code class="highlighter-rouge">AT+CMD=value</code> format like <code class="highlighter-rouge">AT+CSCS="GSM"</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSCS="GSM"

OK
AT+CSCS?

+CSCS: "GSM"

OK</code></pre></figure>

<p>Network signal strength can be checked using <code class="highlighter-rouge">AT+CSQ</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CSQ

+CSQ: 23,99

OK</code></pre></figure>

<p>The response has format <code class="highlighter-rouge">+CSQ: signal-strength, error-rate</code>.
Signal strength varies from 31 (very good)
to 0 (very poor / lack of signal).
In my case bit error rate is not supported (99) by the modem.</p>

<p><code class="highlighter-rouge">AT+COPS</code> command allows us to check the
current network and to get a list of
the present networks:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+COPS?

+COPS: 0,0,"Plus",0

OK
AT+COPS=?

+COPS: (2,"Plus","PLUS","26001",0),
 (1,"Plus","PLUS","26001",2),
 (3,"T-Mobile PL","T-Mobile PL","26002",2),
 (3,"Orange PL","Orange","26003",2),
 //... OUTPUT TRUNCATED

OK</code></pre></figure>

<h4 id="sending-ussd-codes">Sending USSD codes</h4>

<p>USSD codes (short codes) like “*100#” are quite useful,
we can use them to check money amount on our account or
to change the current tariff.
Let’s see how to send them using AT commands.
First hurdle to overcome is 
the encoding used while sending an USSD code.
By default the codes must be encoded using
GSM7Bit encoding, which is not
related to 7-bit ASCII in any way.
I couldn’t find any online encoder/decoder for this
encoding, but fortunatelly
I found a pice of code that does exactly what we want:
<a href="https://github.com/bsimic0001/AegisWallet/blob/master/mobile/src/main/java/com/aegiswallet/utils/MessagingUtils.java">MessagingUtils.java</a>
And so I added a <code class="highlighter-rouge">main</code> method and pasted the code to 
<a href="https://www.compilejava.net/">www.compilejava.net</a>
to obtain an online converter. 
You can see the final, “paste ready” code
<a href="https://gist.github.com/marcin-chwedczuk/96f7f2a310ca416bed88a6dc10b7abc6">here</a>.</p>

<p>Encoding <code class="highlighter-rouge">*100#</code> in GSM7Bit gives us <code class="highlighter-rouge">AA180C3602</code>.
Now we may issue our USSD request using <code class="highlighter-rouge">AT+CUSD</code> command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">OK
AT+CUSD=1,"AA180C3602",15

OK

+CUSD: 0,"C135BD1E66BBF3A0393DEC06ADDF6E7A1844668741EE7ABB2CAF8368B85C2E97CBE572B91C48078AB160301094E97481966F37FD0DBA87F5EE3288FC0691DDE93048866BC1722D192C9603C5623A1A4D378301",15</code></pre></figure>

<p><code class="highlighter-rouge">1</code> (first value in the request) means that we want to see the response,
<code class="highlighter-rouge">15</code> (the last value) is the encoding type that we are using.</p>

<p>Next we need to use our GSM7Bit decoder to obtain plain
text from the network response (in Polish):</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">Aktualny stan konta dla numeru 48999999999 : 1,00 PLN.
Konto wazne do dnia 28-09-2019 11:44:30</code></pre></figure>

<h4 id="sending-and-receiving-sms">Sending and receiving SMS</h4>

<p>Our next step will be to send and to receive an SMS:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGF=1

OK
AT+CMGS="+48333666999"

&gt; Hello, world!
+CMGS: 7

OK</code></pre></figure>

<p>Before we send a message we must switch to the text mode,
which can be done by issuing <code class="highlighter-rouge">AT+CMGF=1</code> command.
The default mode is the PDU mode, which requires
creating and parsing PDU binary frames.</p>

<p>To send an SMS <code class="highlighter-rouge">AT+CMGS="phone-number"</code> command is used.
After executing <code class="highlighter-rouge">AT+CMGS</code>, a command prompt (<code class="highlighter-rouge">&gt;</code>) will
appear allowing us to write our message.
When we are done we press Ctrl+Z,
few seconds later the message will be delivered.</p>

<p>To list received and sent messages we can use <code class="highlighter-rouge">AT+CMGL</code>
command:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGL=?

+CMGL: ("REC UNREAD","REC READ","STO UNSENT","STO SENT","ALL")

OK
AT+CMGL="ALL"

+CMGL: 0,"REC READ","+48111222333",,"19/09/23,16:01:42+08"
 Pszczolka Maja

OK</code></pre></figure>

<p>Remember to run this command in the text mode (<code class="highlighter-rouge">AT+CMGF=1</code>),
otherwise you will see hex encoded binary PDU frames.</p>

<p>First value in the row is the message index (<code class="highlighter-rouge">0</code>).
We may use this index to either read the message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGR=0

+CMGR: "REC READ","+48111222333",,"19/09/23,16:13:03+08"
 Pszczolka Maja</code></pre></figure>

<p>or to remove it:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CMGD=0

OK
AT+CMGL="ALL"

OK</code></pre></figure>

<h4 id="playing-with-the-phone-book-entries">Playing with the phone book entries</h4>

<p><code class="highlighter-rouge">AT+CPBR</code> command can be used to read SIM card phone book entries:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBR=?

+CPBR: (1-250),40,20

OK
AT+CPBR=1,10

+CPBR: 1,"*110#",129,"Obsluga konta"
+CPBR: 2,"112",129,"Nr.alarmowy112"
+CPBR: 3,"999",129,"Pogotowie Rat."
+CPBR: 4,"997",129,"Policja"
+CPBR: 5,"998",129,"Straz pozarna"
+CPBR: 6,"+48601100100",145,"WOPR"
+CPBR: 7,"+48601100300",145,"GOPR/TOPR"
+CPBR: 8,"+48601102601",145,"Biuro obslugi"
+CPBR: 9,"5555",129,"Zasil konto"
+CPBR: 10,"*100#",129,"Stan konta"</code></pre></figure>

<p><code class="highlighter-rouge">AT+CPBR=?</code> returns supported range of indexes (<code class="highlighter-rouge">(1-250)</code>; some of them
may be empty), max. phone number length (<code class="highlighter-rouge">40</code>) and max.
entry name length (<code class="highlighter-rouge">20</code>).
Using this information we may read phone book entries using
<code class="highlighter-rouge">AT+CPBR=&lt;&lt;index-range&gt;&gt;</code> command.
When the phone number starts with <code class="highlighter-rouge">+</code> its type is <code class="highlighter-rouge">145</code>
otherwise its type is <code class="highlighter-rouge">129</code>.</p>

<p>Adding a phone book entry is very simple:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBW=25,"111222333",129,"foo"

OK
AT+CPBR=25

+CPBR: 25,"111222333",129,"foo"

OK</code></pre></figure>

<p>The same command can be used to remove a phone book entry:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">AT+CPBW=25

OK
AT+CPBR=25

+CME ERROR: 22</code></pre></figure>

<h4 id="ring-ring-ring">RING RING RING</h4>

<p>AT commands can also be used to make and receive phone calls.
Voice is send/received in WAVE format.
Unfortunately I cannot obtain even a simplest <code class="highlighter-rouge">RING</code> notification
from my modem.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Ultimate guide to Scala's match expression</title>
	  <link>//ultimate-guide-to-scalas-match-expression</link>
	  <author></author>
	  <pubDate>2019-09-19T02:00:01+02:00</pubDate>
	  <guid>//ultimate-guide-to-scalas-match-expression</guid>
	  <description><![CDATA[
	     <p>Scala <code class="highlighter-rouge">match</code> expression is a very powerful tool.
In hands of an experienced developer it can be used to
create concise and easy to understand code,
yet novice programmers are often intimidated by it.
In this blog post I will describe how <code class="highlighter-rouge">match</code> expression
work. We will start with the basics and finish with the extractors.
After reading this post you will know how <code class="highlighter-rouge">case List(a, b, c)</code>
works and you will be able to write your own extractors.</p>

<h4 id="pattern-matching-values">Pattern matching values</h4>

<p><code class="highlighter-rouge">match</code> expression can be used (just like Java’s <code class="highlighter-rouge">switch</code>)
as a more robust <code class="highlighter-rouge">if</code> statement replacement.
For example we can write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">command</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">fetchNextCommand</span><span class="o">()</span>

<span class="n">command</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"ls"</span> <span class="k">=&gt;</span> <span class="n">printDirectoryContents</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"ps"</span> <span class="k">=&gt;</span> <span class="n">printProcesses</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"exit"</span> <span class="k">=&gt;</span> <span class="n">exitShell</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> expression, in opposite to Java’s <code class="highlighter-rouge">switch</code> is not
limited to strings, Enums and numeric types, but can also match
booleans, floating point numbers (although this isn’t a good idea)
and <code class="highlighter-rouge">null</code> literal.
We can also mix multiple value types in a single <code class="highlighter-rouge">match</code>
expression:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mf">3.1415</span>

<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's true"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"integer 3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mf">3.1415</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pi approximation"</span><span class="o">)</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"null"</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">"foo"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"this 'foo' again!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="sc">'a'</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"character 'a'"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">pi</span> <span class="n">approximation</span></code></pre></figure>

<p>When we match an Enum value we are not required to
provide cases for all possible values of the Enum:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Color</span> <span class="o">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">White</span><span class="o">,</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Black</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">skyColor</span> <span class="k">=</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span>

<span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">weatherWildGuess</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">rain</span><span class="o">?</span></code></pre></figure>

<p>When a value cannot be pattern matched
a <code class="highlighter-rouge">scala.MatchError</code> runtime exception is thrown.
A special “catch all” case can be
provided to handle all previously unmatched values 
(Scala’s <code class="highlighter-rouge">case _</code> is a counterpart to Java’s <code class="highlighter-rouge">switch</code> <code class="highlighter-rouge">default</code> label):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"I don't know"</span>
<span class="o">}</span></code></pre></figure>

<p>“catch all” case should be the last one. 
Patterns are matched from top to bottom and the procedure
stops on the first matching <code class="highlighter-rouge">case</code> clause.</p>

<p>Sometimes we want to access the value matched by “catch all” case,
this can be done by replacing wildcard pattern (<code class="highlighter-rouge">_</code>)
with a variable name:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="n">unknownColor</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">"Cannot guess weather for sky color: $unknownColor"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Often it is required to execute the same code for multiple values.
With <code class="highlighter-rouge">match</code> this can be done using <code class="highlighter-rouge">|</code> (pipe) operator:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">answer</span><span class="o">.</span><span class="n">toLowerCase</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"y"</span> <span class="o">|</span> <span class="s">"yes"</span> <span class="o">|</span> <span class="s">"ok"</span> <span class="o">|</span> <span class="s">"proceed"</span> <span class="k">=&gt;</span>
    <span class="n">executeOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"n"</span> <span class="o">|</span> <span class="s">"no"</span> <span class="o">|</span> <span class="s">"abort"</span> <span class="k">=&gt;</span>
    <span class="n">abortOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">askAgain</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> can also be used to match against <code class="highlighter-rouge">null</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">nullableValue</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> 

<span class="k">val</span> <span class="n">option</span> <span class="k">=</span> <span class="n">nullableValue</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Matching against Double <code class="highlighter-rouge">NaN</code> value is more problematic, since
<code class="highlighter-rouge">NaN == NaN</code> must always return <code class="highlighter-rouge">false</code> according to IEEE 754
Standard. To match against <code class="highlighter-rouge">NaN</code> we need to use a pattern guard:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span> <span class="k">=&gt;</span> <span class="s">"+∞"</span>

  <span class="c1">// WRONG way to match NaN
</span>  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">=&gt;</span> <span class="s">"this does not work"</span>
  <span class="c1">// RIGHT way to match NaN
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isNaN</span> <span class="k">=&gt;</span> <span class="s">"NaN"</span>

  <span class="c1">// catch-all
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span></code></pre></figure>

<p>We will return to pattern guards later.</p>

<h4 id="pattern-matching-class-instances">Pattern matching class instances</h4>

<p>Besides pattern matching primitive types, <code class="highlighter-rouge">match</code> can also be used
to compare normal class instances.
For this to work, a matched class must provide a sensible
override for <code class="highlighter-rouge">equals</code> and <code class="highlighter-rouge">hashCode</code> methods.</p>

<p>Before we’ll see an example, we need to learn about
a certain pitfall of Scala, illustrated by the following code:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NotEqualToAnything</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>

<span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="c1">// false
</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">y</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
// false
</span><span class="o">//</span> <span class="nc">Whaaaaa</span><span class="o">!</span> <span class="nc">What</span> <span class="n">has</span> <span class="n">just</span> <span class="n">happened</span><span class="o">?</span></code></pre></figure>

<p>Why was <code class="highlighter-rouge">x</code> matched with <code class="highlighter-rouge">case y</code> despite <code class="highlighter-rouge">x.equals(y)</code> returning <code class="highlighter-rouge">false</code>?
Because the <code class="highlighter-rouge">y</code> in <code class="highlighter-rouge">case y</code> is a new variable introduced by “catch-all” clause 
to keep the matched value. It’s the same construct that we used
earlier to catch unknown colors (<code class="highlighter-rouge">case unknownColor</code>).
To tell Scala compiler that we want to use the value kept in
a variable instead of introducing a new one,
we just need to quote variable name using <code>&#96;</code> character:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`y`</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"no-match"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Returning to the instances matching, here is a working example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">JustInt</span><span class="o">(</span><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// hashCode() omitted for brevity
</span>  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">other</span><span class="k">:</span> <span class="kt">JustInt</span> <span class="o">=&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="n">n</span>
      <span class="k">case</span> <span class="k">_</span>              <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">j2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j4</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="k">val</span> <span class="n">just3</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">just3</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`j2`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 2!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j3`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 3!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j4`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 4!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">just</span> <span class="mi">3</span><span class="o">!</span></code></pre></figure>

<p>One more example before we move on. When we attempt to
match singleton objects we do not need to use <code>&#96;</code> escaping:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">X</span> <span class="o">{</span> <span class="o">}</span>
<span class="k">object</span> <span class="nc">Y</span> <span class="o">{</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">X</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">Y</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's Y!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">X</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's X!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">it</span><span class="ss">'s </span><span class="n">X</span><span class="o">!</span></code></pre></figure>

<p><code class="highlighter-rouge">case X</code> will work just fine!</p>

<h4 id="pattern-matching-types">Pattern matching types</h4>

<p>Besides matching values, <code class="highlighter-rouge">match</code> can also perform <code class="highlighter-rouge">instanceof</code> tests:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">something</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">()</span>

<span class="n">something</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"a string!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"an int!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.Random</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"A Random instance!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"type unknown!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>As usual on JVM <code class="highlighter-rouge">instanceof</code> tests will not work with
parametrized types 
(while <code class="highlighter-rouge">class List&lt;T&gt;</code> is a generic type, 
<code class="highlighter-rouge">List&lt;T&gt;</code> usage like <code class="highlighter-rouge">List&lt;String&gt;</code> is
called a parametrized type). 
<a href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">Type erasure</a>
is here to blame:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// DO NOT WORK
</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"string list"</span> <span class="c1">// unreachable code warning
</span>  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"int list"</span> <span class="c1">// unreachable code warning
</span><span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">string</span> <span class="n">list</span> <span class="o">(</span><span class="n">sic</span><span class="o">!)</span></code></pre></figure>

<p>But not all is lost, we can still preform type tests
on generic types using wildcards (Scala <code class="highlighter-rouge">_</code> is a conterpart of Java <code class="highlighter-rouge">?</code>,
consider Scala’s <code class="highlighter-rouge">List[_]</code> and Java’s <code class="highlighter-rouge">List&lt;?&gt;</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a map"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a list"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a java's list"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">a</span> <span class="n">list</span></code></pre></figure>

<p>So far we where not interested in the actual value of the variable,
but only in it’s type and so we just discarded the value using <code class="highlighter-rouge">case _: Type</code>
clause.
But nothing prevents us from assigning the already type checked
value to a variable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">map</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="n">jlist</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">jlist</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span></code></pre></figure>

<p>Every <code class="highlighter-rouge">case</code> clause creates it’s own lexical scope.
This means that we can reuse variable names across different <code class="highlighter-rouge">case</code>es:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">10</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>

  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>
<span class="o">}</span></code></pre></figure>

<p>Pipe operator can be used with type checks too, but the
resulting code isn’t very readable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"a number!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>If we want to use the value matched by this
pattern we need to use a pattern binder:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">num</span><span class="o">@(</span><span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">].</span><span class="n">doubleValue</span><span class="o">())</span>
<span class="o">}</span></code></pre></figure>

<p>Pattern binders allow us to assign a value
that matches a <em>subpattern</em> to a variable.
In the extreme case this <em>subpattern</em> can be the entire
pattern, as it is in our case. We will return to
the pattern binders later.</p>

<h4 id="pattern-matching-tuples">Pattern matching tuples</h4>

<p>Pattern matching on tuples is supported out of the box.
We can match on tuple elements using all previously
described matchers. We can ignore a tuple element
by using “match all” wildcard (<code class="highlighter-rouge">_</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// unpacking tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// ignoring certain elements
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// matching values of the tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$e"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// matching types of the tuple
</span><span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="mf">1.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="kc">true</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$s $n $b"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p>We can also match nested tuple structures:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">))</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// and with other constraints:
</span><span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<h4 id="pattern-guards">Pattern guards</h4>

<p>When pattern matching values, we often need to preform
some additional checks e.g. say we want to match all odd
or even integers. We can use pattern guards for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Since pattern guards use predicates (expressions that
return either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>) they are very flexible.
We can express both value and type checks using only
pattern guards:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">"foo"</span> <span class="k">=&gt;</span>
    <span class="s">"it's this 'foo' again!"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">=&gt;</span>
    <span class="s">"it's three!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="s">"foo"</span>
<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"it's a string: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The problem with pattern guards is that they are
imperative. We should try to avoid them
as much as possible. Later we will learn about
extractors, that roughly speaking do the same
job as guards but in a more declarative way.</p>

<h4 id="extractors">Extractors</h4>

<p>Extractors are pattern guards on steroids.
They allow us to build highly readable DSLs and provide
a functional way to match, extract and transform program data.</p>

<p>The simplest extractor return just a <code class="highlighter-rouge">Boolean</code> value and
can be used as a pattern guard replacement:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Odd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Even</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Odd</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Even</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Generally speaking extractor is just a value with <code class="highlighter-rouge">unapply</code> method.
In the last example we used <code class="highlighter-rouge">object</code>s but extractor can also be kept in variables:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">multipleOf2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">multipleOf5</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m5</span> <span class="k">@</span> <span class="n">multipleOf5</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m5 is multiple of 5"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">m2</span> <span class="k">@</span> <span class="n">multipleOf2</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m2 is multiple of 2"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Here we also used pattern binders to name the values that where matched
by <code class="highlighter-rouge">multipleOf</code> extractors.</p>

<p>Unfortunately in the current version of Scala we cannot create parametrized
extractors. In other words we cannot create a universal <code class="highlighter-rouge">multipleOf(n)</code> extractor.
This also means that pattern guards are not 100% replaceable by extractors.</p>

<p>As the name suggest, the extractors main purpose is to extract the
data from matched values.
Our next extractor will extract non-null values from nullable reference:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NonNull</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">arg</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">string</span> <span class="k">&lt;-</span> <span class="n">strings</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">string</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">NonNull</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"placeholder"</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">foo</span> <span class="n">placeholder</span> <span class="n">bar</span> <span class="n">placeholder</span></code></pre></figure>

<p><code class="highlighter-rouge">unapply</code> method can be generic, and should return <code class="highlighter-rouge">Some(value)</code> in
case of match and <code class="highlighter-rouge">None</code> when there is not match.</p>

<p>But extractors are not limited to returning only a single value.
In our next example we will learn how to extract <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> from
<code class="highlighter-rouge">java.util.List[E]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>

<span class="k">object</span> <span class="nc">JList</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">E</span>, <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">None</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">head</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">subList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="o">())</span>
      <span class="nc">Some</span><span class="o">((</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collections</span><span class="o">.</span><span class="n">emptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">](),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>To return multiple values from the extractor we just need to return a
tuple instead of a single value wrapped in <code class="highlighter-rouge">Option[A]</code>.</p>

<p>Extractors can be nested, this is a really powerful feature.
Given our previous <code class="highlighter-rouge">JList</code> extractor we can extract not only
the first element but any finite number of elements from the beginning of a list:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)))</span> <span class="k">=&gt;</span>
	 <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>To understand how this pattern works it’s helpful to look at the equivalent
for comprehension:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">tmp1</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="n">tmp2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp2</span><span class="o">)</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>When we extract multiple values, sometimes we want to
ignore some of them.
We can use <code class="highlighter-rouge">_</code> wildcard, that matches any value, for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>We can also use pattern binders to assign names to
subpatterns, for example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>Matching Java’s <code class="highlighter-rouge">List[E]</code> using nested patterns is not
very comfortable. 
In reality we prefer a syntax like <code class="highlighter-rouge">case JList(e1, e2, e3)</code>.
Fortunately this can be done in Scala using extractors that return <code class="highlighter-rouge">Option[Seq[E]]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">JList2</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">scala.jdk.CollectionConverters._</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSeq</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 3 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 2 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"4 elements: $a, $b, $c, $d"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that we used <code class="highlighter-rouge">unapplySeq</code> instead of <code class="highlighter-rouge">unapply</code>.</p>

<p>With <code class="highlighter-rouge">Seq</code> extractor we can match “tail” of
the list using <code class="highlighter-rouge">_*</code> pattern:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head $head, tail $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The last thing that may come handy is the ability to write
extractor expression using either call notation <code class="highlighter-rouge">JList2(head, tail)</code>
or using operator notation <code class="highlighter-rouge">head JList2 tail</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">head</span> <span class="nc">JList</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is mostly useful when we want to provide “operator like” experience
for the programmers. For example when we want to match
<code class="highlighter-rouge">List</code>s using <code class="highlighter-rouge">e1 :: e2 :: tail</code> expression.</p>

<h4 id="scala-buildin-extractors">Scala buildin extractors</h4>

<p>Let’s finish this post with a tour of Scala buildin extractors.</p>

<h5 id="case-classes">Case classes</h5>

<p>When you declare a case class in Scala:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
                 <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span></code></pre></figure>

<p>compiler, among other things, adds appropriate
<code class="highlighter-rouge">apply</code> and <code class="highlighter-rouge">unapply</code> methods to the case class companion object.
Thanks to this, pattern matching works with case classes out of the box:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">line</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Line</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">fy</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="n">tx</span><span class="o">,</span> <span class="n">ty</span><span class="o">),</span> <span class="n">color</span><span class="nd">@_</span><span class="o">)</span> <span class="k">=&gt;</span> 
    <span class="n">s</span><span class="s">"line(($fx,$fy) -&gt; ($tx,$ty))"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> 
    <span class="s">"fail"</span>
<span class="o">}</span></code></pre></figure>

<h5 id="list">List</h5>

<p>Scala <code class="highlighter-rouge">List</code> implements a singly linked list.
<code class="highlighter-rouge">case object Nil</code> is used to represent an empty list.
As a singleton object, <code class="highlighter-rouge">Nil</code> is matched by <code class="highlighter-rouge">case Nil</code> clause.
<code class="highlighter-rouge">case class ::</code> is used as a linked list node, it contains
two fields <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">next</code>. Both <code class="highlighter-rouge">Nil</code> and <code class="highlighter-rouge">::</code>
extend abstract class <code class="highlighter-rouge">List[E]</code>.
Because name of the <code class="highlighter-rouge">case class ::</code> ends in a <code class="highlighter-rouge">:</code> (colon),
<code class="highlighter-rouge">::</code> when used as an operator is right associative:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="o">==</span> <span class="o">::(</span><span class="mi">1</span><span class="o">,</span> <span class="o">::(</span><span class="mi">2</span><span class="o">,</span> <span class="o">::(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span></code></pre></figure>

<p>After this overly simplistic explanation on how <code class="highlighter-rouge">List[E]</code> works, we
should now understand how pattern matching
works with lists:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"single element list $head"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">e1</span> <span class="o">::</span> <span class="n">e2</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list $e1 $e2"</span><span class="o">)</span>
      
    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// single element list 1
// two element list 1 2
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>For programmers convenience <code class="highlighter-rouge">unapplySeq</code> is also
provided on <code class="highlighter-rouge">List</code> singleton object. It works very similar to 
our <code class="highlighter-rouge">JList</code> extractor:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list: [$first, $second]"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// head: 1, tail: List()
// two element list: [1, 2]
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>It is a good exercise to create our own <code class="highlighter-rouge">List[E]</code> implementation
with all pattern matching facilities that standard <code class="highlighter-rouge">List[E]</code> provides.</p>

<h5 id="regexes">Regexes</h5>

<p>Scala <code class="highlighter-rouge">Regex</code> class provides <code class="highlighter-rouge">unapplySeq</code> extractor.
When a regex matches an input, the extractor will return
values for all matching groups within the regex.
You can create a group within a regex by using parentheses,
for example regex <code class="highlighter-rouge">(\d{3})-(\d{5})</code> has two groups
<code class="highlighter-rouge">\d{3}</code> and <code class="highlighter-rouge">\d{5}</code>. If you want to use parentheses
but do not wish to create a group, you just need to put
<code class="highlighter-rouge">?:</code> after starting <code class="highlighter-rouge">(</code> like in <code class="highlighter-rouge">(?:\d{3})?</code>.
If you want to learn more about regular expressions
you should check out <em>Mastering Regular Expressions</em> book by Jeffrey Friedl.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">phoneNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="s">"+48 123-123-123"</span><span class="o">,</span>
  <span class="s">"123-123-123"</span><span class="o">,</span>
  <span class="s">"123123123"</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">plPhoneNumber</span> <span class="k">=</span> <span class="s">"^(?:\\+(\\d{2})\\s)?(\\d{3}-\\d{3}-\\d{3})$"</span><span class="o">.</span><span class="n">r</span>
<span class="k">for</span> <span class="o">(</span><span class="n">phoneNo</span> <span class="k">&lt;-</span> <span class="n">phoneNumbers</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">phoneNo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">plPhoneNumber</span><span class="o">(</span><span class="n">countryPrefix</span><span class="o">,</span> <span class="n">phoneNo</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"countryPrefix: $countryPrefix, phoneNo: $phoneNo"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"no match"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// countryPrefix: 48, phoneNo: 123-123-123
// countryPrefix: null, phoneNo: 123-123-123
</span><span class="o">//</span> <span class="n">no</span> <span class="k">match</span></code></pre></figure>

<p>In practice regex extractors are rarely used with <code class="highlighter-rouge">match</code> expression.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Floating point numbers and Unit Testing</title>
	  <link>//doubles-and-unit-testing</link>
	  <author></author>
	  <pubDate>2019-09-18T02:00:01+02:00</pubDate>
	  <guid>//doubles-and-unit-testing</guid>
	  <description><![CDATA[
	     <p>Floating point numbers are inherently imprecise.
This can be problematic when we try to unit test
numerical algorithms.
Let’s see this on an example
(JVM/Scala, ScalaTest used as a testing framework):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span><span class="o">*</span><span class="n">d</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>This test works just fine… until someone decides to
do a “harmless refactoring” and replaces <code class="highlighter-rouge">d*d</code> by <code class="highlighter-rouge">Math.pow(d, 2)</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Now the test fails with the following message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">0.38052927966064654 was not equal to 0.3805292796606466</code></pre></figure>

<p>The expected and the actual values differ by ~5.6E-17.
Doubles offer precision of about 15 significant digits in a result.
All the other digits after 15th digit are just noise that should be
ignored.</p>

<p>To make our unit-test more robust we have two strategies.
The first strategy is to know the precision that is guaranteed by the algorithm
that we are using, and to round the result to that
precision before returning it to the client:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d2</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
    <span class="c1">// Precision from org.apache.commons:commons-math3:3.6.1
</span>    <span class="k">return</span> <span class="nc">Precision</span><span class="o">.</span><span class="n">round</span><span class="o">(</span><span class="n">d2</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
<span class="o">}</span>

<span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.38052928</span><span class="o">)</span> <span class="c1">// rounded
</span><span class="o">}</span></code></pre></figure>

<p>The second strategy is to use assertions intended to work
with floating point numbers. Again to use them correctly we need to
be aware of the precision of our algorithm:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"squaring should work"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="mf">0.6168705534069904</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span><span class="o">*</span><span class="n">d</span>

    <span class="n">result</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mf">0.3805292796606466</span> <span class="o">+-</span> <span class="mf">0.000000005</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>In this case it is good to define the precision
as a global constant (or as a constant per algorithm).</p>

<p>Personally I prefer the first strategy, but with
either of them our tests will be more robust and
refactoring-friendly.</p>

<h4 id="troubles-with-nan">Troubles with NaN</h4>

<p>Totally different set of problems are connected to <code class="highlighter-rouge">NaN</code> values.
On JVM operator <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">equals</code> behave 
inconsistently when comparing <code class="highlighter-rouge">NaN</code>s:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"Jvm's Double"</span> <span class="n">should</span> <span class="o">{</span>
    <span class="s">"follow JVM spec"</span> <span class="n">in</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>

        <span class="c1">// Required by IEEE 754 Standard
</span>        <span class="o">(</span><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span><span class="o">)</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>

        <span class="c1">// Required by JVM Object#equals contract:
</span>        <span class="c1">// "for any non-null reference value x,
</span>        <span class="c1">//  x.equals(x) should return true"
</span>        <span class="n">nan</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">nan</span><span class="o">)</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Unit testing frameworks often do not help here much.
For example the following test:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"how to check that a value is NaN?"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>
    <span class="n">nan</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="n">nan</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>will fail with a rather unhelpful message:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">NaN was not equal to NaN</code></pre></figure>

<p>According to ScalaTest guidelines we should use <code class="highlighter-rouge">Double#isNaN</code>
to check if a value is <code class="highlighter-rouge">NaN</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"how to check that a value is NaN?"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">;</span>
    <span class="n">nan</span><span class="o">.</span><span class="n">isNaN</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>We experience similar troubles when we try to
compare case classes containing double fields with <code class="highlighter-rouge">NaN</code> values:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">CaseClass</span><span class="o">(</span><span class="n">d1</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
                     <span class="n">d2</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>

<span class="c1">// In test code:
</span><span class="k">val</span> <span class="n">inf</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span>
<span class="k">val</span> <span class="n">nan</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>
<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">+</span><span class="mf">0.0</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.0</span><span class="o">))</span>
<span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">inf</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">inf</span><span class="o">))</span>

<span class="c1">// fails: CaseData(1.0,NaN) was not equal to CaseData(1.0,NaN)
</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">nan</span><span class="o">)</span> <span class="n">shouldBe</span><span class="o">(</span><span class="nc">CaseClass</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">nan</span><span class="o">))</span></code></pre></figure>

<p>I do not have a good solution for this problem.
We can either create a custom assertion for a given case class ourselves,
define a custom equality using 
<a href="http://www.scalactic.org/user_guide/CustomEquality">Scalactic</a>
or we can use <code class="highlighter-rouge">Option[Double]</code> and
somehow map <code class="highlighter-rouge">NaN</code>s to <code class="highlighter-rouge">Option</code>s <code class="highlighter-rouge">None</code>.
None of the solutions is great.</p>

<p>The last thing to remember is that we cannot <code class="highlighter-rouge">match</code> <code class="highlighter-rouge">NaN</code> values:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="c1">// will fail
</span><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">=&gt;</span> <span class="n">doStuff</span><span class="o">()</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fail</span><span class="o">(</span><span class="s">"NaN not matched!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// how to do it properly
</span><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">value</span><span class="nd">@_</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isNaN</span> <span class="k">=&gt;</span> <span class="n">doStuff</span><span class="o">()</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fail</span><span class="o">(</span><span class="s">"NaN not matched!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>


	  ]]></description>
	</item>


</channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>marcin-chwedczuk.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>A place where I share my thoughts about programming.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Cierpienia młodego Wertera czyli algorytm alfa-beta dla gry kółko i krzyżyk</title>
	  <link>//cierpienia-mlodego-wertera</link>
	  <author></author>
	  <pubDate>2020-08-06T02:00:01+02:00</pubDate>
	  <guid>//cierpienia-mlodego-wertera</guid>
	  <description><![CDATA[
	     <p>W tym wpisie przyjrzymy się trudnościom które występują podczas
implementacji algorytmu alfa-beta dla gry kółko i krzyżyk.
Nie będę tutaj omawiał samego algorytmu, gdyż został on już dobrze
opisany w wielu innych miejscach, między innymi na
<a href="http://wazniak.mimuw.edu.pl/index.php?title=Sztuczna_inteligencja/SI_Modu%C5%82_8_-_Gry_dwuosobowe">Ważniaku</a>.
Zamiast tego skoncentrujemy się na technikach debugowania które można
będzie wykorzystać również przy innych grach np. warcabach.</p>

<p>Kod algorytmów alfa-beta i minimax jest powszechnie dostępny
w internecie czy to w postaci 
<a href="https://en.wikipedia.org/wiki/Alpha–beta_pruning#Pseudocode">pseudokodu</a>
czy jako gotowa implementacja na <a href="https://github.com/search?l=Java&amp;q=alpha+beta+tictactoe&amp;type=Repositories">GitHubie</a>.</p>

<p>W trakcie przygotowań do stworzenia tego artykułu, ja również napisałem 
prostą implementację gry w kółko i krzyżyk. 
Kod mojej wersji algorytmu alfa-beta, podobnie jak cała gra, dostępny jest na 
<a href="https://github.com/marcin-chwedczuk/xox/blob/master/src/main/java/pl/marcinchwedczuk/xox/game/AlphaBetaAlgo.java">GitHubie</a>.</p>

<p>W dalszej części artykułu założymy że posiadana przez nas 
implementacja algorytmu alfa-beta jest poprawna, 
a mimo to program nie wykonuje prawidłowych ruchów podczas gry.</p>

<h3 id="heurystyka-czyli-serce-algorytmu">Heurystyka czyli Serce algorytmu</h3>

<p>Najważniejszą częścią algorytmu alfa-beta jest heurystyka czyli
funkcja oceniająca stan gry z punktu widzenia danego gracza.
Ogólna sygnatura heurystyki wygląda następująco:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">double</span> <span class="nf">score</span><span class="o">(</span><span class="n">GameState</span> <span class="n">gameState</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span></code></pre></figure>

<p>Większe wartości zwracane przez funkcję odpowiadają lepszej
sytuacji gracza na planszy i na odwrót im mniejsza wartość
zwrócona tym położenie gracza jest gorsze.</p>

<p>Czasami przekazujemy do heurystyki również
inne pomocnicze informacje,
na przykład ostatni wykonany przez gracza ruch, jeżeli może to
przyspieszyć wykonywanie obliczeń.
Sama funkcja może również zwracać więcej danych niż tylko samą ocenę sytuacji na polu gry.
Przykładowo heurystyka może zwracać informację o zakończeniu gry i jej ewentualnym zwycięscy.
Wiele zależy tutaj od konkretnej gry, w przypadku gry w kółko i krzyżyk
obie te optymalizacje są możliwe.</p>

<p>W przypadku planszy 3x3 prosta heurystyka która zwraca <code class="highlighter-rouge">1</code> gdy gracz
wygrał i <code class="highlighter-rouge">0</code> w przeciwnym wypadku, w połączeniu z algorytmem alfa-beta
tworzy program z którym nie sposób wygrać.</p>

<p>Na koniec uwaga techniczna. Nakreślona powyżej funkcja heurystyki
traktuje w taki sam sposób zarówno gracza MAX
jak i gracza MIN. Dla poprawności działania algorytmu alfa-beta
konieczne jest zanegowanie wyniku zwróconego przez heurystykę dla
gracza MIN:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">currentPlayer</span><span class="o">);</span>
<span class="n">score</span> <span class="o">=</span> <span class="n">maximizingPlayer</span> <span class="o">?</span> <span class="n">score</span> <span class="o">:</span> <span class="o">-</span><span class="n">score</span><span class="o">;</span></code></pre></figure>

<h3 id="plansza-4x4-3-pod-rząd-wygrywają">Plansza 4x4, 3 pod rząd wygrywają</h3>

<p>Uruchomienie powyższego algorytmu na planszy 4x4, gdy pierwszy ruch
należy do użytkownika przynosi jednak opłakane rezultaty.
Program zajmuje po prostu kolejne pola na planszy, a my nie mamy
najmniejszego problemu z wygraną.</p>

<p><img src="assets/images/2020-08-05/game1.png" alt="Dziwne zachowanie algorytmu" />
X - Użytkownik, O - Komputer</p>

<p>Dlaczego tak się dzieje? Okazuje się że przy grze 4x4, 3 pod rząd
istnieje strategia wygrywająca która pozwala pierwszemu graczowi
wygrać w dokładnie 3 ruchach:
<img src="assets/images/2020-08-05/str1.svg" alt="Strategia wygrywająca" /></p>

<p>Z punktu widzenia algorytmu minimax każdy ruch skutkuje przegraną,
dlatego algorytm wybierze pierwszy lub ostatni ruch 
(w zależności od implementacji).
Pozwolę sobie nazwać to zjawisko depresją,
chociaż nie jest to powszechnie przyjęta terminologia.</p>

<p>Istnieje bardzo prosty sposób na wykrycie zjawiska depresji -
wystarczy zamienić kolejność graczy tj. pozwolić komputerowi wykonać
pierwszy ruch. Jeżeli spowoduje to nagłą poprawę sposobu działania algorytmu
należy sprawdzić czy przypadkiem gra nie faworyzuje gracza wykonującego
ruch jako pierwszy.</p>

<p>Istnieje jeszcze jedno proste ulepszenie które możemy wykonać.
Mianowicie jeżeli pozwolimy algorytmowi grać samemu ze sobą to
okaże się że “nie spieszy mu się do wygranej”:
<img src="assets/images/2020-08-05/str2.svg" alt="Ilustracja problemu" />
Ludzie zachowują się inaczej, chcemy wygrać jak najszybciej,
w jak najmniejszej ilości ruchów.
Możemy dodać to zachowanie do naszego algorytmu, modyfikując
funkcję heurystyki tak żeby “karała” gracza za każdy wykonany ruch.
Alternatywnie heurystyka może nagradzać gracza za każde 
pozostawione wolne pole na planszy:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">double</span> <span class="nf">impatientPlayerHeuristics</span><span class="o">(</span><span class="n">GameState</span> <span class="n">gameState</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">currentPlayer</span><span class="o">);</span>
    <span class="n">var</span> <span class="n">freePlaces</span> <span class="o">=</span> <span class="n">gameState</span><span class="o">.</span><span class="na">board</span><span class="o">.</span><span class="na">countFreePlaces</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">score</span> <span class="o">+</span> <span class="n">freePlaces</span><span class="o">*</span><span class="n">Q</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Stałą <code class="highlighter-rouge">Q</code> musimy dobrać w taki sposób żeby wartość 
wyrażenia <code class="highlighter-rouge">freePlaces*Q</code> nigdy
nie przekraczała wartości zwracanej w przypadku wygranej przez 
funkcję <code class="highlighter-rouge">score</code>.
Na przykład jeżeli dla wygranej heurystyka zwraca <code class="highlighter-rouge">1000.0</code> to użycie
<code class="highlighter-rouge">Q = 1.0</code> jest rozsądnym wyborem.</p>

<p>Na koniec zauważmy że plansza 5x5, 3 pod rząd zawiera w sobie
planszę 4x4, 3 pod rząd, dlatego wszystko co powiedzieliśmy tutaj
o zjawisku depresji odnosi się również do niej.</p>

<h3 id="plansza-4x4-4-pod-rząd-wygrywają">Plansza 4x4, 4 pod rząd wygrywają</h3>

<p>W przypadku plansz 4x4 i większych kluczowym problemem staje się wydajność.
Prostym sposobem na poradzenie sobie z tym problemem jest rezygnacja z
analizy całego drzewa gry i skupienie się na pierwszych N ruchach 
wykonywanych przez graczy.
W tym wypadku dobór odpowiedniej heurystyki staje się jeszcze ważniejszy
ponieważ
oceniać musimy nie tylko gry zakończone, ale również takie
które wciąż trwają.
Z drugiej strony nadmierne skomplikowanie heurystyki negatywnie wpływa 
na złożoność obliczeniową i co za tym idzie, na czas oczekiwania na wybór ruchu.</p>

<p>Jako kompromis możemy przyjąć na przykład analizę jedynie siedmiu
posunięć graczy w przyszłość, przy jednoczesnym rozbudowaniu heurystyki
o punktowanie “prawie zwycięstw”. Prawie zwycięstwo to sytuacja na
planszy która w wyniku jednego ruchu czy posunięcia gracza zmienia się
w wygraną. W przypadku planszy 4x4, 4 pod rząd możemy przyjąć
że rząd, kolumna lub przekątna złożona z trzech znaków gracza i wolnego
miejsca jest prawie zwycięstwem np. <code class="highlighter-rouge">X _ X X</code> jest prawie zwycięstwem
dla gracza X.</p>

<p>W przypadku optymalizacji bardziej skomplikowanych gier nie obejdziemy się
bez dodatkowych narzędzi takich jak np. profiler.
Jednym z najlepszych, darmowych profilerów dostępnych na rynku dla platformy JVM
jest <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a>.</p>

<p>Możemy również dużo zyskać unikając nadmiernych alokacji pamięci.
Na przykład zamiast tworzyć nową niemutowalną planszę za każdym razem gdy 
symulujemy ruch gracza, możemy wykorzystać mutowalną strukturę danych
wraz z wycofywaniem ruchów (ang. backtracking):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="n">Move</span> <span class="nl">playerMove:</span> <span class="n">movesToCheck</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Modify board in place</span>
    <span class="n">board</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">playerMove</span><span class="o">.</span><span class="na">position</span><span class="o">,</span> <span class="n">playerMove</span><span class="o">.</span><span class="na">mark</span><span class="o">);</span>

    <span class="c1">// Do recursive minimax call and other stuff</span>

    <span class="c1">// Restore board state</span>
    <span class="n">board</span><span class="o">.</span><span class="na">removeMark</span><span class="o">(</span><span class="n">playerMove</span><span class="o">.</span><span class="na">position</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<h3 id="plansza-5x5-4-lub-5-pod-rząd-wygrywają">Plansza 5x5, 4 lub 5 pod rząd wygrywają</h3>

<p>Na tym poziomie wydajność staje się elementem kluczowym.
Duża wielkość drzewa gry sprawia że strategie
bazujące na prawdopodobieństwie zaczynają wyglądać 
coraz bardziej interesująco.
Na przykład możemy użyć następującego algorytmu bazującego
na <a href="https://pl.wikipedia.org/wiki/Metoda_Monte_Carlo">metodzie Monte Carlo</a>,
do wygenerowania listy ruchów które będziemy oceniać:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Moves</span><span class="o">&gt;</span> <span class="nf">getMovesToCheck</span><span class="o">(</span><span class="n">Board</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Cutoff - use heuristics to evaluate the board</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Set</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// For the first three player moves we analyze every possibility</span>
    <span class="n">var</span> <span class="n">allPossibleMoves</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">getMovesForAllFreeFields</span><span class="o">()</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">allPossibleMoves</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Take K random moves to analyze</span>
    <span class="k">return</span> <span class="n">allPossibleMove</span><span class="o">.</span><span class="na">shuffle</span><span class="o">().</span><span class="na">take</span><span class="o">(</span><span class="n">K</span><span class="o">);</span>

<span class="o">}</span></code></pre></figure>

<p>W przypadku gdy algorytm zwróci pustą listę ruchów do sprawdzenia,
po prostu oceniamy planszę za pomocą heurystyki i zwracamy to jako
wynik (pamiętając o negacji dla gracza MIN) z wywołania funkcji minimax.</p>

<h3 id="jak-to-zdebugować-generalne-strategie-debugowania">Jak to zdebugować? Generalne strategie debugowania</h3>

<ul>
  <li>Testy jednostkowe dla wykorzystywanych przez nas heurystyk to podstawa.
 Pisząc heurystyki dla gry kółko i krzyżyk bardzo łatwo o pomyłkę
 lub błąd w stylu “off by one”. Dodanie testów i upewnienie się
 że pokrycie kodu testami jest odpowiednio wysokie powinno być
 pierwszym działaniem jakie podejmujemy podczas debugowania.</li>
  <li>Nasza aplikacja powinna posiadać funkcję umożliwiającą cofnięcie
 ostatnich ruchów gracza. Znacznie ułatwi to debugowanie za pomocą
 debuggera. W przypadku bardziej skomplikowanych gier typu warcaby
 warto dodać opcję zapisu i odczytu stanu gry z pliku.</li>
  <li>Warto dodać opcję gry komputer vs komputer, jak również wyboru
 kto stawia pierwszy ruch. Pozwala to lepiej ocenić działanie algorytmu.</li>
  <li>Zwracając optymalny ruch algorytm minimax zwraca tak naprawdę
 ścieżkę od korzenia do liścia w drzewie gry (korzeń reprezentuje
 obecną sytuację na planszy, liść przyszłą wygraną lub remis).
 Warto zalogować taką informację wypisując ją na konsole, bądź 
 zapisując do pliku. Pamiętajmy żeby zalogować tylko i wyłącznie
 ścieżkę dla wybranego ruchu. W przeciwnym wypadku możemy utonąć w
 powodzi informacji.</li>
</ul>

<p>Na koniec zdradzę wam sekret debugowania, który pomoże wam rozwiązać
nie jeden problem: “Co dwie głowy to nie jedna!”.
Jeżeli masz problem którego nie potrafisz sam rozwiązać poproś
drugą osobę o pomoc. I niech to nie będzie prośba na forum 
czy StackOverflow ale debugowanie ramie w ramie z drugim człowiekiem.
To naprawdę działa i mówię to mając na karku kilka lat solidnej
praktyki jako programista.</p>

<h3 id="przykładowa-aplikacja">Przykładowa aplikacja</h3>

<p>Kod przykładowej aplikacji można znaleźć na 
<a href="https://github.com/marcin-chwedczuk/xox/">GitHubie</a>.</p>

<p>Aplikację najlepiej otworzyć w IntelliJ, importując ją 
jako projekt Gradle. Do edycji GUI niezbędny jest
<a href="https://gluonhq.com/products/scene-builder/">SceneBuilder</a>.</p>

<p>Jeżeli odkryjecie w aplikacji błąd proszę piszcie na 0xmarcin małpa gmail.com.</p>

<p>Sam kod aplikacji jest czytelny ale nie perfekcyjny. Jest jeszcze wiele
rzeczy które chciałbym poprawić. Jeżeli widzicie miejsce które
można poprawić nie bójcie się stworzyć pull request’a na GitHubie.
Gwiazdki są również mile widziane ;)</p>

	  ]]></description>
	</item>

	<item>
	  <title>Nesting monads in Scala</title>
	  <link>//scala-nesting-monads</link>
	  <author></author>
	  <pubDate>2020-08-01T02:00:01+02:00</pubDate>
	  <guid>//scala-nesting-monads</guid>
	  <description><![CDATA[
	     <p>Recently I write a lot of async code. Most of my repository
methods return types like <code class="highlighter-rouge">Future[Set[T]]</code> or <code class="highlighter-rouge">Future[Option[T]]</code>.
But as we will see, working with such types in pure Scala
can be very cumbersome.</p>

<p>For example in pure Scala we cannot write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">namesFuture</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"bob"</span><span class="o">,</span> <span class="s">"alice"</span><span class="o">));</span>

<span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">names</span> <span class="k">&lt;-</span> <span class="n">namesFuture</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">names</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">name</span><span class="o">.</span><span class="n">capitalize</span></code></pre></figure>

<p>Nop. Nada. Will not work. When we try to compile this code,
the compiler will point out that <code class="highlighter-rouge">names</code> have type of <code class="highlighter-rouge">List[String]</code>
instead of expected <code class="highlighter-rouge">Future[X]</code>.</p>

<p>To understand the problem better lets remind ourselves
how Scala compiler translates for-comprehensions into
method calls:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">ks</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span>
  <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">i</span>
  <span class="n">k</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">j</span>
  <span class="n">sum</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="mi">3</span><span class="o">*</span><span class="n">sum</span>
<span class="c1">// Is translated (with some simplifications) into:
</span><span class="k">val</span> <span class="n">ks2</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">i</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">j</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">j</span><span class="o">)</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">k</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">withFilter</span> <span class="o">{</span> <span class="n">sum</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">sum</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">sum</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>In short every but the last “assignment” of the form <code class="highlighter-rouge">var &lt;- something</code> is
translated into <code class="highlighter-rouge">something.flatMap { var =&gt; ...</code>.
The last “assignment” is translated into a simple <code class="highlighter-rouge">map</code> call.
<code class="highlighter-rouge">if</code> filters are translated into <code class="highlighter-rouge">withFilter</code> or <code class="highlighter-rouge">filter</code> calls.</p>

<p>Returning to our first example we see that it is translated
into:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">names</span> <span class="k">&lt;-</span> <span class="n">namesFuture</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">names</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">name</span><span class="o">.</span><span class="n">capitalize</span>
<span class="c1">// into this:
</span><span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="n">namesFuture</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">names</span> <span class="k">=&gt;</span>
  <span class="n">names</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">capitalize</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>And indeed it does not type check as <code class="highlighter-rouge">namesFuture.flatMap</code> expects
that the passed lambda will return a <code class="highlighter-rouge">Future[X]</code> not
a <code class="highlighter-rouge">List[X]</code>.</p>

<p>We can quickly fix this problem by introducing a nested <code class="highlighter-rouge">for</code>
or by replacing <code class="highlighter-rouge">flatMap</code> by <code class="highlighter-rouge">map</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">names</span> <span class="k">&lt;-</span> <span class="n">namesFuture</span> <span class="o">}</span> <span class="k">yield</span>
                       <span class="k">for</span> <span class="o">{</span> <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">names</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="o">;</span>
<span class="c1">// or:
</span><span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="n">namesFuture</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">names</span> <span class="k">=&gt;</span>
  <span class="n">names</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">capitalize</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// of if you are processing only a single collection:
</span><span class="k">val</span> <span class="n">capitalizedNames</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">names</span> <span class="k">&lt;-</span> <span class="n">namesFuture</span> <span class="o">}</span>
                       <span class="k">yield</span> <span class="n">names</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">capitalize</span><span class="o">)</span></code></pre></figure>

<p>And even in this simple example, the method chain 
becomes quite unreadable when you try to
squash it into a single line: <code class="highlighter-rouge">namesFuture.map(_.map(_.capitalize))</code>.</p>

<p>Exactly the same problems appears when we try to work with <code class="highlighter-rouge">Future[Option[T]]</code>.
But here we can at least use libraries to reduce the pain.
For example using <code class="highlighter-rouge">OptionT</code> type from <a href="https://typelevel.org/cats/">Cats</a>,
we can write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.data.OptionT</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">val</span> <span class="n">nameFuture</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="s">"foo"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">nameFuture</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">name</span> <span class="k">=&gt;</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">name</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"name is $name"</span><span class="o">))</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="nc">Inf</span><span class="o">)</span></code></pre></figure>

<p>…and call it a day.</p>

<p>In pure Scala this code would look like this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">nameFuture</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">name</span> <span class="k">=&gt;</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">))</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"name is $n"</span><span class="o">)))</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="nc">Inf</span><span class="o">)</span></code></pre></figure>

<p>In short I don’t understand why language designers decided to not support
nested monads in for-comprehensions. It’s a pity that we have to use
external libraries to get such a basic functionality.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Useful JDK tools (part 1)</title>
	  <link>//useful-jdk-tools-part-1</link>
	  <author></author>
	  <pubDate>2020-07-10T02:00:01+02:00</pubDate>
	  <guid>//useful-jdk-tools-part-1</guid>
	  <description><![CDATA[
	     <p>JDK comes with a bunch of handy tools. It’s good to
know about them. In this post we will take a look at
<code class="highlighter-rouge">jps</code>, <code class="highlighter-rouge">jstack</code>, <code class="highlighter-rouge">jmap</code> and <code class="highlighter-rouge">jhat</code>.</p>

<h3 id="jps">jps</h3>

<p><code class="highlighter-rouge">jps</code> is a JVM counterpart to unix <code class="highlighter-rouge">ps</code> command.
By default <code class="highlighter-rouge">jps</code> prints process PID and 
the name of the main class
or the name of a jar file if the 
application was started using <code class="highlighter-rouge">java -jar</code> option.</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jps
54177 Jps
54173 App
54452 app.jar</code></pre></figure>

<p>But it can be more talkative. 
<code class="highlighter-rouge">-l</code> option adds a package name to the
main class name and a full/relative path to the jar filename.
<code class="highlighter-rouge">-m</code> option will print command line arguments passed to the program.</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jps -lm
54355 pl.marcinchwedczuk.app.App arg1 arg2 arg3
54452 build/libs/app.jar arg1 arg2 arg3
54458 jdk.jcmd/sun.tools.jps.Jps -lm</code></pre></figure>

<p>To print JVM switches we use <code class="highlighter-rouge">-v</code> option:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jps -v
54654 app.jar -Xmx32m -Xms32m
54657 Jps -Dapplication.home=... -Xms8m ...</code></pre></figure>

<h3 id="jstack">jstack</h3>

<p><code class="highlighter-rouge">jstack PID</code> can be used to print current stack traces of
all threads running in java process.
You can also print stack traces from a core dump file.
The output of <code class="highlighter-rouge">jstack</code> command is often referred to
as a <em>thread dump</em>.</p>

<p>Thread dumps are invaluable resources when it comes to debugging
nasty deadlocks that show up only on the production servers.
On the other hand the number of threads in a serious java application
can be overwhelming. To make the most of thread dumps, you
need to give threads meaningful names. You should give names 
(via <code class="highlighter-rouge">Thread::setName</code>) at least to the threads that you create 
yourself and 
you should also supply a “thread naming” <code class="highlighter-rouge">ThreadFactory</code> when creating
new thread pools (e.g. <code class="highlighter-rouge">newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code>).</p>

<p>Let’s create a simple app that deadlocks and see what <code class="highlighter-rouge">jstack</code>
will print:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
	<span class="n">Lock</span> <span class="n">l1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
	<span class="n">Lock</span> <span class="n">l2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>

	<span class="n">var</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
		<span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">setName</span><span class="o">(</span><span class="s">"AppThread#1"</span><span class="o">);</span>
		<span class="n">l1</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="n">l2</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
	<span class="o">});</span>

	<span class="n">var</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
		<span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">setName</span><span class="o">(</span><span class="s">"AppThread#2"</span><span class="o">);</span>
		<span class="n">l2</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="n">l1</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
	<span class="o">});</span>

	<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
	<span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>EDIT: I was tired when I wrote this code. It will deadlock
both threads
say 99% of time but not always. Instead of <code class="highlighter-rouge">sleep</code> I should use
<code class="highlighter-rouge">CountDownLatch</code>. I leave the code as it is as I don’t want to regenerate
thread dumps but I wanted to point out this problem.</p>

<p>For readability I had to shorten <code class="highlighter-rouge">jstack</code> output.</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jstack `jps | grep App | cut -d ' ' -f 1`

"main" #1 prio=5 os_prio=31 cpu=46.25ms elapsed=85.17s tid=0x00007fb623810800 nid=0x1803 in Object.wait()  [0x000070000027a000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(java.base@14.0.1/Native Method)
	...
	at java.lang.Thread.join(java.base@14.0.1/Thread.java:1371)
	at pl.marcinchwedczuk.bzzz.App.main(App.java:37)

"AppThread#1" #13 prio=5 os_prio=31 cpu=1.30ms elapsed=85.12s tid=0x00007fb622031000 nid=0x9b03 waiting on condition  [0x00007000014b3000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@14.0.1/Native Method)
	...
	at java.util.concurrent.locks.ReentrantLock.lock(java.base@14.0.1/ReentrantLock.java:322)
	at pl.marcinchwedczuk.bzzz.App.lambda$main$0(App.java:22)
	at pl.marcinchwedczuk.bzzz.App$$Lambda$1/0x0000000800b65840.run(Unknown Source)
	at java.lang.Thread.run(java.base@14.0.1/Thread.java:832)
...
Found one Java-level deadlock:
=============================
"AppThread#1":
  waiting for ownable synchronizer 0x00000007ffd92998, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),
  which is held by "AppThread#2"

"AppThread#2":
  waiting for ownable synchronizer 0x00000007ffd92968, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),
  which is held by "AppThread#1"
...</code></pre></figure>

<p>Notice that JVM was able to detect the deadlock, saving us a hours
of debugging. If you have a heisenbug you may consider running
<code class="highlighter-rouge">jstack</code> periodically and searching its output for <code class="highlighter-rouge">Found * deadlock</code> lines.</p>

<p>Now let’s see how we can extract thread dumps for a core dump.
And for that we need a core dump.</p>

<p>Here I will describe how to make a core dump on macOS 10.15
(this is based on <a href="https://developer.apple.com/library/archive/technotes/tn2124/_index.html#//apple_ref/doc/uid/DTS10003391-CH1-SECCOREDUMPS">this article</a>)
First we need to execute <code class="highlighter-rouge">ulimit -c unlimited</code> in the shell
to remove the file size limit on created core-dump files.
A simple crashing hello world C program can create about 2GB core dump,
Java cores can have sizes of 10GB or more.
Then we need to set appropriate
permissions for <code class="highlighter-rouge">/cores</code> directory:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ sudo chmod 1777 /cores
# Test if we have enough permissions
$ echo 1 &gt; /cores/test</code></pre></figure>

<p>TIP: <code class="highlighter-rouge">1</code> in <code class="highlighter-rouge">1777</code> is for <a href="https://en.wikipedia.org/wiki/Sticky_bit">sticky bit</a>.
If a directory has this bit set then 
only the owner of a file contained in that directory
can remove or rename that file.
If we additionally create a file with <code class="highlighter-rouge">700</code> permissions 
then nobody beyond us will be able to change or
remove the file.</p>

<p>Then <em>in the same</em> shell in which we executed <code class="highlighter-rouge">ulimit -c unlimited</code>
we have to run a java application and in a new
terminal window we need to send <code class="highlighter-rouge">SIGSEGV</code> to that app:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ kill -SIGSEGV PID</code></pre></figure>

<p>After being hit by <code class="highlighter-rouge">SIGSEGV</code> Java should crash with a message:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ java -jar build/libs/bzzz.jar
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fff6f4cfdfa, pid=55303, tid=775
...
# Core dump will be written. Default location: /cores/core.56128
...</code></pre></figure>

<p>It may take a while to write 10GB+ file on disk so be patient.</p>

<p>Now for some reason I was not able to take a core dump from
official Oracle distribution of JDK. When I used OpenJDK
build everything worked perfectly. Now when I switched to OpenJDK
I have to use OpenJDKs <code class="highlighter-rouge">jstack</code> to analyze the core dump.</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ export PATH=/usr/local/Cellar/openjdk/14.0.1/bin:$PATH
$ jhsdb jstack --core /cores/core.56128 \
	 --exe /usr/local/Cellar/openjdk/14.0.1/bin/java

"main" #1 prio=5 tid=0x00007fb4c300c000 nid=0x1d03 in Object.wait() [0x00007000027db000]
   java.lang.Thread.State: WAITING (on object monitor)
   JavaThread state: _thread_blocked
 - java.lang.Object.wait(long) @bci=0 (Interpreted frame)
	- waiting on &lt;0x000000061fe55d88&gt; (a java.lang.Thread)
 - java.lang.Thread.join(long) @bci=72, line=1303 (Interpreted frame)
	- locked &lt;0x000000061fe55d88&gt; (a java.lang.Thread)
 - java.lang.Thread.join() @bci=2, line=1371 (Interpreted frame)
 - pl.marcinchwedczuk.bzzz.App.main(java.lang.String[]) @bci=57, line=37 (Interpreted frame)
...</code></pre></figure>

<p>For some reason in OpenJDK 14 the command <code class="highlighter-rouge">jstack /path/to/java coredump</code>
did not work. Instead I have to use a new tool introduced in JDK9
called <code class="highlighter-rouge">jhsdb</code>. Anyway the result is the same, we managed to
get thread dumps from the core dump. Again the tool was smart enough
to point out the deadlock (not visible on attached listing).</p>

<p>OK lets cleanup our system and revert the settings:
<code class="highlighter-rouge">ulimit -c 0</code>, <code class="highlighter-rouge">rm /cores/*</code> and <code class="highlighter-rouge">sudo chmod 1775 /cores</code>.</p>

<h3 id="jmap">jmap</h3>

<p><code class="highlighter-rouge">jmap</code> can be used to display various info about
Java process heap. For example we may take a heap 
histogram, which tells us number of instances and
total memory size taken per class.</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jmap -histo $PID | head
No dump file specified
 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:           965        2775128  [I (java.base@14.0.1)
   2:          7555         399568  [B (java.base@14.0.1)
   3:          7324         175776  java.lang.String (java.base@14.0.1)
   4:          1295         160512  java.lang.Class (java.base@14.0.1)
   5:           964          88712  [Ljava.lang.Object; (java.base@14.0.1)
   6:          1872          59904  java.util.HashMap$Node (java.base@14.0.1)</code></pre></figure>

<p>But the real power of <code class="highlighter-rouge">jmap</code> lies in its ability
to take heap dumps:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ jmap -dump:live,format=b,file=heapdump $PID
Dumping heap to /path/to/heapdump ...
Heap dump file created [4264220 bytes in 0.018 secs]</code></pre></figure>

<p>Heapdumps can then be comfortably opened and analyzed in tools like
<a href="https://www.eclipse.org/mat/">Eclipse Memory Analyzer</a>.</p>

<p><img src="assets/images/2020-07-10/ema.png" alt="Eclipse Memory Analyzer" /></p>

<p>Heapdumps can be quite huge, if you want to move them between
servers remember to first compress them to speed things up.
They also contain sensitive data like AWS access
keys and user passwords, so please keep them secure.</p>

<p>TIP: You can also generate heapdumps on
out of memory errors using <code class="highlighter-rouge">-XX:+HeapDumpOnOutOfMemoryError</code> JVM switch.</p>

<p>EDIT: Since JDK9 the recommended way of generating heapdumps
changed. You may want to see <a href="https://www.infoq.com/news/2015/12/OpenJDK-9-removal-of-HPROF-jhat/">this article on InfoQ</a>.</p>

<h3 id="jhat">jhat</h3>

<p>Now what if you don’t want/have permissions to install fancy heapdump analyzers?
Not all is lost, we may still use primitive but working <code class="highlighter-rouge">jhat</code>.
Run <code class="highlighter-rouge">jhat heapdump</code> to start <code class="highlighter-rouge">jhat</code> HTTP server with basic
heapdump browser.</p>

<p>EDIT: Unfortunately <code class="highlighter-rouge">jhat</code> was removed in JDK9.</p>

	  ]]></description>
	</item>

	<item>
	  <title>iTerm2 cheat sheet</title>
	  <link>//iterm2-cheat-sheet</link>
	  <author></author>
	  <pubDate>2020-07-08T02:00:01+02:00</pubDate>
	  <guid>//iterm2-cheat-sheet</guid>
	  <description><![CDATA[
	     <p>iTerm2 is one of the best terminal emulators out there.
But to appreciate its full power you should know how to
use it effectively.
Here are shortcuts that I find indispensible while working with iTerm2.</p>

<h4 id="working-with-panes">Working with panes</h4>

<ul>
  <li><code class="highlighter-rouge">Command + D</code> - Split vertically</li>
  <li><code class="highlighter-rouge">Command + Shift + D</code> - Split horizontally</li>
  <li>
    <p><code class="highlighter-rouge">Command + W</code> - Close pane</p>
  </li>
  <li><code class="highlighter-rouge">Command + Option + Arrows</code> - Navigate between panes</li>
  <li><code class="highlighter-rouge">Control + Command + Arrow</code> - Resize current pane</li>
  <li>
    <p><code class="highlighter-rouge">Command + Shift + Enter</code> - Maximize current pane / Restore its original size</p>
  </li>
  <li><code class="highlighter-rouge">Command + K</code> - Clear current pane</li>
</ul>

<h4 id="text-editing">Text editing</h4>

<ul>
  <li><code class="highlighter-rouge">Control + A</code> - Move to the line beginning</li>
  <li><code class="highlighter-rouge">Control + E</code> - Move to the line end</li>
</ul>

<p>Consider enabling “Natural Text Editing” (instructions <a href="https://apple.stackexchange.com/a/293988">here</a>)
if you want to use <code class="highlighter-rouge">Option + Left/Right Arrow</code> for
one word forward/backward navigation instead of
awkward <code class="highlighter-rouge">Control+] F</code> / <code class="highlighter-rouge">Esc F</code> (Escape followed by F for forward or
B for backward).</p>

<ul>
  <li><code class="highlighter-rouge">Option + Delete</code> - Delete one world</li>
  <li><code class="highlighter-rouge">Command + Delete</code> - Delete entire line</li>
</ul>

<h4 id="scrolling">Scrolling</h4>

<ul>
  <li><code class="highlighter-rouge">Fn + Shift + Up Arrow</code> - Page Up</li>
  <li><code class="highlighter-rouge">Fn + Shift + Down Arrow</code> - Page Down</li>
</ul>

<h4 id="tabs">Tabs</h4>

<ul>
  <li><code class="highlighter-rouge">Command + T</code> - Create new tab</li>
  <li><code class="highlighter-rouge">Command + &lt;num&gt;</code> - Move to <code class="highlighter-rouge">num</code>th tab e.g. <code class="highlighter-rouge">Command + 3</code></li>
  <li><code class="highlighter-rouge">Command + Left/Right arrow</code> - Move to left/right tab</li>
  <li><code class="highlighter-rouge">Command + Option + W</code> - Close tab</li>
</ul>

<p>Add the following function to your <code class="highlighter-rouge">~/.profile</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">title<span class="o">()</span> <span class="o">{</span>
	<span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\e</span><span class="s2">]1;</span><span class="nv">$@</span><span class="se">\a</span><span class="s2">"</span>
<span class="o">}</span></code></pre></figure>

<p>Then you can use <code class="highlighter-rouge">title foo</code> to set iTerm2 tab title.</p>

<h4 id="iterm2-window">iTerm2 Window</h4>

<ul>
  <li><code class="highlighter-rouge">Command + Enter</code> - Enter / Leave full screen mode</li>
  <li><code class="highlighter-rouge">Command + ,</code> - Show preferences</li>
</ul>

<h4 id="history-search">History search</h4>

<ul>
  <li><code class="highlighter-rouge">Control + R</code> - Start history search (fuzzy search)</li>
  <li><code class="highlighter-rouge">Control + R</code> - Move to the next suggestion</li>
</ul>

<h4 id="other">Other</h4>

<ul>
  <li><code class="highlighter-rouge">Command + ;</code> - Open graphical autocomplete menu in iTerm2</li>
  <li>Use <code class="highlighter-rouge">open URL</code> command to open given file in MacOS e.g. <code class="highlighter-rouge">open 'https://google.com'</code> or <code class="highlighter-rouge">open .</code> to open current directory in Finder</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Connecting to Raspberry PI from Linux via UART</title>
	  <link>//connecting-to-raspberry-pi-via-uart</link>
	  <author></author>
	  <pubDate>2020-07-07T02:00:01+02:00</pubDate>
	  <guid>//connecting-to-raspberry-pi-via-uart</guid>
	  <description><![CDATA[
	     <p>In this blog post we will learn how to connect to a Raspberry PI via UART
(think serial terminal).
Before we begin we need to get a cheap <code class="highlighter-rouge">USB &lt;-&gt; UART</code> converter.
Make sure that the converter supports 3.3V voltage.
Most of the converters support other voltages e.g. 5V and you
can select which voltage you want by moving a jumper.
If your converter has such a jumper make sure that it is in 3.3V position.
<img src="assets/images/2020-07-07/converter1.jpeg" alt="Converter" /></p>

<p>Although converters can have from four up to six pins, we will only need three:
GND, RXD and TXD. We should connect RXD pin on the converter to TXD pin on
the Raspberry PI and similarly TXD pin to the Raspberry’s RXD pin (crossover).
We also need to connect the converter GND pin to Raspberry’s Ground pin.
Do NOT connect VCC (or VCCIO) pin, we only need three wires.
You can find the Raspberry PI pinout in the official docs: 
<a href="https://www.raspberrypi.org/documentation/usage/gpio/">https://www.raspberrypi.org/documentation/usage/gpio/</a> - look at the five top left pins, the first two
are +5V, then we have Ground, TXD and RXD pins.
<img src="assets/images/2020-07-07/connection.jpeg" alt="Connection" /></p>

<p>Next thing that we need to do is to enable UART support in Raspbian, which for
security reasons is disabled by default.
We need to change <code class="highlighter-rouge">config.txt</code> file on the <code class="highlighter-rouge">/boot</code> partition
on the Raspberry PI SD card. We need to add <code class="highlighter-rouge">enable_uart=1</code> line
before <code class="highlighter-rouge">[pi4]</code> section (or at the end of the file if the section is not present).</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">(some lines skipped)

# Enable audio (loads snd_bcm2835)
dtparam=audio=on

# ADD THIS LINE HERE
enable_uart=1

[pi4]
# Enable DRM VC4 V3D driver on top of the dispmanx display stack
dtoverlay=vc4-fkms-v3d
max_framebuffers=2</code></pre></figure>

<p>When we connect the converter to both Raspberry PI and the computer it should
be recognized by the system and a new device named <code class="highlighter-rouge">ttyUSBn</code> (where n is a number e.g. <code class="highlighter-rouge">ttyUSB0</code>)
should appear under <code class="highlighter-rouge">/dev</code> directory.
As always with all things hardware <code class="highlighter-rouge">dmesg</code> is your friend, so you can either <code class="highlighter-rouge">dmesg | tail -n 100</code> or
<code class="highlighter-rouge">dmesg | grep tty</code> to find out what exactly device was created and if there where any problems.
On my system I saw the following messages:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">$ dmesg | grep tty
[22562.037811] usb 3-10: cp210x converter now attached to ttyUSB0</code></pre></figure>

<p>There are a lot of different programs on Linux that you can use to open a session.
We will concentrate on only two of them, <code class="highlighter-rouge">putty</code> which is a GUI tool and
<code class="highlighter-rouge">screen</code> which is a pure command line utility.</p>

<p>Let’s start with <code class="highlighter-rouge">putty</code>, first we need to configure it to read from <code class="highlighter-rouge">/dev/ttyUSB0</code> device.
<img src="assets/images/2020-07-07/puttyconf.png" alt="Putty Config" /></p>

<p>To avoid putting this info every time, when you want to connect we should save it as an profile
(put a name and click Save button).
<img src="assets/images/2020-07-07/profile.png" alt="Putty Profile" /></p>

<p>It is also worth checking other settings like the font, keyboard or the default terminal size:
<img src="assets/images/2020-07-07/puttyk.png" alt="Putty Other Settings 1" />
<img src="assets/images/2020-07-07/puttyf.png" alt="Putty Other Settings 2" /></p>

<p>OK its time to test our configuration. Open putty and load
previously saved profile, click Open and restart Raspberry PI.
You should be able to see boot messages. Try pressing Enter if the console appears to hang.
<img src="assets/images/2020-07-07/boot.png" alt="Boot messages" /></p>

<p>After we login it is easy to notice that there is no color support out of the box
(at least on Raspbian Lite).
This can be easily changed by selecting a different terminal type in the terminal session:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">TERM</span><span class="o">=</span>xterm-256color</code></pre></figure>

<p><img src="assets/images/2020-07-07/colors.png" alt="Color support" /></p>

<p>Another problem is that we are stuck with a fixed terminal size.
If your Raspberry PI has xterm package installed (not available on Lite version)
you can use <code class="highlighter-rouge">resize</code> command after you resize putty’s window.
Otherwise you may use this script created by @pkh 
<a href="https://unix.stackexchange.com/a/283206">https://unix.stackexchange.com/a/283206</a>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">resize<span class="o">()</span> <span class="o">{</span>
  <span class="nv">old</span><span class="o">=</span><span class="k">$(</span>stty <span class="nt">-g</span><span class="k">)</span>
  stty raw <span class="nt">-echo</span> min 0 <span class="nb">time </span>5

  <span class="nb">printf</span> <span class="s1">'\0337\033[r\033[999;999H\033[6n\0338'</span> <span class="o">&gt;</span> /dev/tty
  <span class="nv">IFS</span><span class="o">=</span><span class="s1">'[;R'</span> <span class="nb">read</span> <span class="nt">-r</span> _ rows cols _ &lt; /dev/tty

  stty <span class="s2">"</span><span class="nv">$old</span><span class="s2">"</span>
  stty cols <span class="s2">"</span><span class="nv">$cols</span><span class="s2">"</span> rows <span class="s2">"</span><span class="nv">$rows</span><span class="s2">"</span>
<span class="o">}</span></code></pre></figure>

<p>Just copy and paste this code into the session and then enter <code class="highlighter-rouge">resize</code> (use Ctrl+Shift+Insert to paste in <code class="highlighter-rouge">putty</code>).
After the <code class="highlighter-rouge">resize</code>, commands like <code class="highlighter-rouge">top</code> or <code class="highlighter-rouge">htop</code> should occupy the entire terminal window.
<img src="assets/images/2020-07-07/beforeR.png" alt="Before resize" />
After resize becomes:
<img src="assets/images/2020-07-07/afterR.png" alt="After resize" /></p>

<p>You may want to add both the <code class="highlighter-rouge">resize</code> function and <code class="highlighter-rouge">TERM</code> environment variable to <code class="highlighter-rouge">~/.profile</code>
to avoid copy-pasting them every time.</p>

<p>If you don’t use GUI at all you may use <code class="highlighter-rouge">screen</code>. <code class="highlighter-rouge">screen</code> was designed to work with SSH sessions,
it helps you keep your programs running even after you end your SSH connection.
Most people these day use <code class="highlighter-rouge">tmux</code> as a modern alternative, unfortunately <code class="highlighter-rouge">tmux</code> does not
support serial communications so we are stuck with <code class="highlighter-rouge">screen</code> (which TBH I am not very familiar with).</p>

<p>We start <code class="highlighter-rouge">screen</code> using the following command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">screen /dev/ttyUSB0 115200</code></pre></figure>

<p>To exit screen (which is on the same level of difficultly as exiting Vim) 
press Ctrl+A followed by \ (yup backslash).
A question will appear at the left bottom of the screen, answer y.</p>

<p>If <code class="highlighter-rouge">screen</code>s window appears blank, press enter to reprint the prompt.
For some reason programs like <code class="highlighter-rouge">htop</code> tend to look worse under <code class="highlighter-rouge">screen</code>
(assuming that you set <code class="highlighter-rouge">TERM</code> variable and did <code class="highlighter-rouge">resize</code>). Probably I am missing some extra setup,
nevertheless they are usable.
<img src="assets/images/2020-07-07/screen.png" alt="screen" /></p>

<p>Last but not least, for fans of ancient <code class="highlighter-rouge">minicom</code> 
if you want to connect via <code class="highlighter-rouge">minicom</code>
remember to disable “Hardware Control Flow” option 
(they use RTS and CTS lines present on some converters that we do not use).</p>


	  ]]></description>
	</item>

	<item>
	  <title>Scala WTF 1</title>
	  <link>//scala-wtf-1</link>
	  <author></author>
	  <pubDate>2020-07-06T02:00:01+02:00</pubDate>
	  <guid>//scala-wtf-1</guid>
	  <description><![CDATA[
	     <p>So here is a puzzle. What will be written by
this program:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Wtf1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">points</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
      <span class="nc">Point</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
    <span class="o">)</span>

    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">points</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"result: $result"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// ANSWER BELOW
// ..............................................
</span><span class="o">//</span></code></pre></figure>

<p>The answer is <code class="highlighter-rouge">false</code>.
Why? Because the line with <code class="highlighter-rouge">points.contains(Point(3, _))</code>
instead of performing pattern matching, checks whether <code class="highlighter-rouge">points</code> 
contain a function:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">points</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
<span class="c1">// in reality is:
</span><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">names</span><span class="o">.</span><span class="n">contains</span><span class="o">((</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span></code></pre></figure>

<p>The strangest thing for me is that the compilation of 
this code does not generate any warnings.
From Scala compiler point of view the above code is
perfectly valid and this in turn is the result of
<code class="highlighter-rouge">List</code> type being covariant.
Or in the other words because we can assign <code class="highlighter-rouge">List[Point]</code> to
<code class="highlighter-rouge">List[Any]</code>, <code class="highlighter-rouge">contains</code> must accept
arguments of any type:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">points</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
    <span class="nc">Point</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">anys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">points</span>

<span class="n">anys</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">())</span></code></pre></figure>

<p>The declaration of <code class="highlighter-rouge">contains</code> method in <code class="highlighter-rouge">List[A]</code> looks like this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">contains</span><span class="o">[</span><span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">elem</span><span class="k">:</span> <span class="kt">A1</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span></code></pre></figure>

<p>We may snoop the actual types assigned to the generic parameters
using a helper method:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">detectType</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">A1</span><span class="o">)</span>
                          <span class="o">(</span><span class="k">implicit</span> <span class="n">tagA</span><span class="k">:</span> <span class="kt">ClassTag</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tagA1</span><span class="k">:</span> <span class="kt">ClassTag</span><span class="o">[</span><span class="kt">A1</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"type of A : ${tagA.runtimeClass.getName}"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"type of A1: ${tagA1.runtimeClass.getName}"</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">detectType</span><span class="o">(</span><span class="n">names</span><span class="o">,</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>

<span class="c1">// This prints:
// type of A : Point
// type of A1: java.lang.Object
</span><span class="o">//</span></code></pre></figure>

<p>So during the compilation <code class="highlighter-rouge">A1</code> becomes <code class="highlighter-rouge">Object</code> and everything
type-checks.</p>

<p>Let’s finish by writing a code that actually does what
the programmer intended:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">names</span>
    <span class="o">.</span><span class="n">collectFirst</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span></code></pre></figure>


	  ]]></description>
	</item>

	<item>
	  <title>Matching regexes using backtracking</title>
	  <link>//matching-regexes-using-backtracking</link>
	  <author></author>
	  <pubDate>2020-06-28T02:00:01+02:00</pubDate>
	  <guid>//matching-regexes-using-backtracking</guid>
	  <description><![CDATA[
	     <p>In this post we will write a simple regex library.
The table below presents regex operators that we are going to support:</p>

<table>
    <colgroup>
        <col width="25%" />
        <col width="75%" />
    </colgroup>
    <thead>
        <tr class="header">
            <th>Operator</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>A single character e.g. <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">\n</code>, <code class="highlighter-rouge">\(</code></td>
            <td>
                A single character matches itself.<br />
                Special characters need to be escaped e.g. <code class="highlighter-rouge">\n</code>.
            </td>
        </tr>
        <tr>
            <td>Character groups e.g. <code class="highlighter-rouge">[a-z]</code>, <code class="highlighter-rouge">[^xyz]</code></td>
            <td>Character group matches any character
                that is part of the group.<br /><br />
                Negated character group (<code class="highlighter-rouge">[^xyz]</code>)
                matches any character that is <em>not</em> part of the group.<br /><br />
                Character ranges like <code class="highlighter-rouge">a-z</code> can be used inside groups.
                A character c belongs to <code class="highlighter-rouge">a-z</code> range when its
                numerical value falls between <code class="highlighter-rouge">(int)'a' &lt;= (int)c &lt;= (int)'z'</code>.
            </td>
        </tr>
        <tr>
            <td><code class="highlighter-rouge">.</code> wildcard</td>
            <td>
                <code class="highlighter-rouge">.</code> wildcard will match any single character. 
                <br /><br />
                For example
                <code class="highlighter-rouge">...</code> will match any string consisting of three characters.
            </td>
        </tr>
        <tr>
            <td>Concatenation e.g. <code class="highlighter-rouge">abc</code>,<br /><code class="highlighter-rouge">[0-9]-[0-9]</code></td>
            <td>Just as we can concatenate strings, 
                we may also concatenate regexes. 
                The resulting expression will match an input, only when the input can be split into two parts, so that
                the first part of the input matches the first concatenated regex and
                the second part of the input matches the second concatenated regex.
                <br /><br />
                For example input <code class="highlighter-rouge">9X</code> matches the regex <code class="highlighter-rouge">[0-9][XYZ]</code> because <code class="highlighter-rouge">9</code> matches <code class="highlighter-rouge">[0-9]</code> and <code class="highlighter-rouge">X</code> matches <code class="highlighter-rouge">[XYZ]</code>.
            </td>
        </tr>
        <tr>
            <td>Alternative e.g. <code class="highlighter-rouge">Z|X|[0-9]</code></td>
            <td>Input matches the alternative when it matches
                any branch of the alternative. <br /><br />
                For example inputs <code class="highlighter-rouge">Z</code>, <code class="highlighter-rouge">X</code>
                and <code class="highlighter-rouge">3</code> will all match <code class="highlighter-rouge">Z|X|[0-9]</code> alternative because they match
                respectively <code class="highlighter-rouge">Z</code>, <code class="highlighter-rouge">X</code> and <code class="highlighter-rouge">[0-9]</code> branches. 
                <br /><br />
                Alternative has lower priority than concatenation so
                <code class="highlighter-rouge">foo|bar</code> means <code class="highlighter-rouge">(foo)|(bar)</code>, not <code class="highlighter-rouge">fo(o|b)ar</code>.
            </td>
        </tr>
        <tr>
            <td>Repetition (quantification) 
                e.g. <code class="highlighter-rouge">a*</code>, <code class="highlighter-rouge">[0-9]?</code>, <code class="highlighter-rouge">X{1,5}</code></td>
            <td>
                Preceding regex must match input specified number of times.<br />
                Supported operators are: <br /><br />
                <ul>
                    <li><code>*</code> - matches zero or more times</li>
                    <li><code>+</code> - matches one or more times</li>
                    <li><code>?</code> - matches zero or one time</li>
                    <li><code>{n}</code> - matches exactly n times</li>
                    <li><code>{n,m}</code> - matches between n and m
                     times (inclusive) 
                    </li>
                </ul>
                <div>
                    For example <code class="highlighter-rouge">[0-9]*</code> will match any string consisting of digits, including empty string.<br />
                    On the other hand <code class="highlighter-rouge">[0-9]{2,3}</code> will match strings consisting of two or three decimal digits.<br /><br />
                    In our limited implementation we do not support spaces
                    (or any other whitespace characters) inside <code class="highlighter-rouge">{n,m}</code> expressions.<br /><br />
                    Repetition has higher priority than concatenation and 
                    alternative so <code class="highlighter-rouge">foo{5}</code> means <code class="highlighter-rouge">fo(o{5})</code>, not <code class="highlighter-rouge">(foo){5}</code>.<br /><br />
                    Repetition operators are greedy, this means they will try
                    to match as much input as possible.<br />
                    For example <code class="highlighter-rouge">(a*)(a*)</code> will match the <code class="highlighter-rouge">aaaaa</code> input in
                    the following way <code class="highlighter-rouge">(aaaaa)()</code> - the first <code class="highlighter-rouge">a*</code> will match
                    all the characters, leaving empty string for the second <code class="highlighter-rouge">a*</code> to match.
                </div>
            </td>
        </tr>
        <tr>
            <td><code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> anchors</td>
            <td>
                <code class="highlighter-rouge">^</code> matches the beginning of the input.<br />
                <code class="highlighter-rouge">$</code> matches the end of the input.<br /><br />
                For example <code class="highlighter-rouge">^foo</code> will match strings that start with
                <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar$</code> will match strings that end with <code class="highlighter-rouge">bar</code>.
            </td>
        </tr>
        <tr>
            <td>Grouping (parentheses)</td>
            <td>
                Parentheses are used to alter the precedence of the operators.<br /><br />
                For example compare <code class="highlighter-rouge">foo|bar</code> with <code class="highlighter-rouge">fo(o|b)ar</code>,
                the first one will match <code class="highlighter-rouge">foo</code>, the second one <code class="highlighter-rouge">fooar</code>.
            </td>
        </tr>
    </tbody>
</table>

<p>The library itself is quite small, it consists of two parts:
a parser and a matcher. 
The parser is a very simple <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>
and as most of manually written parsers
it probably contains some undiscovered bugs.
The parser itself is not the main focus of this article,
so we will tread it as a black box that consumes regular 
expressions in text form and produces equivalent ASTs or Abstract Syntax Trees.</p>

<p>ASTs are tree like data structures, 
that make order of operator evaluation and the internal structure of a regular
expression explicit.
Let’s see this on an example. The AST representation of 
 <code class="highlighter-rouge">^a(foo|bar|egg)*b$</code> regex is:
<img src="assets/images/2020-06-28/ast1.svg" alt="AST tree" /></p>

<p>The anchors <code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> are represented by their own
AST nodes <code class="highlighter-rouge">AT_BEGINNING</code> and <code class="highlighter-rouge">AT_END</code>.
To represent both character groups and single characters, we use
<code class="highlighter-rouge">GROUP</code> nodes. <code class="highlighter-rouge">GROUP</code> nodes are very simple, they contain a list
of characters that they match. A <code class="highlighter-rouge">GROUP</code> node for <code class="highlighter-rouge">[0-9]</code> regex
contains characters <code class="highlighter-rouge">0123456789</code> in the list.
For negated groups like <code class="highlighter-rouge">[^0-9]</code> we use <code class="highlighter-rouge">NEGATED_GROUP</code> node,
the representation is the same as for <code class="highlighter-rouge">GROUP</code> (we keep <code class="highlighter-rouge">0123456789</code> characters
in the list).
Next is the tricky one, we use <code class="highlighter-rouge">NEGATED_GROUP</code> without any characters
to represent wildcard (<code class="highlighter-rouge">.</code>). This makes sense because an empty group <code class="highlighter-rouge">[]</code> 
does not match anything, so its negation will match all characters.</p>

<p>To represent quantification operators like <code class="highlighter-rouge">?</code>, <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code> and <code class="highlighter-rouge">{n,m}</code>
we use <code class="highlighter-rouge">REPEAT</code> nodes. <code class="highlighter-rouge">REPEAT</code> nodes contain two additional attributes:
minimum and maximum number of allowed repetitions.
We use <code class="highlighter-rouge">Long.MAX_VALUE</code> to signify that maximum number of repetitions is unbound.
Finally we use <code class="highlighter-rouge">CONCAT</code> node to represent concatenation of two or more
regular expressions.</p>

<p>In the code all AST nodes are represented by a single class
called <code class="highlighter-rouge">RAst</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RAst</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">RAstType</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">chars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">exprs</span><span class="o">;</span>

    <span class="c1">// Repeat from to, both inclusive</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">repeatMin</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">repeatMax</span><span class="o">;</span>

    <span class="c1">// ...</span></code></pre></figure>

<p><code class="highlighter-rouge">type</code> field describes what kind of AST node this instance
represents e.g. <code class="highlighter-rouge">CONCAT</code>.
<code class="highlighter-rouge">GROUP</code> and <code class="highlighter-rouge">NEGATED_GROUP</code> nodes keep the set of matched/not-matched
characters in <code class="highlighter-rouge">chars</code> field.
<code class="highlighter-rouge">CONCAT</code> and <code class="highlighter-rouge">ALTERNATIVE</code> nodes keep their children in <code class="highlighter-rouge">exprs</code> field 
(the order of children is important, hence a <code class="highlighter-rouge">List</code>).
<code class="highlighter-rouge">REPEAT</code> node keeps its only child as a single element list in <code class="highlighter-rouge">exprs</code> field.</p>

<p>The matcher is represented in the code by <code class="highlighter-rouge">BacktrackingMatcher</code> class.
The interface of the matcher is very simple:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BacktrackingMatcher</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Match</span> <span class="nf">match</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">regex</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Match</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">hasMatch</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">input</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">matched</span><span class="o">()</span>  <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">hasMatch</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Our matcher will only find the first substring of the input that
matches the regex. Yet it would not be too difficult to extend 
the algorithm to find all matches (start matching again 
after the end of the previous match).</p>

<p>To implement our matcher we will use an algorithm design technique 
called backtracking. The general idea of backtracking is
very simple: we enumerate all the possible solution candidates
in a smart way and then we return the first candidate that is a valid solution.
The part “in a smart way” is very important, usually
enumerating all solution candidates will result in a very
slow algorithm (think <code class="highlighter-rouge">O(2^n)</code> or even <code class="highlighter-rouge">O(n!)</code>).
The key here is to quickly and early reject some subsets of
the solutions candidates.</p>

<p>Let’s see this on a very simple example,
say we want to solve a puzzle that is about placing various shapes in 3x3 grid. Some places in the grid are already taken. There is also a rule that describes a valid solution: in every row and column we cannot have two shapes of the same kind.
<img src="assets/images/2020-06-28/puzzle.svg" alt="Puzzle board" />
Simple enumeration of all possible assignments of the shapes to the free places
will generate <code class="highlighter-rouge">3^5</code> solution candidates, most of them wrong.
A smarter candidate generation strategy
would be to check immediately after we fill a free place,
if the solution conditions still holds for this place row and column.
This would save us a lot of work, because we could discard a lot of
solution candidates much more early in the process.
For example we could discard all the solution candidates that have
Cloud shape at 1B position in the first step of the algorithm.</p>

<p>The name of the technique itself comes from the specific way
in which the algorithm generates all the solution candidates.
The naive backtracking algorithm that solves our simple puzzle looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Board positions:</span>
<span class="c1">// [0 | 1 | 2]</span>
<span class="c1">// [3 | 4 | 5]</span>
<span class="c1">// [6 | 7 | 8]</span>
<span class="c1">// Notice that rowIndex = currentPosition / 3</span>
<span class="c1">// and         colIndex = currentPosition % 3</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">currentPosition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currentPosition</span> <span class="o">==</span> <span class="mi">9</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// All places are filled, check if this</span>
        <span class="c1">// candidate is a valid solution.</span>
        <span class="k">return</span> <span class="nf">isValidSolution</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">isPlaceTaken</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Move to checking the next place.</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Try putting all shapes in the free place</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">shape:</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]</span> <span class="o">{</span> <span class="sc">'C'</span><span class="o">,</span> <span class="sc">'H'</span><span class="o">,</span> <span class="sc">'R'</span> <span class="o">})</span> <span class="o">{</span>
        <span class="n">putShape</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">,</span> <span class="n">shape</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Clear position or BACKTRACK.</span>
        <span class="n">putShape</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">currentPosition</span><span class="o">,</span> <span class="sc">'?'</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>The key part of the algorithm is the <code class="highlighter-rouge">for</code> loop,
where we put a shape on the free place and then remove it 
when don’t find a solution. This removal
or taking a move back is what gave the algorithm its name.
Alternatively we may say that when <code class="highlighter-rouge">solve</code> returns <code class="highlighter-rouge">false</code>,
then the <code class="highlighter-rouge">board</code> is exactly in the same state as it was
before we called <code class="highlighter-rouge">solve</code>.</p>

<p>Matching regular expression is somehow similar to solving our previous puzzle.
At each step we have several possibilities, like should we match <code class="highlighter-rouge">foo</code>
or <code class="highlighter-rouge">fo</code> from the alternative <code class="highlighter-rouge">(foo|fo)</code>. How much characters should
<code class="highlighter-rouge">f+</code> expression match? Should <code class="highlighter-rouge">(bar)?</code> match <code class="highlighter-rouge">bar</code> or nothing?
On the other hand the most complexity in matching regular expressions
comes from the fact that we are matching a recurrent structure (tree).
It’s like matching our puzzle, but where each empty place can contain
another smaller version of the same puzzle that also must be solved.</p>

<p>The main entry point to our regex matching algorithm is</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Cont</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">ast</span><span class="o">,</span> <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span></code></pre></figure>

<p>method. It takes three parameters, <code class="highlighter-rouge">input</code> which is just
the input <code class="highlighter-rouge">String</code> plus a pointer called <code class="highlighter-rouge">pos</code> that tracks next, not yet
matched character. <code class="highlighter-rouge">Input</code> also provides helpful methods that can
be used to save and restore <code class="highlighter-rouge">pos</code> value (we will need that
for backtracking). Next parameter, <code class="highlighter-rouge">ast</code>, is an AST subtree that the algorithm
should match. The last parameter <code class="highlighter-rouge">cont</code> is the most interesting one.
In my previous blog post I wrote about 
<a href="/continuations-in-java">continuations</a>, please read that post before
going further. <code class="highlighter-rouge">cont</code> is lambda expression (but we may thread it also as
a kind of continuation), that when called will
try to match remaining part of the regex AST (e.g. it will match parents
and the remaining siblings nodes of <code class="highlighter-rouge">ast</code> node).</p>

<p>The contract of <code class="highlighter-rouge">match</code> method is as follows.
If the method is not able to match <code class="highlighter-rouge">ast</code> subtree it will
return <code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">cont</code> will not be called and the <code class="highlighter-rouge">input</code>
will not be modified (or it may be restored to the original state).
On the other hand if <code class="highlighter-rouge">ast</code> subtree could be matched then
<code class="highlighter-rouge">cont</code> will be called with the modified <code class="highlighter-rouge">input</code> and
<code class="highlighter-rouge">match</code> will return whatever <code class="highlighter-rouge">cont</code> returns.
Before returning value to the client <code class="highlighter-rouge">input</code> will be restored
to the original state (this is not strictly necessary if we
are looking for the first match but somehow makes algorithm more elegant).</p>

<p>At the top level we will call <code class="highlighter-rouge">match</code> somehow like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">currentPos</span><span class="o">();</span>
<span class="n">AtomicInteger</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="kt">boolean</span> <span class="n">hasMatch</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">regex</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">endIndex</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">currentPos</span><span class="o">());</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">});</span></code></pre></figure>

<p>This call means that we are looking for the matches
starting at index <code class="highlighter-rouge">startIndex</code> and if we find one
we save the
end of the match in the <code class="highlighter-rouge">endIndex</code> variable and return <code class="highlighter-rouge">true</code>
to signify that matching process should stop.
This is the only place in the algorithm where we use
<code class="highlighter-rouge">return true</code>. Matched substring could be easily
retrieved as <code class="highlighter-rouge">input.substring(startIndex, endIndex)</code>.</p>

<p>The body of <code class="highlighter-rouge">match</code> method is a giant switch statement that
delegates matching of different AST types to different methods (not counting simple
operators):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span> <span class="n">RAst</span> <span class="n">ast</span><span class="o">,</span> <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">RAstType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="na">type</span><span class="o">;</span>
    <span class="n">InputPositionMarker</span> <span class="n">m</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">switch</span> <span class="o">(</span><span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* some cases skipped */</span>

        <span class="k">case</span> <span class="nl">GROUP:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">atEnd</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ast</span><span class="o">.</span><span class="na">chars</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">current</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">markPosition</span><span class="o">();</span>
                <span class="n">input</span><span class="o">.</span><span class="na">advance</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">input</span><span class="o">.</span><span class="na">restorePosition</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">case</span> <span class="nl">CONCAT:</span>
            <span class="k">return</span> <span class="nf">concatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">.</span><span class="na">exprs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">case</span> <span class="nl">ALTERNATIVE:</span>
            <span class="k">return</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">.</span><span class="na">exprs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">case</span> <span class="nl">REPEAT:</span>
            <span class="k">return</span> <span class="nf">repeatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">ast</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>

        <span class="k">default</span><span class="o">:</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">AssertionError</span><span class="o">(</span><span class="s">"Unknown AST type: "</span> <span class="o">+</span> <span class="n">type</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Let’s take a look how matching a <code class="highlighter-rouge">GROUP</code> is performed.
If the group matches next input character, we save the current
input pointer in <code class="highlighter-rouge">m</code> variable, then we advance the input pointer 
and finally we call <code class="highlighter-rouge">cont</code> to match the
rest of the regex. After <code class="highlighter-rouge">cont</code> returns we restore the input position
using <code class="highlighter-rouge">finally</code> block. This is a bit hacky but it works.</p>

<p>Matching <code class="highlighter-rouge">CONCAT</code> node is also simple. We use recursion to match
subsequent children expressions:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">concatRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                 <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">exprs</span><span class="o">,</span>
                                 <span class="kt">int</span> <span class="n">currExpr</span><span class="o">,</span>
                                 <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currExpr</span> <span class="o">==</span> <span class="n">exprs</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// We matched all the children</span>
        <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Match exprs.get(currExpr) child</span>
    <span class="k">return</span> <span class="nf">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">exprs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currExpr</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span>
        <span class="c1">// If it succeeded then match next child expression </span>
        <span class="n">concatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">exprs</span><span class="o">,</span> <span class="n">currExpr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)</span>
    <span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that because we are not consuming any input here we have
nothing to restore.</p>

<p>Similarly <code class="highlighter-rouge">ALTERNATIVE</code> is easy to match:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                      <span class="n">List</span><span class="o">&lt;</span><span class="n">RAst</span><span class="o">&gt;</span> <span class="n">expr</span><span class="o">,</span>
                                      <span class="kt">int</span> <span class="n">currExpr</span><span class="o">,</span>
                                      <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currExpr</span> <span class="o">==</span> <span class="n">expr</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// We tried all branches but found no match.</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Try matching expr.get(currExpr) branch of the alternative</span>
    <span class="kt">boolean</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currExpr</span><span class="o">),</span> <span class="n">cont</span><span class="o">);</span>
    <span class="c1">// We found a match</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">matched</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="c1">// No match found - Let's try next alternative "branch"</span>
    <span class="k">return</span> <span class="nf">alternativeRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">expr</span><span class="o">,</span> <span class="n">currExpr</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Here <code class="highlighter-rouge">currExpr</code> points to the current alternative branch that we are matching.
Instead of using recursion we may implement <code class="highlighter-rouge">alternativeRec</code> 
using a simple <code class="highlighter-rouge">for</code> loop, which I left as an exercise for the reader.</p>

<p>Matching <code class="highlighter-rouge">REPEAT</code> node causes the most troubles, because all
quantification operators are greedy by default. This means that
e.g. <code class="highlighter-rouge">a+</code> will try to match as much characters as possible.
To implement this behavior we first attempt to match <code class="highlighter-rouge">REPEAT</code>s child subtree 
as many times as possible, then we move “backwards” calling <code class="highlighter-rouge">cont</code>
each time to check if we have a match.
The diagram below illustrates this process:</p>

<figure class="highlight"><pre><code class="language-nohighlight" data-lang="nohighlight">We match a+ expression:
a
a a
a a a         // We matched a three times.
a a a noMatch // Forth time we have noMatch.
a a a cont()  // We move backwards, calling cont()
a a cont()    // each time until it returns true.
a cont() match // cont() returned true.
               // We stop moving backwards and return true from a+.</code></pre></figure>

<p>The code of <code class="highlighter-rouge">repeatRec</code> is:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">repeatRec</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">,</span>
                                 <span class="n">RAst</span> <span class="n">repeatAst</span><span class="o">,</span>
                                 <span class="kt">long</span> <span class="n">matchCount</span><span class="o">,</span>
                                 <span class="n">Cont</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// For expressions like R{n,m} do we have</span>
    <span class="c1">// more matches than necessary?</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">matchCount</span> <span class="o">&gt;</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">repeatMax</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Greedy matching as much as possible.</span>
    <span class="kt">boolean</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">match</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">headExpr</span><span class="o">(),</span> <span class="o">()</span> <span class="o">-&gt;</span>
        <span class="n">repeatRec</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">repeatAst</span><span class="o">,</span> <span class="n">matchCount</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)</span>
    <span class="o">);</span>

    <span class="c1">// We are moving backwards, calling `cont` each time.</span>
    <span class="c1">// We also make sure that we have min number of matches</span>
    <span class="c1">// for expressions like R{n,m}.</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">matched</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">matchCount</span> <span class="o">&gt;=</span> <span class="n">repeatAst</span><span class="o">.</span><span class="na">repeatMin</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">matched</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>And generally that’s it. Our simple regex engine.
There are some details left (like handling <code class="highlighter-rouge">^</code> or <code class="highlighter-rouge">$</code> or
moving <code class="highlighter-rouge">startIndex</code>) but the idea behind the backtracking
matcher should now be familiar to us.</p>

<p>You can find source code for the engine (including tests)
on GitHub: <a href="https://github.com/marcin-chwedczuk/reng">https://github.com/marcin-chwedczuk/reng</a>. But before you jump to see the
code I really recommend you to write a similar engine (in your
favorite language) yourself. This will give you a much more
deeper understanding of the algorithm.</p>

<p>Last but not least, our algorithm has a decent performance,
given that we use reasonable regexes and inputs.
A regex like <code class="highlighter-rouge">(a+)*c</code> matched on the input <code class="highlighter-rouge">aaaaaaaaaaaaaaaaaaaaaaaaaaaab</code>
will have a very bad performance. This is a common problem
not only in our matcher but in most regex libraries
that use backtracking algorithms. You can 
read more about this problem on <a href="https://en.wikipedia.org/wiki/ReDoS">Wikipedia</a>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Continuations in Java</title>
	  <link>//continuations-in-java</link>
	  <author></author>
	  <pubDate>2020-06-27T02:00:01+02:00</pubDate>
	  <guid>//continuations-in-java</guid>
	  <description><![CDATA[
	     <p>CSP or Continuation-Passing Style is a style of programming in which
functions return results via callbacks.
For example <code class="highlighter-rouge">+</code> operator is a function that takes two numbers and
returns their sum. In CSP <code class="highlighter-rouge">+</code> operator becomes a function that takes
three arguments, two terms and a callback, usually called a continuation in
the context of CSP.
In Java we can express this as:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Cont</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">R</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Because functions’ results are always returned via callback calls,
CSP is forcing us to name the returned values by naming callback parameters.
In addition CSP makes the order of evaluation of an expression explicit.
For example, a simple Java program in imperative style:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></code></pre></figure>

<p>Can be expressed in CSP as follows:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">partialSum</span> <span class="o">-&gt;</span>
  <span class="n">add</span><span class="o">(</span><span class="n">partialSum</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span>
    <span class="n">print</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">unit</span> <span class="o">-&gt;</span>
      <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">))));</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
  <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>While transforming imperative programs into CSP form we may encounter
problems with handling procedures (methods returning <code class="highlighter-rouge">void</code> in Java).
A lot of functional programming languages do not support procedures,
instead they define a special type called <code class="highlighter-rouge">Unit</code>, that has only
a single value and use that type to signify that function does
not return any meaningful data.
So defined <code class="highlighter-rouge">Unit</code> type is often identified with the empty tuple <code class="highlighter-rouge">()</code>.
In Java we do not have <code class="highlighter-rouge">Unit</code>, but we may use <code class="highlighter-rouge">Void</code> type with its only
allowed value <code class="highlighter-rouge">null</code> to simulate it.</p>

<p>While looking at our last example we may notice that in CSP form,
function arguments can be in one of three forms:
a constant, a variable or a lambda expression.
There is no rule preventing us from passing two or more
callbacks to a single function. 
Indeed this is necessary to translate <code class="highlighter-rouge">if</code> statement to CSP counterpart:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">iff</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expr</span><span class="o">,</span>
         <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">trueBranch</span><span class="o">,</span>
         <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">falseBranch</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">expr</span><span class="o">)</span> <span class="n">trueBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="k">else</span> <span class="n">falseBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Instead of <code class="highlighter-rouge">Cont&lt;Boolean&gt;</code> we could use here <code class="highlighter-rouge">Cont&lt;Void&gt;</code> as well.</p>

<p>To get a better feel for CSP we will look at three more examples.
We will start with a simple (naive) program for computing sum
of all numbers between given two numbers:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>The transformation to CSP will become easier
if we first replace <code class="highlighter-rouge">for</code> loop with recursion:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum_rec</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="o">)</span>
    <span class="o">?</span> <span class="mi">0</span>
    <span class="o">:</span> <span class="n">from</span> <span class="o">+</span> <span class="n">sum_rec</span><span class="o">(</span><span class="n">from</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>This version can be easily translated into CSP:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">sumCC</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">gt</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">fromGreaterThanTo</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">fromGreaterThanTo</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">0L</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">from1</span> <span class="o">-&gt;</span>
        <span class="n">sumCC</span><span class="o">(</span><span class="n">from1</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">sumCC1</span> <span class="o">-&gt;</span>
          <span class="n">addLong</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">sumCC1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>Where <code class="highlighter-rouge">gt</code> is the CSP counterpart of <code class="highlighter-rouge">&gt;</code> operator.</p>

<p>Next we will transform factorial computing function.
This time we will start with a recursive definition that is 
easier to translate:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">return</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">n</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>CSP version of factorial looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">eq</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">isNZero</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">isNZero</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">factorial</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">fnm1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>As the last example we will transform a function
that computes Fibonacci sequence:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">int</span> <span class="nf">fib1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">fib1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib1</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>In CSP it looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">lt</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nlt2</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">nlt2</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">fib</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">nm2</span> <span class="o">-&gt;</span>
            <span class="n">fib</span><span class="o">(</span><span class="n">nm2</span><span class="o">,</span> <span class="n">fnm2</span> <span class="o">-&gt;</span>
              <span class="n">add</span><span class="o">(</span><span class="n">fnm1</span><span class="o">,</span> <span class="n">fnm2</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))))));</span>
<span class="o">}</span></code></pre></figure>

<p>Now we should have, at least intuitive feel, how the
transformation to CSP works. In fact any program can be
transformed to CSP. The last point is quite interesting,
especially if we pass <code class="highlighter-rouge">() -&gt; exit(0)</code> or some other not-returning function
as the last continuation. Why? Because in that case we will
never return from any of the called functions.
Let’s see how this works on a simple example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">factorial</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="n">fac6</span> <span class="o">-&gt;</span>
      <span class="n">print</span><span class="o">(</span><span class="n">fac6</span><span class="o">,</span> <span class="n">x</span> <span class="o">-&gt;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Will never be printed"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>The entire idea of having a call stack is about providing a way for
the called functions to return the control to the callers.
But if we are never returning, then we don’t need a call stack, right?
Not so fast, some of you may say - what about passing arguments to 
the called functions,
call stack is used for that too. Yes, the arguments are also stored on
the call stack but with CSP we capture 
the values of arguments using closures.
Of course JVM does not know that our programs are in CSP form or that they 
would do fine without having a call stack at all.
Instead we get a new call stack frame every time we call something,
this results in <code class="highlighter-rouge">StackOverflowError</code> quickly when we call
e.g. <code class="highlighter-rouge">factorial(3000, r -&gt; ...)</code>.</p>

<p>Too avoid <code class="highlighter-rouge">StackOverflowError</code>s we may use a technique called trampolining. 
Trampolining in connection with CSP
could reduce the required call stack space to a constant number
of slots.
The idea of trampolining is very simple, we split computation into
parts and then we compute only the first part and <em>return</em> a 
continuation (called thunk) that is responsible for computing the rest. 
The returned continuation captures the result of the first computation in
its closure so we don’t have to recompute it.
Let’s see how a trampolined <code class="highlighter-rouge">+</code> operator would looks like:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">add3</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span>
            <span class="n">add</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">cont</span><span class="o">));</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Cont</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Thunk</span> <span class="nf">apply</span><span class="o">(</span><span class="n">R</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">private</span> <span class="kd">interface</span> <span class="nc">Thunk</span> <span class="o">{</span>
    <span class="n">Thunk</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that trampolined <code class="highlighter-rouge">+</code> operator splits its computation
into two parts: computing the sum and calling the continuation.
The called continuation will again split it’s work and so on and on.</p>

<p><code class="highlighter-rouge">add3</code> function illustrates two key points. 
One is that the logical flow of the program stays the same, we just
call the passed continuations like in a pure CSP program.
The other is, that to introduce trampolining we only need to modify
primitives provided by our programming language (operators and statements).
The program code stays the same.
Of course because Java is a statically-typed language we need to change 
functions return type from <code class="highlighter-rouge">void</code> into <code class="highlighter-rouge">Thunk</code>, but this is
a simple mechanical change that would not be necessary in 
a dynamically-typed language.</p>

<p>Next example illustrates how trampolined <code class="highlighter-rouge">if</code> statement and
<code class="highlighter-rouge">factorial</code> looks like. Notice that factorial code did not change,
not counting the return type:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">iff</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expr</span><span class="o">,</span>
                 <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">trueBranch</span><span class="o">,</span>
                 <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">falseBranch</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">expr</span><span class="o">)</span>
    <span class="o">?</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">trueBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">falseBranch</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">Thunk</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cont</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">eq</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">isNZero</span> <span class="o">-&gt;</span>
    <span class="n">iff</span><span class="o">(</span><span class="n">isNZero</span><span class="o">,</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">cont</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
      <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">nm1</span> <span class="o">-&gt;</span>
        <span class="n">factorial</span><span class="o">(</span><span class="n">nm1</span><span class="o">,</span> <span class="n">fnm1</span> <span class="o">-&gt;</span>
          <span class="n">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">fnm1</span><span class="o">,</span> <span class="n">cont</span><span class="o">)))));</span>
<span class="o">}</span></code></pre></figure>

<p>Because we are now performing computation “in parts”, we need 
a procedure that will be continually invoking returned thunks,
thus ensuring that out computation is making progress.
A procedure like this is called a trampoline:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">void</span> <span class="nf">trampoline</span><span class="o">(</span><span class="n">Thunk</span> <span class="n">thunk</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">thunk</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">thunk</span> <span class="o">=</span> <span class="n">thunk</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Cont</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">endCall</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">call</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="n">call</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">};</span>
<span class="o">}</span></code></pre></figure>

<p>We are also providing a new primitive operator <code class="highlighter-rouge">endCall</code> that
can be used to mark the last part of the computation.
Using <code class="highlighter-rouge">trampoline</code> we may now compute <code class="highlighter-rouge">factorial(3000)</code>
without any troubles:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">AtomicInteger</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
<span class="n">trampoline</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="mi">400000</span><span class="o">,</span> <span class="n">endCall</span><span class="o">(</span><span class="nl">res:</span><span class="o">:</span><span class="n">set</span><span class="o">)));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">())</span></code></pre></figure>

<p>As a side effect, we may now use trampoline to mix
CSP and imperative code in the same program.</p>

<p>CSP and trampolining are not mere theoretical concepts,
there where and are still used to implement e.g. LISP interpreters.
Continuations can also be used to simplify backtracking algorithms.
Source code for this blog post can be found
<a href="https://github.com/marcin-chwedczuk/reng/tree/master/test/pl/marcinchwedczuk/continuations">here</a>.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Jak zacząć przygodę z elektroniką</title>
	  <link>//jak-zaczac-przygode-z-elektronika</link>
	  <author></author>
	  <pubDate>2019-12-30T01:00:01+01:00</pubDate>
	  <guid>//jak-zaczac-przygode-z-elektronika</guid>
	  <description><![CDATA[
	     <p>Parę miesięcy temu postanowiłem powrócić do mojego
hobby z czasów dzieciństwa: elektroniki.
Powrót, po ponad dziesięciu latach przerwy, okazał
się być trudniejszy niż przypuszczałem,
a droga do pierwszego działającego układu 
pełna frustracji i porażek.</p>

<p>Pomimo tego radość z wykonania najprostszego generatora,
który naprzemiennie migał diodami LED dostarczyła
mi tak dużo radości i frajdy, że przez kilka następnych
wieczorów oddałem się w całości budowie kolejnych układów.</p>

<p>Niestety elektronika jako hobby, nie jest
już w Polsce tak popularna jak 
miało to miejsce w końcówce lat dziewięćdziesiątych.
A szkoda, bo na zachodzie mamy obecnie do czynienia
z prawdziwym boomem na elektronikę.
Dobrze ilustrują to platformy takie jak
<a href="https://www.arduino.cc/">Arduino</a> czy
<a href="https://www.raspberrypi.org/">Raspberry PI</a>.
Nie wspominając już o modzie na retro-computing
(a więc na budowę prostych, często 8-bitowych komputerów wprost
z układów scalonych) uosabianej przez takie postaci
jak <a href="https://www.youtube.com/channel/UCS0N5baNlQWJCUrhCEo8WlA">Ben Eater</a>
i projekty jak <a href="https://monster6502.com/">The MOnSter 6502</a> i
<a href="https://gigatron.io/">Gigatron</a></p>

<p>Niestety nauka nowej umiejętności czy jest nią jazda samochodem,
czy język obcy czy też elektronika, nie jest prosta.
Na początkujących czyha wiele pułapek, które zniechęcają ich 
do dalszej nauki. Dlatego, aby ułatwić początkującym wejście w
świat elektronik, postawiłem podzielić się moimi doświadczeniami
(czytaj wpadkami)
i opisać problemy na jakie się natknąłem.
To jest pierwszy wpis z tej serii, w którym opisuję
pułapki które czekają nas przy zakupie pierwszych płytek
stykowych, przewodów i elementów elektronicznych. Zapraszam!</p>

<h4 id="płytka-stykowa">Płytka stykowa</h4>

<p>Według mnie najlepszym sposobem montażu układów, na początku
przygody z elektroniką są płytki stykowe.
Na rysunku poniżej przedstawiam przykład dwóch takich płytek:
<img src="assets/images/2019-12-30/plytki-stykowe-1.jpg" alt="Przykładowe płytki stykowe" /></p>

<p>Płytka oznaczona numerem 1, to przykład płytki droższej
która mimo to posiada kilka poważnych mankamentów.
Po pierwsze brakuje oznaczenia polaryzacji szyn zasilania,
co rodzi pole do przykrych w konsekwencjach pomyłek
(np. nieprawidłowe doprowadzenie zasilania do układu scalonego).
Po drugie szyny zasilania są “przecięte” w połowie płytki
(patrz strzałki). Tego typu “przecięcie” przydaje 
się gdy budujemy układy w których występują dwa poziomy
zasilania np. 3.3V i 5V. Większość początkujących
elektroników korzysta jednak z pojedynczego napięcia zasilania.
W praktyce okazywało się to tak denerwujące że musiałem dodać specjalne
oznaczenia markerem, żeby już więcej się nie zastanawiać dlaczego
połowa układu nie ma napięcia zasilania.</p>

<p>Płytka oznaczona numerem 2 to tania płytka (7 PLN za sztukę),
produkcji chińskiej. Mimo to producent
nie oszczędzał na pomocnych oznaczeniach. 
Każda z czterech linii zasilania
ma swój kolor, każde gniazdo jest adresowane 
za pomocą kombinacji litery (a-j) i liczby (1-65).
Może, na pierwszy rzut oka nie wydaje się to
przydatne, ale w internecie można znaleźć mnóstwo
projektów pomyślanych specjalnie do wykonania
na płytkach stykowych, które zawierają instrukcje
typu: “umieść rezystor 1k w gniazdach 5f i 5c”.</p>

<p>Niestety niska cena płytki nr. 2 znalazła negatywne
odbicie w jakości styków. Korzystanie z tej płytki
rodziło sporo kłopotów: często miałem problemy żeby
włożyć końcówkę przewodu lub nóżkę elementu do danego
gniazda. Czasami pomagało wetknięcie szpilki, czasami
włożenie przewodów najpierw do sąsiadujących gniazd
a dopiero potem przeniesienie ich do tego właściwego.
Czasami pomagało “wiercenie” w gnieździe nóżką diody LED.
Innymi słowy, spora część radości wynikającej z budowania układu 
ustępowała miejsca frustracji związanej z niskiej jakości płytką.</p>

<p>Przed zakupem płytek polecam przeczytać
recenzje, zarówno na polski forach jak i na zagranicznych (oraz
na Amazonie). Osobiście, nie znalazłem jak do tej pory
płytki stykowej godnej polecenia, jeżeli taką znacie to
proszę dodajcie komentarz z linkiem.</p>

<p>Wróćmy jeszcze na chwilę do zdjęcia płytek. 
Część oznaczona numerem cztery to pojedyncza szyna zasilania,
odseparowana od płytki stykowej typu dwa. 
Jak się okazuje od każdej płytki możemy oderwać jedną lub
obie szyny zasilania. Przy wykonywaniu tej operacji
przydaje się nożyk do kartonu, który pozwoli nam
rozciąć izolacyjny materiał znajdujący się na spodzie płytki.</p>

<p>Każda płytka stykowa posiada wypustki, które pozwalają
zbudować “megapłytkę” z dwóch lub większej liczby 
pojedynczych płytek (z obecnymi lub oderwanymi szynami zasilania).
Niestety płytki wyprodukowane przez różne firmy rzadko
są ze sobą kompatybilne. 
Poniżej zamiejszczam zdjęcie takiej “megapłytki”:
<img src="assets/images/2019-12-30/megaplytka.jpg" alt="Megapłytka" /></p>

<p>Oprócz pełonowymiarowych płytek, na ryku dostępne są też
mniejsze modele:
<img src="assets/images/2019-12-30/mini.jpg" alt="Mini płytki" />
Osobiście nie polecam ich początkującym, gdyż są
po prostu za małe.</p>

<p>Wydawało by się że orientacja płytki nie ma żadnego znaczenia.
Warto jednak przy budowie układów podążać za sprawdzoną regułą,
która mówi że prądy powinny płynąć z góry na dół, a sygnały
od lewej do prawej. W praktyce oznacza to że górna wewnętrzna
szyna zasilająca powinna być podłączona do plusa zasilania,
a dolna wewnętrzna do minusa. Przestrzeganie tej
zasady znacznie ułatwi nam doprowadzanie zasilania do układów scalonych.</p>

<p>A skoro już jesteśmy przy układach scalonych, większość
z nich nie posiada prostopadłych nóżek. Zamiast tego
nóżki rozchodzą się nieco na boki, co uniemożliwia umieszczenie
takiego układu w płytce stykowej. Rozwiązaniem tego
problemu jest przygięcie nóżek scalaka przed włożeniem go
do płytki:
<img src="assets/images/2019-12-30/nogi.jpg" alt="Ach te nóżki" /></p>

<p>Zanim opuścimy temat płytek warto jeszcze dodać, że
na opakowaniu płytki znajduje się jeden z najważniejszych
jej parametrów, mianowicie zakres grubości drutów/końcówek/wyprowadzeń
z jakimi płytka współpracuje. Ten parametr okaże się istotny
gdy będziemy planować zakup przewodów kompatybilnych
z płytką (czytaj nie każdy przewód pasuje do danej płytki).</p>

<h4 id="przewody--połączenia--zworki">Przewody / połączenia / zworki</h4>

<p>Oprócz płytki stykowej, przy budowie układów będziemy
też potrzebowali całej masy przewodów.
Osobiście polecam zakup zestawu przewodów
takich jak <a href="https://www.adafruit.com/product/3174">Adafruit Hook-up Wire</a>,
wraz ze szczypcami do ściągania izolacji takimi
jak <a href="https://www.adafruit.com/product/147">Adafruit Wire Stripper</a>:
<img src="assets/images/2019-12-30/druty.jpg" alt="Przewody" />
Przy zakupie warto zwracać uwagę czy na pewno kupujemy
<em>jednożyłowy</em>, <em>cynowany</em> przewód miedziany, a nie na przykład
wielożyłowy (czysta miedź pokrywa się
nieprzewodzącą warstwą tlenków, cynowany drut zapewni
nam znacznie lepszą jakość połączeń).</p>

<p>Przedstawiony powyżej zestaw przewodów ma grubość
drutu AWG 22 (miara amerykańska), co przelicza się
na polskie 0.6438 milimetra średnicy.
Płytki stykowe z pierwszej sekcji, pracują poprawnie z przewodami
o grubościach 0.3-0.8 milimetra, a więc są kompatybilne z tym
zestawem przewodów.</p>

<p>Ze względu na rosnące ceny miedzi zakup zestawów takich
jak te przedstawione powyżej, może wiązać się ze sporym wydatkiem.
Należy jednak pamiętać że
jeden zestaw przewodów powinien zaspokoić nasze potrzeby na mniej więcej rok,
a szczypce to wydatek jednorazowy.
Obecna cena powyższego zestawu przewodów w sklepie <a href="https://pl.mouser.com/">Mouser</a>
wynosi około 120PLN. Oczywiście zawsze warto sprawdzić czy
nie znajdziemy lepszej oferty w polskich sklepach, na ceneo czy
w końcu na AliExpressie.</p>

<p>Oprócz zestawu przewodów, w sklepach można znaleźć również zestawy zworek
(numer jeden na zdjęciu):
<img src="assets/images/2019-12-30/zwory.jpg" alt="Przewody ciąg dalszy" />
Zestawy takie są, w stosunku do ich ceny, kompletnie bezużyteczne.
Zwory prawie nigdy nie miały potrzebnej długości gdy chciałem
ich użyć. Krótkie zworki kończyły się bardzo szybko, podczas
gdy długich zostawał nadmiar. Jednym słowem: nie polecam.</p>

<p>Polecam za to zakup elastycznych przewodów połączeniowych
(numer dwa i trzy na zdjęciu).
Przewody typu trzy dostępne są w zestawach o dość przystępnej
cenie. Przewody typu dwa występują we wstęgach, które można
rozrywać (nawet na pojedyncze przewody) wedle upodobań.</p>

<p>Do zabawy z płytkami stykowymi i Arduino potrzebne nam będą przede
wszystkim przewody z wtykami męskimi (patrz numer trzy).
Do zabawy z Rasbperry PI,
a także z modułami do Arduino (np. czujniki ruchu) przydadzą się
przewody męsko-żeńskie (patrz numer dwa).</p>

<p>Czasami zdarza się, że przewody będące częścią zestawów mają
końcówki wtyków pokryte ochronną warstwą plastiku którą łatwo
przeoczyć. Jeżeli przewód “źle łączy” należy sprawdzić czy
końcówki nie posiadają takiej ochronnej izolacji i ewentualnie
ją usunąć.</p>

<p>Warto zarezerwować sobie dwa kolory (np. czarny i czerwony)
na oznaczenie przewodów które mają potencjał masy i plusa zasilania.
Warto też pomyśleć o konwencji użycia kolorów, na przykład: przewód biały to
zawsze sygnał zegara.
Poza tym im więcej kolorów mamy do dyspozycji tym lepiej.</p>

<h4 id="pozostałe-narzędzia">Pozostałe narzędzia</h4>

<p>Pozostałe przydatne narzędzia to:</p>

<ol>
  <li>Mały płaski śrubokręt</li>
  <li><em>Szczypce tnące boczne</em>
 do ucinania zbyt długich wyprowadzeń elementów
 (<a href="https://botland.com.pl/pl/szczypce/5851-szczypce-tnace-boczne-yato-yt-2081-115mm-5906083920813.html">model ze zdjęcia</a>)</li>
  <li>Oraz najbardziej przydatna z całej tej
 trójki, bo pozwalająca wygodnie wyjmować i wkładać przewody
 połączeniowe - pęseta
 (<a href="https://sklep.avt.pl/peseta-antystatyczna-122mm-prosta-ostra-esd-10.html">model ze zdjęcia</a>)</li>
</ol>

<p><img src="assets/images/2019-12-30/szczypce.jpg" alt="Przydatne narzędzia" /></p>

<p>Przycinanie wyprowadzeń elementów za pomocą
szczypiec może być odrobinę niebezpieczne.
Nóżki, na przykład dużych diod LED, podczas przycinania mają tendencje to
“wystrzeliwania” w znanym tylko sobie kierunku, dlatego
warto też pomyśleć o zakupie 
<a href="https://botland.com.pl/en/goggles/5626-okulary-yt-7367-5906083973611.html">okularów ochronnych</a>.</p>

<p>Ostatnim, naprawdę niezbędnym narzędziem, w jaki
powinniśmy się zaopatrzyć jest multimetr.
Ja używam następującego modelu, mało znanej chińskiej
marki i jestem z niego całkowicie zadowolony:
<img src="assets/images/2019-12-30/multi.jpg" alt="Multimetr" /></p>

<h4 id="elementy-elektroniczne">Elementy elektroniczne</h4>

<p>Można by pomyśleć, że po całym tym zamieszaniu z płytkami,
narzędziami i multimetrem zakup elementów elektronicznych 
będzie czystą przyjemnością.
Nic bardziej mylnego!
Pierwszym zaskoczeniem jakie mnie spotkało, była niewielka
średnica wyprowadzeń resystorów zakupionych w zestawie
“dla początkujących”. Średnica była tak mała, że czasami
trudno było uzyskać dobre połączenie z płytką stykową.
Ostatecznie skończyłem z <a href="https://botland.com.pl/pl/rezystory-przewlekane/13895-zestaw-rezystorow-cf-tht-14w-velleman-kres-e3-480szt-5410329241803.html">tym zestawem rezystorów</a></p>

<p><img src="assets/images/2019-12-30/vkit.jpg" alt="Zestaw velleman-kit" /></p>

<p>Dobrze ilustruje to powyższe zdjęcie, rezystor oznaczony
numerem jeden pochodzi z taniego zestawu “dla początkujących”.
Posiada długie i cienkie wyprowadzenia słabo współpracujące z
płytkami stykowymi. Rezystor oznaczony numerem dwa pochodzi
z zestawu velleman’a - wyraźnie widać krótsze, ale za to
grubsze i bardziej masywne wyprowadzenia.</p>

<p>Osobiście odradzam również zakup rezystorów o mocy większej
niż 0,25W. Rezystory 1W w porównaniu do 0,25W to prawdziwe olbrzymy.</p>

<p>W przeciwieństwie do rezystorów, zakup diod LED
(polecam “duże” 5mm) czy kondensatorów nie sprawiał
większych problemów, elementy po prostu działały.</p>

<p>Z kolei zakup przycisków (“switchy”) i potencjometrów
sprawił mi trochę kłopotów. Okazuje się że wiele elementów
występuje w dwóch wersjach: do wlutowania i do płytek stykowych.
Popatrzmy na zdjęcie:
<img src="assets/images/2019-12-30/proste.jpg" alt="Elementy do wlutowania i do płytek stykowych" />
Elementy z grupy pierwszej są przeznaczone do wlutowania.
Elementy z grupy drugiej, charakteryzującej się prostymi
wyprowadzeniami, są przewidziane do umieszczenia na płytkach
stykowych. Zawsze należy dokładnie sprawdzić czy na pewno
kupujemy takie elementy, jakich naprawdę potrzebujemy.</p>

<p>Na koniec, żeby nie tracić czasu na mozolne odnajdywanie potrzebnych
elementów, warto zaopatrzyć się w dobry organizer:
<img src="assets/images/2019-12-30/organizer.jpg" alt="Organizer" /></p>

<h4 id="zasilanie">Zasilanie</h4>

<p>Początkowo zasilałem moje układy z baterii 9V.
Wykorzystywałem do tego celu kijankę (numer jeden),
gniazdo które można włożyć w szynę zasilania płytki stykowej (numer trzy) oraz
konwerter (numer dwa):
<img src="assets/images/2019-12-30/zas1.jpg" alt="Zasilanie z bateri 9V" />
Konwerter okazał się konieczny, ponieważ zakupu
gniazda dokonałem “na oko”, nie będąc świadom że
istnieje wiele różnych rozmiarów wtyków zasilania.</p>

<p>Osobiście nie polecam tego sposobu zasilania.
Po pierwsze jesteśmy zdani na napięcie baterii, a wiele
układów wymaga niestandardowych napięć 3,3V lub 5V.
Po drugie zaśmiecamy środowisko zużytymi bateriami,
przy jednoczesnym zubożaniu naszego portfela.</p>

<p>Najlepszym rozwiązaniem, dla osób dysponujących zapasem
gotówki jest kupno zasilacza laboratoryjnego,
nazywanego również zasilaczem warsztatowym.
Dla wszystkich pozostałych, przynajmniej na początku,
dobrym kompromisem jest zakup 
<a href="https://sklep.avt.pl/avt3072.html">zasilacza płytek stykowych</a>:
<img src="assets/images/2019-12-30/zas2.jpg" alt="Zasilacz do płytek stykowych" />
Należy pamiętać że sam zasilacz to tylko prosta płytka PCB
(ang. printed circuit board, pl. płytka drukowana), do
pracy potrzebny jej jest <a href="https://sklep.avt.pl/zasilacz-impulsowy-12v-1-5a-18w-dc2-5-5-5.html">zasilacz impulsowy</a> - oznaczony na zdjęciu numerem dwa.</p>

<p>Przedstawiony powyżej zasilacz, który służy mi już kilka miesięcy,
niestety nie jest pozbawiony wad.
Najpoważniejsza z nich jest taka, że nie jesteśmy ostrzegani
o zwarciu przewodów zasilania.
Istnieją na rynku zasilacze które np. piszczą
gdy dojdzie do zwarcia.
W powyższym zasilaczu, zwarcie można rozpoznać jedynie po
silnie rozgrzanym radiatorze.
Dlatego, pomimo że podałem linki do sklepu, zachęcam was do
poszukania lepszego modelu lub jeżeli już taki
posiadacie do pozostawienia komentarza z linkiem.</p>

<h4 id="sklepy">Sklepy</h4>

<p>Na koniec lista sklepów z których jestem
względnie zadowolony:</p>

<ul>
  <li>
    <p><a href="https://sklep.avt.pl/">Sklep AVT</a> związany od wielu lat
 z czasopismem “Elektronika dla wszystkich”</p>
  </li>
  <li>
    <p><a href="https://botland.com.pl/pl/">Botland</a></p>
  </li>
</ul>

<p>Z zagranicznych warto wspomnieć:</p>

<ul>
  <li><a href="https://pl.mouser.com/">Mouser</a> - ten sklep
 śmiało można nazwać profesjonalnym.
 Można łatwo i szybko (czas dostawy nie przekracza tygodnia)
 dostać układy praktycznie niedostępne na polskim rynku.
 Ale uwaga, ceny produktów podane są na modłę amerykańską, 
 a więc nie zawierają
 23% podatku VAT. Najeży o tym pamiętać porównując oferty.</li>
</ul>

<p>Oczywiście zawsze warto korzystać z porównywarek cen
i sprawdzać opinie sklepów na forach internetowych.
Bardziej odważni i cierpliwi mogą spróbować szczęścia na AliExpressie.</p>

<p>Na zakończenie, “starożytne” i niestety niedziałające, układy
scalone polskiej produkcji (sic!), które otrzymałem od jednego
z polskich sklepów:
<img src="assets/images/2019-12-30/cemi.jpg" alt="Polskie scalaki" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>Pitfalls of using Mockito with Scala</title>
	  <link>//pitfalls-of-using-Mockito-with-Scala</link>
	  <author></author>
	  <pubDate>2019-12-22T01:00:01+01:00</pubDate>
	  <guid>//pitfalls-of-using-Mockito-with-Scala</guid>
	  <description><![CDATA[
	     <p>I need to test my new, shiny Scala code.
Usually I write tests in <a href="http://www.scalatest.org/">ScalaTest</a>,
but for generating stubs I still use good, old
<a href="https://site.mockito.org/">Mockito</a>.
What can possibly go wrong?
I open a new tab in my editor and start hacking test code.</p>

<p>For the first surprise I don’t have to wait too long.
In my code I use <a href="https://docs.scala-lang.org/overviews/core/value-classes.html">value classes</a> 
to represent entity IDs.
For example I use <code class="highlighter-rouge">CustomerId</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span></code></pre></figure>

<p>When I tried to mock <code class="highlighter-rouge">customerId</code> method (property?):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">RequestContext</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">customerId</span><span class="k">:</span> <span class="kt">CustomerId</span>
  <span class="c1">// ...
</span><span class="o">}</span></code></pre></figure>

<p>in my test, Mockito started complaining about wrong return types
and refused to cooperate:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// inside test
</span><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="cm">/* Fails with WrongTypeOfReturnValue exception:
*
* CustomerId cannot be returned by customerId()
* customerId() should return long
*/</span>
<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>Of course my <code class="highlighter-rouge">CustomerId</code> <a href="https://docs.scala-lang.org/overviews/core/value-classes.html">value class</a> is here to blame…</p>

<p>In Scala, value classes offer type safety of normal classes with
performance of the primitives.
Scala compiler achieves this, simply by replacing the value
class type by the primitive type, wherever possible.
So I grabbed <code class="highlighter-rouge">javap</code> and took a look at the generated bytecode,
and indeed there is a <code class="highlighter-rouge">long</code> there:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">target/scala-2.13/classes$ javap RequestContext.class 
Compiled from "RequestContext.scala"
public interface RequestContext {
  public abstract long customerId();
  // ...
}</code></pre></figure>

<p>Mockito uses reflection to figure out which type
a given method returns.
This gives us little hope for a nice solution.
We can only try to hack around the problem, for example
this monstrosity works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Object</span><span class="o">])</span>
  <span class="o">.</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="n">box</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="n">assert</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span> <span class="o">==</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>We use <code class="highlighter-rouge">asInstanceOf[Object]</code> to fool Scala’s type system
and then return a <code class="highlighter-rouge">java.lang.Long</code> instance.</p>

<p>Yeah it works but it is not nice… But hey, first get the job done, then
get it done well. Let’s move on to the next test…</p>

<p>I have to verify that a given method was called.
This time I should have more luck, right?
So I wrote another test and I ran it:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// works perfectly 
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// does NOT WORK 
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">any</span><span class="o">())</span></code></pre></figure>

<p>But I saw the results I was completly perplexed.
Verification with <code class="highlighter-rouge">RequestId(123L)</code> worked but the one with
<code class="highlighter-rouge">any()</code> did not. But what is worse the second verification
thrown <code class="highlighter-rouge">NullPointerException</code>. NPE? Really?</p>

<p>My brain was racing, and after a few seconds a thought strike me:
it’s these pesky value classes again!</p>

<p>And I was right! Value classes in Scala cannot be <code class="highlighter-rouge">null</code>!
For example, in Scala REPL:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">FooId</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">FooId</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">FooId</span> <span class="o">=</span> <span class="kc">null</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FooId</span><span class="o">]</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">FooId</span> <span class="o">=</span> <span class="nc">FooId</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">id</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// And more...
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">o</span><span class="k">:</span> <span class="kt">Object</span> <span class="o">=</span> <span class="kc">null</span>
<span class="n">o</span><span class="k">:</span> <span class="kt">Object</span> <span class="o">=</span> <span class="kc">null</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FooId</span><span class="o">]</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">NullPointerException</span>
  <span class="o">...</span> <span class="mi">33</span> <span class="n">elided</span></code></pre></figure>

<p><code class="highlighter-rouge">any()</code> matcher that comes with Mockito has a very simple
implementation:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">any</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">anyObject</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Deprecated</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">anyObject</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">reportMatcher</span><span class="o">(</span><span class="n">Any</span><span class="o">.</span><span class="na">ANY</span><span class="o">);</span>
  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>that always returns <code class="highlighter-rouge">null</code>.</p>

<p>The method that I tried to check, has a signature:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">RequestContext</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">setRequestId</span><span class="o">(</span><span class="n">requestId</span><span class="k">:</span> <span class="kt">RequestId</span><span class="o">)</span>
  <span class="c1">// ...
</span><span class="o">}</span></code></pre></figure>

<p>and since <code class="highlighter-rouge">RequestId</code> is a value class, the “real” JVM signature is:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">public abstract void setRequestId(long);</code></pre></figure>

<p>When I write <code class="highlighter-rouge">verify(...).setRequestId(any())</code> 
Scala compiler adds instructions that convert the <em>object</em> returned
by <code class="highlighter-rouge">any()</code> (remember generics does not exist on JVM level, so all
these <code class="highlighter-rouge">T</code>s and <code class="highlighter-rouge">V</code>s are just <code class="highlighter-rouge">Object</code>s at runtime) to <code class="highlighter-rouge">long</code>.
And this is the reason why I got <code class="highlighter-rouge">NullPointerException</code> earlier.</p>

<p>In bytecode it looks like this:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">19: invokestatic  #33 // Method org/mockito/Mockito.verify:(Ljava/lang/Object;)Ljava/lang/Object;
22: checkcast     #17 // class RequestContext
25: invokestatic  #39 // Method org/mockito/ArgumentMatchers.any:()Ljava/lang/Object;
28: checkcast     #41 // class RequestId
31: invokevirtual #45 // Method RequestId.id:()J
34: invokeinterface #29, 3 // InterfaceMethod RequestContext.setRequestId:(J)V</code></pre></figure>

<p>and the NPE is thrown by the instruction at the offset <code class="highlighter-rouge">31</code>.</p>

<p>Now I understand the problem, but I still want to use <code class="highlighter-rouge">any()</code> matcher.
There must be a trick to make it return a valid <code class="highlighter-rouge">RequestId</code>.
But then I realized that even if I found such a way, I would be
bitten again by <code class="highlighter-rouge">WrongTypeOfReturnValue</code> exception or
something similar, since
the method takes <code class="highlighter-rouge">long</code> not <code class="highlighter-rouge">RequestId</code>. What I really need is
a way to use <code class="highlighter-rouge">anyLong()</code> with <code class="highlighter-rouge">setRequestId</code>. It was a good
enough challenge to
start my evil alter-ego working on some frankensteinian solution.
And I found it, I FOUND IT!, I FOUND IT!!! Ehmm… and here it is:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">])</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="c1">// works again
</span><span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="n">anyLong</span><span class="o">()))</span>
<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span>
  <span class="nc">RequestId</span><span class="o">(</span><span class="nc">ArgumentMatchers</span><span class="o">.</span><span class="n">eq</span><span class="o">(</span><span class="mi">123L</span><span class="o">)))</span></code></pre></figure>

<p>A perfect combination of beauty and evil…</p>

<p>The trick that I used here is that Mockito does not care,
where the matcher is located, it only cares about the time when it
is called. As long as I call <code class="highlighter-rouge">anyLong()</code> after the call to
<code class="highlighter-rouge">verify(...)</code> and before the call to <code class="highlighter-rouge">.setRequestId(...)</code>,
Mockito will work. Actually we may wrap <em>any</em> matcher in
as many dummy calls as we want, as in <code class="highlighter-rouge">a(b(c(d(any()))))</code>,
only the fact that it was called counts.</p>

<p>It can’t be worse right? Two tests, two hacks…</p>

<p>But only I wrote my third test, I was slapped by the next problem,
this time caused by default parameters:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">SomeTrait</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">method</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="n">test</span><span class="o">(</span><span class="s">"..."</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">])</span>

 <span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

 <span class="cm">/* This call fails with:
 * Argument(s) are different! Wanted:
 *  someTrait.method(3, 100);
 * Actual invocations have different arguments:
 *  someTrait.method(3, 0);
 */</span>
 <span class="c1">// verify(someTrait).method(3, 100)
</span>
 <span class="c1">// works
</span> <span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>WTF? Not again… Another strange problem that forces me
to look under the bonnet.</p>

<p>Let’s look at the bytecode using <code class="highlighter-rouge">javap -c</code>:</p>

<figure class="highlight"><pre><code class="language-no-highlight" data-lang="no-highlight">// bytecode of `someTrait.method(3)`
// (some code skipped here)
// 3 - load first arg onto the stack
10: iconst_3

// Scala Magic(TM), call a method to get the second
// argument's default value and push it onto the stack:
// someTrait.method$default$2()
11: aload_0
12: invokeinterface #27,  1

// finally call the `method` method
17: invokeinterface #31,  3
// (some code skipped here)</code></pre></figure>

<p>So the Scala compiler calls a hidden method, with a name
<code class="highlighter-rouge">methodName$default$parameterIndex</code> on the trait,
to figure out what value should be used as a value
of the default parameter. Wow! I didn’t expect something
like that!</p>

<p>If only I could stub this <code class="highlighter-rouge">method$default$2</code> or something :thinking:
:thinking: :thinking:
…oh wait I could:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">])</span>
<span class="n">when</span><span class="o">(</span><span class="n">someTrait</span><span class="o">.</span><span class="n">method$default$2</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>

<span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="c1">// it works!
</span><span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span></code></pre></figure>

<p>Excellent. It is working perfectly but now I have three tests
and three hacks. Surely I am doing something wrong here.</p>

<p>And so I harnessed the power of Google (after spending
some time looking at the pictures of stoats;
hey they are really cute) and found this gem:</p>

<p><a href="https://github.com/mockito/mockito-scala">Mockito-Scala</a></p>

<p>I plug it into my project (it even has a special version
for ScalaTest) and suddenly everything started to working
as it should be.</p>

<p>Stubbing works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.mockito.ArgumentMatchersSugar._</span> <span class="c1">// from Mockito-Scala
</span><span class="k">import</span> <span class="nn">org.mockito.MockitoSugar._</span>
<span class="c1">// Don't import Mockito or ArgumentMatchers
</span>
<span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">]</span>
<span class="n">when</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span><span class="o">).</span><span class="n">thenReturn</span><span class="o">(</span><span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">requestContext</span><span class="o">.</span><span class="n">customerId</span> <span class="o">==</span> <span class="nc">CustomerId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span></code></pre></figure>

<p>…and verification works:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">requestContext</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">RequestContext</span><span class="o">]</span>

<span class="n">requestContext</span><span class="o">.</span><span class="n">setRequestId</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">))</span>

<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">eqTo</span><span class="o">(</span><span class="nc">RequestId</span><span class="o">(</span><span class="mi">123L</span><span class="o">)))</span>
<span class="n">verify</span><span class="o">(</span><span class="n">requestContext</span><span class="o">).</span><span class="n">setRequestId</span><span class="o">(</span><span class="n">any</span><span class="o">[</span><span class="kt">RequestId</span><span class="o">])</span>
<span class="o">//</span> <span class="n">but</span> <span class="k">this</span> <span class="n">will</span> <span class="n">not</span> <span class="n">work</span><span class="k">:</span> <span class="kt">verify</span><span class="o">(</span><span class="kt">requestContext</span><span class="o">)</span><span class="kt">.setRequestId</span><span class="o">(</span><span class="kt">any</span><span class="o">)</span></code></pre></figure>

<p>even default parameters work:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someTrait</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">SomeTrait</span><span class="o">]</span>
<span class="n">someTrait</span><span class="o">.</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">verify</span><span class="o">(</span><span class="n">someTrait</span><span class="o">).</span><span class="n">method</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span></code></pre></figure>

<p>Yay!</p>

<p>Wanna see some real code? <a href="https://github.com/marcin-chwedczuk/blog-problems-when-using-mockito-from-scala/">Click here.</a></p>

<p>References:</p>
<ul>
  <li><a href="https://medium.com/@bruno.bonanno/introduction-to-mockito-scala-ede30769cbda?">Intro to Mockito-Scala (Medium)</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>

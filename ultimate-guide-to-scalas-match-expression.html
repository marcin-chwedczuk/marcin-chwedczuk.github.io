<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Ultimate guide to Scala's match expression</title>
    <meta name="description" content="A place where I share my thoughts about programming." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="http://localhost:4000//ultimate-guide-to-scalas-match-expression" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="Programming is Magic" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Ultimate guide to Scala's match expression" />
    <meta property="og:description" content="A place where I share my thoughts about programming." />
    <meta property="og:url" content="http://localhost:4000//ultimate-guide-to-scalas-match-expression" />
    <meta property="og:image" content="/assets/images/mc_cover3.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Ultimate guide to Scala's match expression" />
    <meta name="twitter:description" content="A place where I share my thoughts about programming." />
    <meta name="twitter:url" content="http://localhost:4000//ultimate-guide-to-scalas-match-expression" />
    <meta name="twitter:image:src" content="/assets/images/mc_cover3.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Programming is Magic",
    "name": "Ultimate guide to Scala's match expression",
    "url": "http://localhost:4000//ultimate-guide-to-scalas-match-expression",
    "image": "/assets/images/mc_cover3.jpg",
    "description": "A place where I share my thoughts about programming."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Programming is Magic" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <!-- <li class="nav-about " role="presentation"><a href="/about">About</a></li> -->

        
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/java">
                    java (25)
                    <!-- ultimate-guide-to-scalas-match-expression name: java -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/dotnet">
                    dotnet (11)
                    <!-- ultimate-guide-to-scalas-match-expression name: dotnet -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/architecture">
                    architecture (7)
                    <!-- ultimate-guide-to-scalas-match-expression name: architecture -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/algorithms">
                    algorithms (6)
                    <!-- ultimate-guide-to-scalas-match-expression name: algorithms -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/javascript">
                    javascript (5)
                    <!-- ultimate-guide-to-scalas-match-expression name: javascript -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/csharp">
                    csharp (4)
                    <!-- ultimate-guide-to-scalas-match-expression name: csharp -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/hibernate">
                    hibernate (3)
                    <!-- ultimate-guide-to-scalas-match-expression name: hibernate -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/linux">
                    linux (3)
                    <!-- ultimate-guide-to-scalas-match-expression name: linux -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/unit-testing">
                    unit-testing (3)
                    <!-- ultimate-guide-to-scalas-match-expression name: unit-testing -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/hardware-review">
                    hardware-review (2)
                    <!-- ultimate-guide-to-scalas-match-expression name: hardware-review -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/devcon">
                    devcon (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: devcon -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/eclipse">
                    eclipse (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: eclipse -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/git">
                    git (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: git -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/kotlin">
                    kotlin (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: kotlin -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/low-level">
                    low-level (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: low-level -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/postman">
                    postman (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: postman -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/powershell">
                    powershell (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: powershell -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/scala">
                    scala (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: scala -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/security">
                    security (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: security -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/sql">
                    sql (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: sql -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/tips">
                    tips (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: tips -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/vim">
                    vim (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: vim -->
                </a>
            </li>
        
            
            
            <li class="nav-about " role="presentation">
                <a href="/tag/windows">
                    windows (1)
                    <!-- ultimate-guide-to-scalas-match-expression name: windows -->
                </a>
            </li>
        

   </ul>
    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/assets/images/mc_cover3.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/"><img src="/assets/images/home.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-test tag-content">

        <header class="post-header">
            <h1 class="post-title">Ultimate guide to Scala's match expression</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
                    <a href='/author/mc'>Marcin Chwedczuk</a>
                
            
            <time class="post-date" datetime="2019-09-19">19 Sep 2019</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/scala'>Scala</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>Scala <code class="highlighter-rouge">match</code> expression is a very powerful tool.
In hands of an experienced developer it can be used to
create concise and easy to understand code,
yet novice programmers are often intimidated by it.
In this blog post I will describe how <code class="highlighter-rouge">match</code> expression
work. We will start with the basics and finish with the extractors.
After reading this post you will know how <code class="highlighter-rouge">case List(a, b, c)</code>
works and you will be able to write your own extractors.</p>

<h4 id="pattern-matching-values">Pattern matching values</h4>

<p><code class="highlighter-rouge">match</code> expression can be used (just like Java’s <code class="highlighter-rouge">switch</code>)
as a more robust <code class="highlighter-rouge">if</code> statement replacement.
For example we can write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">command</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">fetchNextCommand</span><span class="o">()</span>

<span class="n">command</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"ls"</span> <span class="k">=&gt;</span> <span class="n">printDirectoryContents</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"ps"</span> <span class="k">=&gt;</span> <span class="n">printProcesses</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"exit"</span> <span class="k">=&gt;</span> <span class="n">exitShell</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> expression, in opposite to Java’s <code class="highlighter-rouge">switch</code> is not
limited to strings, Enums and numeric types, but can also match
booleans, floating point numbers (although this isn’t a good idea)
and <code class="highlighter-rouge">null</code> literal.
We can also mix multiple value types in a single <code class="highlighter-rouge">match</code>
expression:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mf">3.1415</span>

<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's true"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"integer 3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="mf">3.1415</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pi approximation"</span><span class="o">)</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"null"</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">"foo"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"this 'foo' again!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="sc">'a'</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"character 'a'"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">pi</span> <span class="n">approximation</span></code></pre></figure>

<p>When we match an Enum value we are not required to
provide cases for all possible values of the Enum:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Color</span> <span class="o">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">White</span><span class="o">,</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Black</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">skyColor</span> <span class="k">=</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span>

<span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">weatherWildGuess</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">rain</span><span class="o">?</span></code></pre></figure>

<p>When a value cannot be pattern matched
a <code class="highlighter-rouge">scala.MatchError</code> runtime exception is thrown.
A special “catch all” case can be
provided to handle all previously unmatched values 
(Scala’s <code class="highlighter-rouge">case _</code> is a counterpart to Java’s <code class="highlighter-rouge">switch</code> <code class="highlighter-rouge">default</code> label):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"I don't know"</span>
<span class="o">}</span></code></pre></figure>

<p>“catch all” case should be the last one. 
Patterns are matched from top to bottom and the procedure
stops on the first matching <code class="highlighter-rouge">case</code> clause.</p>

<p>Sometimes we want to access the value matched by “catch all” case,
this can be done by replacing wildcard pattern (<code class="highlighter-rouge">_</code>)
with a variable name:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">weatherWildGuess</span> <span class="k">=</span> <span class="n">skyColor</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">White</span> <span class="k">=&gt;</span> <span class="s">"snow?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span> <span class="k">=&gt;</span> <span class="s">"rain?"</span>
  <span class="k">case</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Black</span> <span class="k">=&gt;</span> <span class="s">"a volcano eruption?"</span>
  <span class="k">case</span> <span class="n">unknownColor</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">"Cannot guess weather for sky color: $unknownColor"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Often it is required to execute the same code for multiple values.
With <code class="highlighter-rouge">match</code> this can be done using <code class="highlighter-rouge">|</code> (pipe) operator:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">answer</span><span class="o">.</span><span class="n">toLowerCase</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"y"</span> <span class="o">|</span> <span class="s">"yes"</span> <span class="o">|</span> <span class="s">"ok"</span> <span class="o">|</span> <span class="s">"proceed"</span> <span class="k">=&gt;</span>
    <span class="n">executeOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="s">"n"</span> <span class="o">|</span> <span class="s">"no"</span> <span class="o">|</span> <span class="s">"abort"</span> <span class="k">=&gt;</span>
    <span class="n">abortOperation</span><span class="o">()</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">askAgain</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">match</code> can also be used to match against <code class="highlighter-rouge">null</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">nullableValue</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> 

<span class="k">val</span> <span class="n">option</span> <span class="k">=</span> <span class="n">nullableValue</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Matching against Double <code class="highlighter-rouge">NaN</code> value is more problematic, since
<code class="highlighter-rouge">NaN == NaN</code> must always return <code class="highlighter-rouge">false</code> according to IEEE 754
Standard. To match against <code class="highlighter-rouge">NaN</code> we need to use a pattern guard:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span> <span class="k">=&gt;</span> <span class="s">"+∞"</span>

  <span class="c1">// WRONG way to match NaN
</span>  <span class="k">case</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">=&gt;</span> <span class="s">"this does not work"</span>
  <span class="c1">// RIGHT way to match NaN
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isNaN</span> <span class="k">=&gt;</span> <span class="s">"NaN"</span>

  <span class="c1">// catch-all
</span>  <span class="k">case</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span></code></pre></figure>

<p>We will return to pattern guards later.</p>

<h4 id="pattern-matching-class-instances">Pattern matching class instances</h4>

<p>Besides pattern matching primitive types, <code class="highlighter-rouge">match</code> can also be used
to compare normal class instances.
For this to work, a matched class must provide a sensible
override for <code class="highlighter-rouge">equals</code> and <code class="highlighter-rouge">hashCode</code> methods.</p>

<p>Before we’ll see an example, we need to learn about
a certain pitfall of Scala, illustrated by the following code:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NotEqualToAnything</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotEqualToAnything</span><span class="o">()</span>

<span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="c1">// false
</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">y</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
// false
</span><span class="o">//</span> <span class="nc">Whaaaaa</span><span class="o">!</span> <span class="nc">What</span> <span class="n">has</span> <span class="n">just</span> <span class="n">happened</span><span class="o">?</span></code></pre></figure>

<p>Why was <code class="highlighter-rouge">x</code> matched with <code class="highlighter-rouge">case y</code> despite <code class="highlighter-rouge">x.equals(y)</code> returning <code class="highlighter-rouge">false</code>?
Because the <code class="highlighter-rouge">y</code> in <code class="highlighter-rouge">case y</code> is a new variable introduced by “catch-all” clause 
to keep the matched value. It’s the same construct that we used
earlier to catch unknown colors (<code class="highlighter-rouge">case unknownColor</code>).
To tell Scala compiler that we want to use the value kept in
a variable instead of introducing a new one,
we just need to quote variable name using <code>&#96;</code> character:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`y`</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Whaaaaa! What has just happened?"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"no-match"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Returning to the instances matching, here is a working example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">JustInt</span><span class="o">(</span><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// hashCode() omitted for brevity
</span>  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">other</span><span class="k">:</span> <span class="kt">JustInt</span> <span class="o">=&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="n">n</span>
      <span class="k">case</span> <span class="k">_</span>              <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">j2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">j4</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="k">val</span> <span class="n">just3</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JustInt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">just3</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`j2`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 2!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j3`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 3!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">`j4`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"just 4!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">just</span> <span class="mi">3</span><span class="o">!</span></code></pre></figure>

<p>One more example before we move on. When we attempt to
match singleton objects we do not need to use <code>&#96;</code> escaping:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">X</span> <span class="o">{</span> <span class="o">}</span>
<span class="k">object</span> <span class="nc">Y</span> <span class="o">{</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">X</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">Y</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's Y!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">X</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"it's X!"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">it</span><span class="ss">'s </span><span class="n">X</span><span class="o">!</span></code></pre></figure>

<p><code class="highlighter-rouge">case X</code> will work just fine!</p>

<h4 id="pattern-matching-types">Pattern matching types</h4>

<p>Besides matching values, <code class="highlighter-rouge">match</code> can also perform <code class="highlighter-rouge">instanceof</code> tests:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">something</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">()</span>

<span class="n">something</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"a string!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"an int!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.Random</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"A Random instance!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"type unknown!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>As usual on JVM <code class="highlighter-rouge">instanceof</code> tests will not work with
parametrized types 
(while <code class="highlighter-rouge">class List&lt;T&gt;</code> is a generic type, 
<code class="highlighter-rouge">List&lt;T&gt;</code> usage like <code class="highlighter-rouge">List&lt;String&gt;</code> is
called a parametrized type). 
<a href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">Type erasure</a>
is here to blame:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// DO NOT WORK
</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"string list"</span> <span class="c1">// unreachable code warning
</span>  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"int list"</span> <span class="c1">// unreachable code warning
</span><span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">string</span> <span class="n">list</span> <span class="o">(</span><span class="n">sic</span><span class="o">!)</span></code></pre></figure>

<p>But not all is lost, we can still preform type tests
on generic types using wildcards (Scala <code class="highlighter-rouge">_</code> is a conterpart of Java <code class="highlighter-rouge">?</code>,
consider Scala’s <code class="highlighter-rouge">List[_]</code> and Java’s <code class="highlighter-rouge">List&lt;?&gt;</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a map"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a list"</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"a java's list"</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">a</span> <span class="n">list</span></code></pre></figure>

<p>So far we where not interested in the actual value of the variable,
but only in it’s type and so we just discarded the value using <code class="highlighter-rouge">case _: Type</code>
clause.
But nothing prevents us from assigning the already type checked
value to a variable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">map</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="n">jlist</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">jlist</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span></code></pre></figure>

<p>Every <code class="highlighter-rouge">case</code> clause creates it’s own lexical scope.
This means that we can reuse variable names across different <code class="highlighter-rouge">case</code>es:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">10</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>

  <span class="k">case</span> <span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">tmp</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="n">list</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span>
<span class="o">}</span></code></pre></figure>

<p>Pipe operator can be used with type checks too, but the
resulting code isn’t very readable:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span> <span class="o">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"a number!"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>If we want to use the value matched by this
pattern we need to use a pattern binder:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">num</span><span class="o">@(</span><span class="k">_:</span><span class="kt">Short</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Int</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:Long</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">].</span><span class="n">doubleValue</span><span class="o">())</span>
<span class="o">}</span></code></pre></figure>

<p>Pattern binders allow us to assign a value
that matches a <em>subpattern</em> to a variable.
In the extreme case this <em>subpattern</em> can be the entire
pattern, as it is in our case. We will return to
the pattern binders later.</p>

<h4 id="pattern-matching-tuples">Pattern matching tuples</h4>

<p>Pattern matching on tuples is supported out of the box.
We can match on tuple elements using all previously
described matchers. We can ignore a tuple element
by using “match all” wildcard (<code class="highlighter-rouge">_</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// unpacking tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// ignoring certain elements
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a"</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// matching values of the tuple
</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$e"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// matching types of the tuple
</span><span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="mf">1.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span>
         <span class="kc">true</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$s $n $b"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p>We can also match nested tuple structures:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">))</span>

<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $b $c $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span>
<span class="c1">// and with other constraints:
</span><span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$a $d"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<h4 id="pattern-guards">Pattern guards</h4>

<p>When pattern matching values, we often need to preform
some additional checks e.g. say we want to match all odd
or even integers. We can use pattern guards for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Since pattern guards use predicates (expressions that
return either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>) they are very flexible.
We can express both value and type checks using only
pattern guards:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">"foo"</span> <span class="k">=&gt;</span>
    <span class="s">"it's this 'foo' again!"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">=&gt;</span>
    <span class="s">"it's three!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="s">"foo"</span>
<span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"it's a string: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The problem with pattern guards is that they are
imperative. We should try to avoid them
as much as possible. Later we will learn about
extractors, that roughly speaking do the same
job as guards but in a more declarative way.</p>

<h4 id="extractors">Extractors</h4>

<p>Extractors are pattern guards on steroids.
They allow us to build highly readable DSLs and provide
a functional way to match, extract and transform program data.</p>

<p>The simplest extractor return just a <code class="highlighter-rouge">Boolean</code> value and
can be used as a pattern guard replacement:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Odd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Even</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Odd</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is odd"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Even</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i is even"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Generally speaking extractor is just a value with <code class="highlighter-rouge">unapply</code> method.
In the last example we used <code class="highlighter-rouge">object</code>s but extractor can also be kept in variables:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">multipleOf2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">multipleOf5</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MultipleOf</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m5</span> <span class="k">@</span> <span class="n">multipleOf5</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m5 is multiple of 5"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">m2</span> <span class="k">@</span> <span class="n">multipleOf2</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$m2 is multiple of 2"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Here we also used pattern binders to name the values that where matched
by <code class="highlighter-rouge">multipleOf</code> extractors.</p>

<p>Unfortunately in the current version of Scala we cannot create parametrized
extractors. In other words we cannot create a universal <code class="highlighter-rouge">multipleOf(n)</code> extractor.
This also means that pattern guards are not 100% replaceable by extractors.</p>

<p>As the name suggest, the extractors main purpose is to extract the
data from matched values.
Our next extractor will extract non-null values from nullable reference:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NonNull</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">arg</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">string</span> <span class="k">&lt;-</span> <span class="n">strings</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">string</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">NonNull</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"placeholder"</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Prints:
</span><span class="o">//</span> <span class="n">foo</span> <span class="n">placeholder</span> <span class="n">bar</span> <span class="n">placeholder</span></code></pre></figure>

<p><code class="highlighter-rouge">unapply</code> method can be generic, and should return <code class="highlighter-rouge">Some(value)</code> in
case of match and <code class="highlighter-rouge">None</code> when there is not match.</p>

<p>But extractors are not limited to returning only a single value.
In our next example we will learn how to extract <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> from
<code class="highlighter-rouge">java.util.List[E]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>

<span class="k">object</span> <span class="nc">JList</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">E</span>, <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">None</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">head</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">subList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="o">())</span>
      <span class="nc">Some</span><span class="o">((</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collections</span><span class="o">.</span><span class="n">emptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">](),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>To return multiple values from the extractor we just need to return a
tuple instead of a single value wrapped in <code class="highlighter-rouge">Option[A]</code>.</p>

<p>Extractors can be nested, this is a really powerful feature.
Given our previous <code class="highlighter-rouge">JList</code> extractor we can extract not only
the first element but any finite number of elements from the beginning of a list:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)))</span> <span class="k">=&gt;</span>
	 <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>To understand how this pattern works it’s helpful to look at the equivalent
for comprehension:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">tmp1</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="n">tmp2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">JList</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">tmp2</span><span class="o">)</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[$e1, $e2, $e3], tail: $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>When we extract multiple values, sometimes we want to
ignore some of them.
We can use <code class="highlighter-rouge">_</code> wildcard, that matches any value, for this purpose:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>We can also use pattern binders to assign names to
subpatterns, for example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="nc">JList</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">JList</span><span class="o">(</span><span class="n">e3</span><span class="o">,</span> <span class="k">_</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"3rd element is $e3"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"tail: $tail"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></figure>

<p>Matching Java’s <code class="highlighter-rouge">List[E]</code> using nested patterns is not
very comfortable. 
In reality we prefer a syntax like <code class="highlighter-rouge">case JList(e1, e2, e3)</code>.
Fortunately this can be done in Scala using extractors that return <code class="highlighter-rouge">Option[Seq[E]]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">JList2</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">scala.jdk.CollectionConverters._</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSeq</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 3 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"only 2 elements"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"4 elements: $a, $b, $c, $d"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Notice that we used <code class="highlighter-rouge">unapplySeq</code> instead of <code class="highlighter-rouge">unapply</code>.</p>

<p>With <code class="highlighter-rouge">Seq</code> extractor we can match “tail” of
the list using <code class="highlighter-rouge">_*</code> pattern:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">JList2</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head $head, tail $tail"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>The last thing that may come handy is the ability to write
extractor expression using either call notation <code class="highlighter-rouge">JList2(head, tail)</code>
or using operator notation <code class="highlighter-rouge">head JList2 tail</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">head</span> <span class="nc">JList</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">emptyList</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is mostly useful when we want to provide “operator like” experience
for the programmers. For example when we want to match
<code class="highlighter-rouge">List</code>s using <code class="highlighter-rouge">e1 :: e2 :: tail</code> expression.</p>

<h4 id="scala-buildin-extractors">Scala buildin extractors</h4>

<p>Let’s finish this post with a tour of Scala buildin extractors.</p>

<h5 id="case-classes">Case classes</h5>

<p>When you declare a case class in Scala:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
                 <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span></code></pre></figure>

<p>compiler, among other things, adds appropriate
<code class="highlighter-rouge">apply</code> and <code class="highlighter-rouge">unapply</code> methods to the case class companion object.
Thanks to this, pattern matching works with case classes out of the box:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">line</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Line</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">fy</span><span class="o">),</span> <span class="nc">Point</span><span class="o">(</span><span class="n">tx</span><span class="o">,</span> <span class="n">ty</span><span class="o">),</span> <span class="n">color</span><span class="nd">@_</span><span class="o">)</span> <span class="k">=&gt;</span> 
    <span class="n">s</span><span class="s">"line(($fx,$fy) -&gt; ($tx,$ty))"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> 
    <span class="s">"fail"</span>
<span class="o">}</span></code></pre></figure>

<h5 id="list">List</h5>

<p>Scala <code class="highlighter-rouge">List</code> implements a singly linked list.
<code class="highlighter-rouge">case object Nil</code> is used to represent an empty list.
As a singleton object, <code class="highlighter-rouge">Nil</code> is matched by <code class="highlighter-rouge">case Nil</code> clause.
<code class="highlighter-rouge">case class ::</code> is used as a linked list node, it contains
two fields <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">next</code>. Both <code class="highlighter-rouge">Nil</code> and <code class="highlighter-rouge">::</code>
extend abstract class <code class="highlighter-rouge">List[E]</code>.
Because name of the <code class="highlighter-rouge">case class ::</code> ends in a <code class="highlighter-rouge">:</code> (colon),
<code class="highlighter-rouge">::</code> when used as an operator is right associative:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="o">==</span> <span class="o">::(</span><span class="mi">1</span><span class="o">,</span> <span class="o">::(</span><span class="mi">2</span><span class="o">,</span> <span class="o">::(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span></code></pre></figure>

<p>After this overly simplistic explanation on how <code class="highlighter-rouge">List[E]</code> works, we
should now understand how pattern matching
works with lists:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"single element list $head"</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">e1</span> <span class="o">::</span> <span class="n">e2</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list $e1 $e2"</span><span class="o">)</span>
      
    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// single element list 1
// two element list 1 2
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>For programmers convenience <code class="highlighter-rouge">unapplySeq</code> is also
provided on <code class="highlighter-rouge">List</code> singleton object. It works very similar to 
our <code class="highlighter-rouge">JList</code> extractor:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lists</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">(),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">list</span> <span class="k">&lt;-</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"empty list"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"two element list: [$first, $second]"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"head: $head, tail: $tail"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// empty list
// head: 1, tail: List()
// two element list: [1, 2]
</span><span class="o">//</span> <span class="n">head</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span></code></pre></figure>

<p>It is a good exercise to create our own <code class="highlighter-rouge">List[E]</code> implementation
with all pattern matching facilities that standard <code class="highlighter-rouge">List[E]</code> provides.</p>

<h5 id="regexes">Regexes</h5>

<p>Scala <code class="highlighter-rouge">Regex</code> class provides <code class="highlighter-rouge">unapplySeq</code> extractor.
When a regex matches an input, the extractor will return
values for all matching groups within the regex.
You can create a group within a regex by using parentheses,
for example regex <code class="highlighter-rouge">(\d{3})-(\d{5})</code> has two groups
<code class="highlighter-rouge">\d{3}</code> and <code class="highlighter-rouge">\d{5}</code>. If you want to use parentheses
but do not wish to create a group, you just need to put
<code class="highlighter-rouge">?:</code> after starting <code class="highlighter-rouge">(</code> like in <code class="highlighter-rouge">(?:\d{3})?</code>.
If you want to learn more about regular expressions
you should check out <em>Mastering Regular Expressions</em> book by Jeffrey Friedl.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">phoneNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="s">"+48 123-123-123"</span><span class="o">,</span>
  <span class="s">"123-123-123"</span><span class="o">,</span>
  <span class="s">"123123123"</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">plPhoneNumber</span> <span class="k">=</span> <span class="s">"^(?:\\+(\\d{2})\\s)?(\\d{3}-\\d{3}-\\d{3})$"</span><span class="o">.</span><span class="n">r</span>
<span class="k">for</span> <span class="o">(</span><span class="n">phoneNo</span> <span class="k">&lt;-</span> <span class="n">phoneNumbers</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">phoneNo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">plPhoneNumber</span><span class="o">(</span><span class="n">countryPrefix</span><span class="o">,</span> <span class="n">phoneNo</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"countryPrefix: $countryPrefix, phoneNo: $phoneNo"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"no match"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Prints:
// countryPrefix: 48, phoneNo: 123-123-123
// countryPrefix: null, phoneNo: 123-123-123
</span><span class="o">//</span> <span class="n">no</span> <span class="k">match</span></code></pre></figure>

<p>In practice regex extractors are rarely used with <code class="highlighter-rouge">match</code> expression.</p>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/mc" style="background-image: url(/assets/images/mc.png)"><span class="hidden">mc's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/mc">Marcin Chwedczuk</a></h4>

                        
                            <p> A programmer, a geek, a human</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Warsaw, Poland</span>
                            <span class="author-link icon-link"><a href="http://marcinchwedczuk.pl"> http://marcinchwedczuk.pl</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Ultimate guide to Scala's match expression&amp;url=http://localhost:4000ultimate-guide-to-scalas-match-expression"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000ultimate-guide-to-scalas-match-expression"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:4000ultimate-guide-to-scalas-match-expression"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            
                <div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'marcinchwedczukgithubio'; // required: replace example with your forum shortname
        var disqus_identifier = '/ultimate-guide-to-scalas-match-expression';
        var disqus_url = 'http://localhost:4000/ultimate-guide-to-scalas-match-expression';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/assets/images/mc_cover2.jpg)" href="/doubles-and-unit-testing">
            <section class="post">
                <h2>Floating point numbers and Unit Testing</h2>
                <p>Floating point numbers are inherently imprecise. This can be problematic when we try to unit...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">Programming is Magic</a> &copy; 2019</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-82096342-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
